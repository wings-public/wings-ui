/*
 * GoJS v2.0.11 JavaScript Library for HTML Diagrams
 * Northwoods Software, https://www.nwoods.com/
 * GoJS and Northwoods Software are registered trademarks of Northwoods Software Corporation.
 * Copyright (C) 1998-2019 by Northwoods Software Corporation.  All Rights Reserved.
 * THIS SOFTWARE IS LICENSED.  THE LICENSE AGREEMENT IS AT: https://gojs.net/2.0.11/license.html.
 */
(function () {
    var t; function ba(a) { var b = 0; return function () { return b < a.length ? { done: !1, value: a[b++] } : { done: !0 } } } function ca(a) { var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator]; return b ? b.call(a) : { next: ba(a) } } function da(a) { for (var b, c = []; !(b = a.next()).done;)c.push(b.value); return c } var fa = "function" == typeof Object.create ? Object.create : function (a) { function b() { } b.prototype = a; return new b }, ha;
    if ("function" == typeof Object.setPrototypeOf) ha = Object.setPrototypeOf; else { var ia; a: { var ja = { a: !0 }, ka = {}; try { ka.__proto__ = ja; ia = ka.a; break a } catch (a) { } ia = !1 } ha = ia ? function (a, b) { a.__proto__ = b; if (a.__proto__ !== b) throw new TypeError(a + " is not extensible"); return a } : null } var la = ha;
    function ma(a, b) { a.prototype = fa(b.prototype); a.prototype.constructor = a; if (la) la(a, b); else for (var c in b) if ("prototype" != c) if (Object.defineProperties) { var d = Object.getOwnPropertyDescriptor(b, c); d && Object.defineProperty(a, c, d) } else a[c] = b[c]; a.wA = b.prototype } var na = "undefined" != typeof window && window === self ? self : "undefined" != typeof global && null != global ? global : self, oa = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) { a != Array.prototype && a != Object.prototype && (a[b] = c.value) };
    function pa(a) { if (a) { for (var b = na, c = ["Array", "prototype", "fill"], d = 0; d < c.length - 1; d++) { var e = c[d]; e in b || (b[e] = {}); b = b[e] } c = c[c.length - 1]; d = b[c]; a = a(d); a != d && null != a && oa(b, c, { configurable: !0, writable: !0, value: a }) } } pa(function (a) { return a ? a : function (a, c, d) { var b = this.length || 0; 0 > c && (c = Math.max(0, b + c)); if (null == d || d > b) d = b; d = Number(d); 0 > d && (d = Math.max(0, b + d)); for (c = Number(c || 0); c < d; c++)this[c] = a; return this } }); var qa = "object" === typeof self && self.self === self && self || "object" === typeof global && global.global === global && global || "object" === typeof window && window.window === window && window || {}; void 0 === qa.requestAnimationFrame && (qa.requestAnimationFrame = qa.setImmediate); function ra() { } function ua(a, b) { var c = -1; return function () { var d = this, e = arguments; -1 !== c && qa.clearTimeout(c); c = wa(function () { c = -1; a.apply(d, e) }, b) } } function wa(a, b) { return qa.setTimeout(a, b) } function xa(a) { return qa.document.createElement(a) }
    function v(a) { throw Error(a); } function ya(a, b) { a = "The object is frozen, so its properties cannot be set: " + a.toString(); void 0 !== b && (a += "  to value: " + b); v(a) } function w(a, b, c, d) { a instanceof b || (c = Aa(c), void 0 !== d && (c += "." + d), Ba(a, b, c)) } function z(a, b, c, d) { typeof a !== b && (c = Aa(c), void 0 !== d && (c += "." + d), Ba(a, b, c)) } function B(a, b, c) { "number" === typeof a && isFinite(a) || (b = Aa(b), void 0 !== c && (b += "." + c), v(b + " must be a real number type, and not NaN or Infinity: " + a)) }
    function Ba(a, b, c, d) { b = Aa(b); c = Aa(c); void 0 !== d && (c += "." + d); "string" === typeof a ? v(c + " value is not an instance of " + b + ': "' + a + '"') : v(c + " value is not an instance of " + b + ": " + a) } function Ca(a, b, c, d) { c = Aa(c); void 0 !== d && (c += "." + d); v(c + " is not in the range " + b + ": " + a) } function Da(a) { v(("string" === typeof a.className ? a.className : "") + " constructor cannot take any arguments.") }
    function Ea(a) { v("Collection was modified during iteration: " + a.toString() + "\n  Perhaps you should iterate over a copy of the collection,\n  or you could collect items to be removed from the collection after the iteration.") } function Fa(a, b) { v("No property to set for this enum value: " + b + " on " + a.toString()) } function Ga(a) { qa.console && qa.console.log(a) }
    function Ha() { qa.console && qa.console.log("Warning: List/Map/Set constructors no longer take an argument that enforces type.Instead they take an optional collection of Values to add to the collection. See 2.0 changelog for details.") } function Ia(a) { return "object" === typeof a && null !== a } function Ka(a) { return Array.isArray(a) || qa.NodeList && a instanceof qa.NodeList || qa.HTMLCollection && a instanceof qa.HTMLCollection } function La(a, b, c) { Ka(a) || Ba(a, "Array or NodeList or HTMLCollection", b, c) }
    function Ma(a) { return Array.prototype.slice.call(a) } function Na(a, b, c) { Array.isArray(a) ? b >= a.length ? a.push(c) : a.splice(b, 0, c) : v("Cannot insert an object into an HTMLCollection or NodeList: " + c + " at " + b) } function Oa(a, b) { Array.isArray(a) ? b >= a.length ? a.pop() : a.splice(b, 1) : v("Cannot remove an object from an HTMLCollection or NodeList at " + b) } function Qa() { var a = Ra.pop(); return void 0 === a ? [] : a } function Ta(a) { a.length = 0; Ra.push(a) }
    function Aa(a) { return null === a ? "*" : "string" === typeof a ? a : "function" === typeof a && "string" === typeof a.className ? a.className : "" } function Va(a) { if ("function" === typeof a) { if (a.className) return a.className; if (a.name) return a.name; var b = a.toString(); b = b.substring(9, b.indexOf("(")).trim(); if ("" !== b) return a._className = b } else if (Ia(a) && a.constructor) return Va(a.constructor); return typeof a }
    function Wa(a) { var b = a; Ia(a) && (a.text ? b = a.text : a.name ? b = a.name : void 0 !== a.key ? b = a.key : void 0 !== a.id ? b = a.id : a.constructor === Object && (a.Text ? b = a.Text : a.Name ? b = a.Name : void 0 !== a.Key ? b = a.Key : void 0 !== a.Id ? b = a.Id : void 0 !== a.ID && (b = a.ID))); return void 0 === b ? "undefined" : null === b ? "null" : b.toString() } function Ya(a, b) { if (a.hasOwnProperty(b)) return !0; for (a = Object.getPrototypeOf(a); a && a !== Function;) { if (a.hasOwnProperty(b)) return !0; var c = a.lA; if (c && c[b]) return !0; a = Object.getPrototypeOf(a) } return !1 }
    function Za(a, b, c) { Object.defineProperty($a.prototype, a, { get: b, set: c }) } function ab() { var a = bb; if (0 === a.length) for (var b = qa.document.getElementsByTagName("canvas"), c = b.length, d = 0; d < c; d++) { var e = b[d]; e.parentElement && e.parentElement.D && a.push(e.parentElement.D) } return a }
    function eb(a) { for (var b = [], c = 0; 256 > c; c++)b["0123456789abcdef".charAt(c >> 4) + "0123456789abcdef".charAt(c & 15)] = String.fromCharCode(c); a.length % 2 && (a = "0" + a); c = []; for (var d = 0, e = 0; e < a.length; e += 2)c[d++] = b[a.substr(e, 2)]; a = c.join(""); a = "" === a ? "0" : a; b = []; for (c = 0; 256 > c; c++)b[c] = c; for (c = d = 0; 256 > c; c++)d = (d + b[c] + 119) % 256, e = b[c], b[c] = b[d], b[d] = e; d = c = 0; for (var f = "", g = 0; g < a.length; g++)c = (c + 1) % 256, d = (d + b[c]) % 256, e = b[c], b[c] = b[d], b[d] = e, f += String.fromCharCode(a.charCodeAt(g) ^ b[(b[c] + b[d]) % 256]); return f }
    var fb = void 0 !== qa.navigator && 0 < qa.navigator.userAgent.indexOf("MSIE 9.0"), gb = void 0 !== qa.navigator && 0 < qa.navigator.userAgent.indexOf("MSIE 10.0"), ib = void 0 !== qa.navigator && 0 < qa.navigator.userAgent.indexOf("Trident/7"), jb = void 0 !== qa.navigator && 0 < qa.navigator.userAgent.indexOf("Edge/"), kb = void 0 !== qa.navigator && void 0 !== qa.navigator.platform && 0 <= qa.navigator.platform.toUpperCase().indexOf("MAC"), lb = void 0 !== qa.navigator && void 0 !== qa.navigator.platform && null !== qa.navigator.platform.match(/(iPhone|iPod|iPad)/i),
        Ra = []; Object.freeze([]); var bb = []; ra.className = "Util"; ra.Dx = "32ab5ff3b26f42dc0ed90f224d2913b5"; ra.adym = "gojs.net"; ra.vfo = "28e646fdb267"; ra.className = "Util"; function D(a, b, c) { qb(this); this.l = a; this.Wa = b; this.w = c } D.prototype.toString = function () { return "EnumValue." + this.Wa }; function sb(a, b) { return void 0 === b || null === b || "" === b ? null : a[b] } function tb(a, b, c, d) { a.classType !== b && (c = Aa(c), void 0 !== d && (c += "." + d), Ba(a, "function" === "a constant of class " + typeof b.className ? b.className : "", c)) }
    na.Object.defineProperties(D.prototype, { classType: { configurable: !0, get: function () { return this.l } }, name: { configurable: !0, get: function () { return this.Wa } }, value: { configurable: !0, get: function () { return this.w } } }); D.className = "EnumValue"; function ub() { this.rw = [] } ub.prototype.toString = function () { return this.rw.join("") }; ub.prototype.add = function (a) { "" !== a && this.rw.push(a) }; ub.className = "StringBuilder"; function xb() { } xb.className = "PropertyCollection";
    var E = {
        Fi: !1, $u: !1, Oy: !1, nA: !1, rA: !1, tx: !1, animationExperiments: !1, mA: null, trace: function (a) { qa.console && qa.console.log(a) }, uy: function (a) {
            var b = {}, c; for (c in a) {
            b.x = c; if ("licenseKey" !== b.x) {
                var d = a[b.x]; if (void 0 !== d.prototype) {
                b.qm = Object.getOwnPropertyNames(d.prototype); for (var e = { gk: 0 }; e.gk < b.qm.length; e = { gk: e.gk }, e.gk++) {
                    var f = Object.getOwnPropertyDescriptor(d.prototype, b.qm[e.gk]); void 0 !== f.get && void 0 === f.set && Object.defineProperty(d.prototype, b.qm[e.gk], {
                        set: function (a, b) {
                            return function () {
                                throw Error("Property " +
                                    a.qm[b.gk] + " of " + a.x + " is read-only.");
                            }
                        }(b, e)
                    })
                }
                }
            } b = { qm: b.qm, x: b.x }
            }
        }
    }; function Bb() { } Bb.prototype.reset = function () { }; Bb.prototype.next = function () { return !1 }; Bb.prototype.fd = function () { return !1 }; Bb.prototype.first = function () { return null }; Bb.prototype.any = function () { return !1 }; Bb.prototype.all = function () { return !0 }; Bb.prototype.each = function () { return this }; Bb.prototype.map = function () { return this }; Bb.prototype.filter = function () { return this }; Bb.prototype.zd = function () { }; Bb.prototype.toString = function () { return "EmptyIterator" };
    na.Object.defineProperties(Bb.prototype, { iterator: { configurable: !0, get: function () { return this } }, count: { configurable: !0, get: function () { return 0 } } }); Bb.prototype.first = Bb.prototype.first; Bb.prototype.hasNext = Bb.prototype.fd; Bb.prototype.next = Bb.prototype.next; Bb.prototype.reset = Bb.prototype.reset; var Cb = null; Bb.className = "EmptyIterator"; Cb = new Bb; function Db(a) { this.key = -1; this.value = a } Db.prototype.reset = function () { this.key = -1 };
    Db.prototype.next = function () { return -1 === this.key ? (this.key = 0, !0) : !1 }; Db.prototype.fd = function () { return this.next() }; Db.prototype.first = function () { this.key = 0; return this.value }; Db.prototype.any = function (a) { this.key = -1; return a(this.value) }; Db.prototype.all = function (a) { this.key = -1; return a(this.value) }; Db.prototype.each = function (a) { this.key = -1; a(this.value); return this }; Db.prototype.map = function (a) { return new Db(a(this.value)) };
    Db.prototype.filter = function (a) { return a(this.value) ? new Db(this.value) : Cb }; Db.prototype.zd = function () { this.value = null }; Db.prototype.toString = function () { return "SingletonIterator(" + this.value + ")" }; na.Object.defineProperties(Db.prototype, { iterator: { configurable: !0, get: function () { return this } }, count: { configurable: !0, get: function () { return 1 } } }); Db.prototype.first = Db.prototype.first; Db.prototype.hasNext = Db.prototype.fd; Db.prototype.next = Db.prototype.next;
    Db.prototype.reset = Db.prototype.reset; Db.className = "SingletonIterator"; function Gb(a) { this.qb = a; this.Ze = null; a.Ka = null; this.na = a.s; this.Ua = -1 } Gb.prototype.reset = function () { var a = this.qb; a.Ka = null; this.na = a.s; this.Ua = -1 }; Gb.prototype.next = function () { var a = this.qb; if (a.s !== this.na) { if (0 > this.key) return !1; Ea(a) } a = a.j; var b = a.length, c = ++this.Ua, d = this.Ze; if (null !== d) for (; c < b;) { var e = a[c]; if (d(e)) return this.key = this.Ua = c, this.value = e, !0; c++ } else { if (c < b) return this.key = c, this.value = a[c], !0; this.zd() } return !1 };
    Gb.prototype.fd = function () { return this.next() }; Gb.prototype.first = function () { var a = this.qb; this.na = a.s; this.Ua = 0; a = a.j; var b = a.length, c = this.Ze; if (null !== c) { for (var d = 0; d < b;) { var e = a[d]; if (c(e)) return this.key = this.Ua = d, this.value = e; d++ } return null } return 0 < b ? (a = a[0], this.key = 0, this.value = a) : null }; Gb.prototype.any = function (a) { var b = this.qb; b.Ka = null; var c = b.s; this.Ua = -1; for (var d = b.j, e = d.length, f = this.Ze, g = 0; g < e; g++) { var h = d[g]; if (null === f || f(h)) { if (a(h)) return !0; b.s !== c && Ea(b) } } return !1 };
    Gb.prototype.all = function (a) { var b = this.qb; b.Ka = null; var c = b.s; this.Ua = -1; for (var d = b.j, e = d.length, f = this.Ze, g = 0; g < e; g++) { var h = d[g]; if (null === f || f(h)) { if (!a(h)) return !1; b.s !== c && Ea(b) } } return !0 }; Gb.prototype.each = function (a) { var b = this.qb; b.Ka = null; var c = b.s; this.Ua = -1; for (var d = b.j, e = d.length, f = this.Ze, g = 0; g < e; g++) { var h = d[g]; if (null === f || f(h)) a(h), b.s !== c && Ea(b) } return this };
    Gb.prototype.map = function (a) { var b = this.qb; b.Ka = null; var c = b.s; this.Ua = -1; for (var d = [], e = b.j, f = e.length, g = this.Ze, h = 0; h < f; h++) { var k = e[h]; if (null === g || g(k)) d.push(a(k)), b.s !== c && Ea(b) } a = new F; a.j = d; a.lb(); return a.iterator }; Gb.prototype.filter = function (a) { var b = this.qb; b.Ka = null; var c = b.s; this.Ua = -1; for (var d = [], e = b.j, f = e.length, g = this.Ze, h = 0; h < f; h++) { var k = e[h]; if (null === g || g(k)) a(k) && d.push(k), b.s !== c && Ea(b) } a = new F; a.j = d; a.lb(); return a.iterator };
    Gb.prototype.zd = function () { this.key = -1; this.value = null; this.na = -1; this.Ze = null; this.qb.Ka = this }; Gb.prototype.toString = function () { return "ListIterator@" + this.Ua + "/" + this.qb.count };
    na.Object.defineProperties(Gb.prototype, { iterator: { configurable: !0, get: function () { return this } }, predicate: { configurable: !0, get: function () { return this.Ze }, set: function (a) { this.Ze = a } }, count: { configurable: !0, get: function () { var a = this.Ze; if (null !== a) { for (var b = 0, c = this.qb.j, d = c.length, e = 0; e < d; e++)a(c[e]) && b++; return b } return this.qb.j.length } } }); Gb.prototype.first = Gb.prototype.first; Gb.prototype.hasNext = Gb.prototype.fd; Gb.prototype.next = Gb.prototype.next;
    Gb.prototype.reset = Gb.prototype.reset; Gb.className = "ListIterator"; function Hb(a) { this.qb = a; a.Tg = null; this.na = a.s; this.Ua = a.j.length } Hb.prototype.reset = function () { var a = this.qb; a.Tg = null; this.na = a.s; this.Ua = a.j.length }; Hb.prototype.next = function () { var a = this.qb; if (a.s !== this.na) { if (0 > this.key) return !1; Ea(a) } var b = --this.Ua; if (0 <= b) return this.key = b, this.value = a.j[b], !0; this.zd(); return !1 }; Hb.prototype.fd = function () { return this.next() };
    Hb.prototype.first = function () { var a = this.qb; this.na = a.s; var b = a.j; this.Ua = a = b.length - 1; return 0 <= a ? (b = b[a], this.key = a, this.value = b) : null }; Hb.prototype.any = function (a) { var b = this.qb; b.Tg = null; var c = b.s, d = b.j, e = d.length; this.Ua = e; for (--e; 0 <= e; e--) { if (a(d[e])) return !0; b.s !== c && Ea(b) } return !1 }; Hb.prototype.all = function (a) { var b = this.qb; b.Tg = null; var c = b.s, d = b.j, e = d.length; this.Ua = e; for (--e; 0 <= e; e--) { if (!a(d[e])) return !1; b.s !== c && Ea(b) } return !0 };
    Hb.prototype.each = function (a) { var b = this.qb; b.Tg = null; var c = b.s, d = b.j, e = d.length; this.Ua = e; for (--e; 0 <= e; e--)a(d[e]), b.s !== c && Ea(b); return this }; Hb.prototype.map = function (a) { var b = this.qb; b.Tg = null; var c = b.s, d = [], e = b.j, f = e.length; this.Ua = f; for (--f; 0 <= f; f--)d.push(a(e[f])), b.s !== c && Ea(b); a = new F; a.j = d; a.lb(); return a.iterator };
    Hb.prototype.filter = function (a) { var b = this.qb; b.Tg = null; var c = b.s, d = [], e = b.j, f = e.length; this.Ua = f; for (--f; 0 <= f; f--) { var g = e[f]; a(g) && d.push(g); b.s !== c && Ea(b) } a = new F; a.j = d; a.lb(); return a.iterator }; Hb.prototype.zd = function () { this.key = -1; this.value = null; this.na = -1; this.qb.Tg = this }; Hb.prototype.toString = function () { return "ListIteratorBackwards(" + this.Ua + "/" + this.qb.count + ")" };
    na.Object.defineProperties(Hb.prototype, { iterator: { configurable: !0, get: function () { return this } }, count: { configurable: !0, get: function () { return this.qb.j.length } } }); Hb.prototype.first = Hb.prototype.first; Hb.prototype.hasNext = Hb.prototype.fd; Hb.prototype.next = Hb.prototype.next; Hb.prototype.reset = Hb.prototype.reset; Hb.className = "ListIteratorBackwards";
    function F(a) { qb(this); this.u = !1; this.j = []; this.s = 0; this.Tg = this.Ka = null; void 0 !== a && ("function" === typeof a || "string" === typeof a ? Ha() : this.addAll(a)) } t = F.prototype; t.lb = function () { var a = this.s; a++; 999999999 < a && (a = 0); this.s = a }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { this.u = !1; return this }; t.toString = function () { return "List()#" + Jb(this) }; t.add = function (a) { if (null === a) return this; this.u && ya(this, a); this.j.push(a); this.lb(); return this }; t.push = function (a) { this.add(a) };
    t.addAll = function (a) { if (null === a) return this; this.u && ya(this); var b = this.j; if (Ka(a)) for (var c = a.length, d = 0; d < c; d++)b.push(a[d]); else for (a = a.iterator; a.next();)b.push(a.value); this.lb(); return this }; t.clear = function () { this.u && ya(this); this.j.length = 0; this.lb() }; t.contains = function (a) { return null === a ? !1 : -1 !== this.j.indexOf(a) }; t.has = function (a) { return this.contains(a) }; t.indexOf = function (a) { return null === a ? -1 : this.j.indexOf(a) };
    t.O = function (a) { E && B(a, F, "elt:i"); var b = this.j; (0 > a || a >= b.length) && Ca(a, "0 <= i < length", F, "elt:i"); return b[a] }; t.get = function (a) { return this.O(a) }; t.jd = function (a, b) { E && B(a, F, "setElt:i"); var c = this.j; (0 > a || a >= c.length) && Ca(a, "0 <= i < length", F, "setElt:i"); this.u && ya(this, a); c[a] = b }; t.set = function (a, b) { this.jd(a, b) }; t.first = function () { var a = this.j; return 0 === a.length ? null : a[0] }; t.Ub = function () { var a = this.j, b = a.length; return 0 < b ? a[b - 1] : null };
    t.pop = function () { this.u && ya(this); var a = this.j; return 0 < a.length ? a.pop() : null }; F.prototype.any = function (a) { for (var b = this.j, c = this.s, d = b.length, e = 0; e < d; e++) { if (a(b[e])) return !0; this.s !== c && Ea(this) } return !1 }; F.prototype.all = function (a) { for (var b = this.j, c = this.s, d = b.length, e = 0; e < d; e++) { if (!a(b[e])) return !1; this.s !== c && Ea(this) } return !0 }; F.prototype.each = function (a) { for (var b = this.j, c = this.s, d = b.length, e = 0; e < d; e++)a(b[e]), this.s !== c && Ea(this); return this };
    F.prototype.map = function (a) { for (var b = new F, c = [], d = this.j, e = this.s, f = d.length, g = 0; g < f; g++)c.push(a(d[g])), this.s !== e && Ea(this); b.j = c; b.lb(); return b }; F.prototype.filter = function (a) { for (var b = new F, c = [], d = this.j, e = this.s, f = d.length, g = 0; g < f; g++) { var h = d[g]; a(h) && c.push(h); this.s !== e && Ea(this) } b.j = c; b.lb(); return b }; t = F.prototype; t.Lb = function (a, b) { E && B(a, F, "insertAt:i"); 0 > a && Ca(a, ">= 0", F, "insertAt:i"); this.u && ya(this, a); var c = this.j; a >= c.length ? c.push(b) : c.splice(a, 0, b); this.lb() };
    t.remove = function (a) { if (null === a) return !1; this.u && ya(this, a); var b = this.j; a = b.indexOf(a); if (-1 === a) return !1; a === b.length - 1 ? b.pop() : b.splice(a, 1); this.lb(); return !0 }; t.delete = function (a) { return this.remove(a) }; t.nb = function (a) { E && B(a, F, "removeAt:i"); var b = this.j; (0 > a || a >= b.length) && Ca(a, "0 <= i < length", F, "removeAt:i"); this.u && ya(this, a); a === b.length - 1 ? b.pop() : b.splice(a, 1); this.lb() };
    t.removeRange = function (a, b) { E && (B(a, F, "removeRange:from"), B(b, F, "removeRange:to")); var c = this.j, d = c.length; if (0 > a) a = 0; else if (a >= d) return this; if (0 > b) return this; b >= d && (b = d - 1); if (a > b) return this; this.u && ya(this); for (var e = a, f = b + 1; f < d;)c[e++] = c[f++]; c.length = d - (b - a + 1); this.lb(); return this }; F.prototype.copy = function () { var a = new F, b = this.j; 0 < b.length && (a.j = Array.prototype.slice.call(b)); return a }; t = F.prototype; t.Oa = function () { for (var a = this.j, b = this.count, c = Array(b), d = 0; d < b; d++)c[d] = a[d]; return c };
    t.Xv = function () { for (var a = new I, b = this.j, c = this.count, d = 0; d < c; d++)a.add(b[d]); return a }; t.sort = function (a) { E && z(a, "function", F, "sort:sortfunc"); this.u && ya(this); this.j.sort(a); this.lb(); return this };
    t.Zi = function (a, b, c) {
        var d = this.j, e = d.length; void 0 === b && (b = 0); void 0 === c && (c = e); E && (z(a, "function", F, "sortRange:sortfunc"), B(b, F, "sortRange:from"), B(c, F, "sortRange:to")); this.u && ya(this); var f = c - b; if (1 >= f) return this; (0 > b || b >= e - 1) && Ca(b, "0 <= from < length", F, "sortRange:from"); if (2 === f) return c = d[b], e = d[b + 1], 0 < a(c, e) && (d[b] = e, d[b + 1] = c, this.lb()), this; if (0 === b) if (c >= e) d.sort(a); else for (b = d.slice(0, c), b.sort(a), a = 0; a < c; a++)d[a] = b[a]; else if (c >= e) for (c = d.slice(b), c.sort(a), a = b; a < e; a++)d[a] = c[a - b];
        else for (e = d.slice(b, c), e.sort(a), a = b; a < c; a++)d[a] = e[a - b]; this.lb(); return this
    }; t.reverse = function () { this.u && ya(this); this.j.reverse(); this.lb(); return this };
    na.Object.defineProperties(F.prototype, {
        _dataArray: { configurable: !0, get: function () { return this.j } }, count: { configurable: !0, get: function () { return this.j.length } }, size: { configurable: !0, get: function () { return this.j.length } }, length: { configurable: !0, get: function () { return this.j.length } }, iterator: { configurable: !0, get: function () { if (0 >= this.j.length) return Cb; var a = this.Ka; return null !== a ? (a.reset(), a) : new Gb(this) } }, iteratorBackwards: {
            configurable: !0,
            enumerable: !0, get: function () { if (0 >= this.j.length) return Cb; var a = this.Tg; return null !== a ? (a.reset(), a) : new Hb(this) }
        }
    }); F.prototype.reverse = F.prototype.reverse; F.prototype.sortRange = F.prototype.Zi; F.prototype.sort = F.prototype.sort; F.prototype.toSet = F.prototype.Xv; F.prototype.toArray = F.prototype.Oa; F.prototype.removeRange = F.prototype.removeRange; F.prototype.removeAt = F.prototype.nb; F.prototype["delete"] = F.prototype.delete; F.prototype.remove = F.prototype.remove; F.prototype.insertAt = F.prototype.Lb;
    F.prototype.pop = F.prototype.pop; F.prototype.last = F.prototype.Ub; F.prototype.first = F.prototype.first; F.prototype.set = F.prototype.set; F.prototype.setElt = F.prototype.jd; F.prototype.get = F.prototype.get; F.prototype.elt = F.prototype.O; F.prototype.indexOf = F.prototype.indexOf; F.prototype.has = F.prototype.has; F.prototype.contains = F.prototype.contains; F.prototype.clear = F.prototype.clear; F.prototype.addAll = F.prototype.addAll; F.prototype.push = F.prototype.push; F.prototype.add = F.prototype.add; F.prototype.thaw = F.prototype.ja;
    F.prototype.freeze = F.prototype.freeze; F.className = "List"; function Kb(a) { this.hg = a; a.Ka = null; this.na = a.s; this.pa = null } Kb.prototype.reset = function () { var a = this.hg; a.Ka = null; this.na = a.s; this.pa = null }; Kb.prototype.next = function () { var a = this.hg; if (a.s !== this.na) { if (null === this.key) return !1; Ea(a) } var b = this.pa; b = null === b ? a.ga : b.qa; if (null !== b) return this.pa = b, this.value = b.value, this.key = b.key, !0; this.zd(); return !1 }; Kb.prototype.fd = function () { return this.next() };
    Kb.prototype.first = function () { var a = this.hg; this.na = a.s; a = a.ga; if (null !== a) { this.pa = a; var b = a.value; this.key = a.key; return this.value = b } return null }; Kb.prototype.any = function (a) { var b = this.hg; b.Ka = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;) { if (a(d.value)) return !0; b.s !== c && Ea(b); d = d.qa } return !1 }; Kb.prototype.all = function (a) { var b = this.hg; b.Ka = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;) { if (!a(d.value)) return !1; b.s !== c && Ea(b); d = d.qa } return !0 };
    Kb.prototype.each = function (a) { var b = this.hg; b.Ka = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;)a(d.value), b.s !== c && Ea(b), d = d.qa; return this }; Kb.prototype.map = function (a) { var b = this.hg; b.Ka = null; for (var c = new F, d = b.s, e = b.ga; null !== e;)c.add(a(e.value)), b.s !== d && Ea(b), e = e.qa; return c.iterator }; Kb.prototype.filter = function (a) { var b = this.hg; b.Ka = null; for (var c = new F, d = b.s, e = b.ga; null !== e;) { var f = e.value; a(f) && c.add(f); b.s !== d && Ea(b); e = e.qa } return c.iterator };
    Kb.prototype.zd = function () { this.value = this.key = null; this.na = -1; this.hg.Ka = this }; Kb.prototype.toString = function () { return null !== this.pa ? "SetIterator@" + this.pa.value : "SetIterator" }; na.Object.defineProperties(Kb.prototype, { iterator: { configurable: !0, get: function () { return this } }, count: { configurable: !0, get: function () { return this.hg.Fb } } }); Kb.prototype.first = Kb.prototype.first; Kb.prototype.hasNext = Kb.prototype.fd; Kb.prototype.next = Kb.prototype.next; Kb.prototype.reset = Kb.prototype.reset;
    Kb.className = "SetIterator"; function I(a) { qb(this); this.u = !1; this.Gb = {}; this.Fb = 0; this.Ka = null; this.s = 0; this.Ve = this.ga = null; void 0 !== a && ("function" === typeof a || "string" === typeof a ? Ha() : this.addAll(a)) } t = I.prototype; t.lb = function () { var a = this.s; a++; 999999999 < a && (a = 0); this.s = a }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { this.u = !1; return this }; t.toString = function () { return "Set()#" + Jb(this) };
    t.add = function (a) { if (null === a) return this; this.u && ya(this, a); var b = a; Ia(a) && (b = Nb(a)); void 0 === this.Gb[b] && (this.Fb++ , a = new Ob(a, a), this.Gb[b] = a, b = this.Ve, null === b ? this.ga = a : (a.Al = b, b.qa = a), this.Ve = a, this.lb()); return this }; t.addAll = function (a) { if (null === a) return this; this.u && ya(this); if (Ka(a)) for (var b = a.length, c = 0; c < b; c++)this.add(a[c]); else for (a = a.iterator; a.next();)this.add(a.value); return this };
    t.contains = function (a) { if (null === a) return !1; var b = a; return Ia(a) && (b = Jb(a), void 0 === b) ? !1 : void 0 !== this.Gb[b] }; t.has = function (a) { return this.contains(a) }; t.Ay = function (a) { if (null === a) return !0; for (a = a.iterator; a.next();)if (!this.contains(a.value)) return !1; return !0 }; t.By = function (a) { if (null === a) return !0; for (a = a.iterator; a.next();)if (this.contains(a.value)) return !0; return !1 }; t.first = function () { var a = this.ga; return null === a ? null : a.value };
    I.prototype.any = function (a) { for (var b = this.s, c = this.ga; null !== c;) { if (a(c.value)) return !0; this.s !== b && Ea(this); c = c.qa } return !1 }; I.prototype.all = function (a) { for (var b = this.s, c = this.ga; null !== c;) { if (!a(c.value)) return !1; this.s !== b && Ea(this); c = c.qa } return !0 }; I.prototype.each = function (a) { for (var b = this.s, c = this.ga; null !== c;)a(c.value), this.s !== b && Ea(this), c = c.qa; return this }; I.prototype.map = function (a) { for (var b = new I, c = this.s, d = this.ga; null !== d;)b.add(a(d.value)), this.s !== c && Ea(this), d = d.qa; return b };
    I.prototype.filter = function (a) { for (var b = new I, c = this.s, d = this.ga; null !== d;) { var e = d.value; a(e) && b.add(e); this.s !== c && Ea(this); d = d.qa } return b }; t = I.prototype; t.remove = function (a) { if (null === a) return !1; this.u && ya(this, a); var b = a; if (Ia(a) && (b = Jb(a), void 0 === b)) return !1; a = this.Gb[b]; if (void 0 === a) return !1; var c = a.qa, d = a.Al; null !== c && (c.Al = d); null !== d && (d.qa = c); this.ga === a && (this.ga = c); this.Ve === a && (this.Ve = d); delete this.Gb[b]; this.Fb--; this.lb(); return !0 }; t.delete = function (a) { return this.remove(a) };
    t.vq = function (a) { if (null === a) return this; this.u && ya(this); if (Ka(a)) for (var b = a.length, c = 0; c < b; c++)this.remove(a[c]); else for (a = a.iterator; a.next();)this.remove(a.value); return this }; t.Zz = function (a) { if (null === a || 0 === this.count) return this; this.u && ya(this); var b = new I; b.addAll(a); a = []; for (var c = this.iterator; c.next();) { var d = c.value; b.contains(d) || a.push(d) } this.vq(a); return this }; t.clear = function () { this.u && ya(this); this.Gb = {}; this.Fb = 0; null !== this.Ka && this.Ka.reset(); this.Ve = this.ga = null; this.lb() };
    I.prototype.copy = function () { var a = new I, b = this.Gb, c; for (c in b) a.add(b[c].value); return a }; I.prototype.Oa = function () { var a = Array(this.Fb), b = this.Gb, c = 0, d; for (d in b) a[c] = b[d].value, c++; return a }; I.prototype.Wv = function () { var a = new F, b = this.Gb, c; for (c in b) a.add(b[c].value); return a }; function qb(a) { a.__gohashid = Pb++ } function Nb(a) { var b = a.__gohashid; void 0 === b && (b = Pb++ , a.__gohashid = b); return b } function Jb(a) { return a.__gohashid }
    na.Object.defineProperties(I.prototype, { count: { configurable: !0, get: function () { return this.Fb } }, size: { configurable: !0, get: function () { return this.Fb } }, iterator: { configurable: !0, get: function () { if (0 >= this.Fb) return Cb; var a = this.Ka; return null !== a ? (a.reset(), a) : new Kb(this) } } }); I.prototype.toList = I.prototype.Wv; I.prototype.toArray = I.prototype.Oa; I.prototype.clear = I.prototype.clear; I.prototype.retainAll = I.prototype.Zz; I.prototype.removeAll = I.prototype.vq;
    I.prototype["delete"] = I.prototype.delete; I.prototype.remove = I.prototype.remove; I.prototype.first = I.prototype.first; I.prototype.containsAny = I.prototype.By; I.prototype.containsAll = I.prototype.Ay; I.prototype.has = I.prototype.has; I.prototype.contains = I.prototype.contains; I.prototype.addAll = I.prototype.addAll; I.prototype.add = I.prototype.add; I.prototype.thaw = I.prototype.ja; I.prototype.freeze = I.prototype.freeze; var Pb = 1; I.className = "Set"; I.uniqueHash = qb; I.hashIdUnique = Nb; I.hashId = Jb;
    function Qb(a) { this.la = a; this.na = a.s; this.pa = null } Qb.prototype.reset = function () { this.na = this.la.s; this.pa = null }; Qb.prototype.next = function () { var a = this.la; if (a.s !== this.na) { if (null === this.key) return !1; Ea(a) } var b = this.pa; b = null === b ? a.ga : b.qa; if (null !== b) return this.pa = b, this.value = this.key = a = b.key, !0; this.zd(); return !1 }; Qb.prototype.fd = function () { return this.next() }; Qb.prototype.first = function () { var a = this.la; this.na = a.s; a = a.ga; return null !== a ? (this.pa = a, this.value = this.key = a = a.key) : null };
    Qb.prototype.any = function (a) { var b = this.la, c = b.s; this.pa = null; for (var d = b.ga; null !== d;) { if (a(d.key)) return !0; b.s !== c && Ea(b); d = d.qa } return !1 }; Qb.prototype.all = function (a) { var b = this.la, c = b.s; this.pa = null; for (var d = b.ga; null !== d;) { if (!a(d.key)) return !1; b.s !== c && Ea(b); d = d.qa } return !0 }; Qb.prototype.each = function (a) { var b = this.la, c = b.s; this.pa = null; for (var d = b.ga; null !== d;)a(d.key), b.s !== c && Ea(b), d = d.qa; return this };
    Qb.prototype.map = function (a) { var b = this.la, c = b.s; this.pa = null; for (var d = new F, e = b.ga; null !== e;)d.add(a(e.key)), b.s !== c && Ea(b), e = e.qa; return d.iterator }; Qb.prototype.filter = function (a) { var b = this.la, c = b.s; this.pa = null; for (var d = new F, e = b.ga; null !== e;) { var f = e.key; a(f) && d.add(f); b.s !== c && Ea(b); e = e.qa } return d.iterator }; Qb.prototype.zd = function () { this.value = this.key = null; this.na = -1 }; Qb.prototype.toString = function () { return null !== this.pa ? "MapKeySetIterator@" + this.pa.value : "MapKeySetIterator" };
    na.Object.defineProperties(Qb.prototype, { iterator: { configurable: !0, get: function () { return this } }, count: { configurable: !0, get: function () { return this.la.Fb } } }); Qb.prototype.first = Qb.prototype.first; Qb.prototype.hasNext = Qb.prototype.fd; Qb.prototype.next = Qb.prototype.next; Qb.prototype.reset = Qb.prototype.reset; Qb.className = "MapKeySetIterator"; function Rb(a) { I.call(this); qb(this); this.u = !0; this.la = a } ma(Rb, I); t = Rb.prototype; t.freeze = function () { return this }; t.ja = function () { return this };
    t.toString = function () { return "MapKeySet(" + this.la.toString() + ")" }; t.add = function () { v("This Set is read-only: " + this.toString()); return this }; t.contains = function (a) { return this.la.contains(a) }; t.has = function (a) { return this.contains(a) }; t.remove = function () { v("This Set is read-only: " + this.toString()); return !1 }; t.delete = function (a) { return this.remove(a) }; t.clear = function () { v("This Set is read-only: " + this.toString()) }; t.first = function () { var a = this.la.ga; return null !== a ? a.key : null };
    Rb.prototype.any = function (a) { for (var b = this.la.ga; null !== b;) { if (a(b.key)) return !0; b = b.qa } return !1 }; Rb.prototype.all = function (a) { for (var b = this.la.ga; null !== b;) { if (!a(b.key)) return !1; b = b.qa } return !0 }; Rb.prototype.each = function (a) { for (var b = this.la.ga; null !== b;)a(b.key), b = b.qa; return this }; Rb.prototype.map = function (a) { for (var b = new I, c = this.la.ga; null !== c;)b.add(a(c.key)), c = c.qa; return b }; Rb.prototype.filter = function (a) { for (var b = new I, c = this.la.ga; null !== c;) { var d = c.key; a(d) && b.add(d); c = c.qa } return b };
    Rb.prototype.copy = function () { return new Rb(this.la) }; Rb.prototype.Xv = function () { var a = new I, b = this.la.Gb, c; for (c in b) a.add(b[c].key); return a }; Rb.prototype.Oa = function () { var a = this.la.Gb, b = Array(this.la.Fb), c = 0, d; for (d in a) b[c] = a[d].key, c++; return b }; Rb.prototype.Wv = function () { var a = new F, b = this.la.Gb, c; for (c in b) a.add(b[c].key); return a };
    na.Object.defineProperties(Rb.prototype, { count: { configurable: !0, get: function () { return this.la.Fb } }, size: { configurable: !0, get: function () { return this.la.Fb } }, iterator: { configurable: !0, get: function () { return 0 >= this.la.Fb ? Cb : new Qb(this.la) } } }); Rb.prototype.toList = Rb.prototype.Wv; Rb.prototype.toArray = Rb.prototype.Oa; Rb.prototype.toSet = Rb.prototype.Xv; Rb.prototype.first = Rb.prototype.first; Rb.prototype.clear = Rb.prototype.clear; Rb.prototype["delete"] = Rb.prototype.delete;
    Rb.prototype.remove = Rb.prototype.remove; Rb.prototype.has = Rb.prototype.has; Rb.prototype.contains = Rb.prototype.contains; Rb.prototype.add = Rb.prototype.add; Rb.prototype.thaw = Rb.prototype.ja; Rb.prototype.freeze = Rb.prototype.freeze; Rb.className = "MapKeySet"; function Sb(a) { this.la = a; a.Ue = null; this.na = a.s; this.pa = null } Sb.prototype.reset = function () { var a = this.la; a.Ue = null; this.na = a.s; this.pa = null };
    Sb.prototype.next = function () { var a = this.la; if (a.s !== this.na) { if (null === this.key) return !1; Ea(a) } var b = this.pa; b = null === b ? a.ga : b.qa; if (null !== b) return this.pa = b, this.value = b.value, this.key = b.key, !0; this.zd(); return !1 }; Sb.prototype.fd = function () { return this.next() }; Sb.prototype.first = function () { var a = this.la; this.na = a.s; a = a.ga; if (null !== a) { this.pa = a; var b = a.value; this.key = a.key; return this.value = b } return null };
    Sb.prototype.any = function (a) { var b = this.la; b.Ue = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;) { if (a(d.value)) return !0; b.s !== c && Ea(b); d = d.qa } return !1 }; Sb.prototype.all = function (a) { var b = this.la; b.Ue = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;) { if (!a(d.value)) return !1; b.s !== c && Ea(b); d = d.qa } return !0 }; Sb.prototype.each = function (a) { var b = this.la; b.Ue = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;)a(d.value), b.s !== c && Ea(b), d = d.qa; return this };
    Sb.prototype.map = function (a) { var b = this.la; b.Ue = null; var c = b.s; this.pa = null; for (var d = new F, e = b.ga; null !== e;)d.add(a(e.value)), b.s !== c && Ea(b), e = e.qa; return d.iterator }; Sb.prototype.filter = function (a) { var b = this.la; b.Ue = null; var c = b.s; this.pa = null; for (var d = new F, e = b.ga; null !== e;) { var f = e.value; a(f) && d.add(f); b.s !== c && Ea(b); e = e.qa } return d.iterator }; Sb.prototype.zd = function () { this.value = this.key = null; this.na = -1; this.la.Ue = this };
    Sb.prototype.toString = function () { return null !== this.pa ? "MapValueSetIterator@" + this.pa.value : "MapValueSetIterator" }; na.Object.defineProperties(Sb.prototype, { iterator: { configurable: !0, get: function () { return this } }, count: { configurable: !0, get: function () { return this.la.Fb } } }); Sb.prototype.first = Sb.prototype.first; Sb.prototype.hasNext = Sb.prototype.fd; Sb.prototype.next = Sb.prototype.next; Sb.prototype.reset = Sb.prototype.reset; Sb.className = "MapValueSetIterator";
    function Ob(a, b) { this.key = a; this.value = b; this.Al = this.qa = null } Ob.prototype.toString = function () { return "{" + this.key + ":" + this.value + "}" }; Ob.className = "KeyValuePair"; function Tb(a) { this.la = a; a.Ka = null; this.na = a.s; this.pa = null } Tb.prototype.reset = function () { var a = this.la; a.Ka = null; this.na = a.s; this.pa = null };
    Tb.prototype.next = function () { var a = this.la; if (a.s !== this.na) { if (null === this.key) return !1; Ea(a) } var b = this.pa; b = null === b ? a.ga : b.qa; if (null !== b) return this.pa = b, this.key = b.key, this.value = b.value, !0; this.zd(); return !1 }; Tb.prototype.fd = function () { return this.next() }; Tb.prototype.first = function () { var a = this.la; this.na = a.s; a = a.ga; return null !== a ? (this.pa = a, this.key = a.key, this.value = a.value, a) : null };
    Tb.prototype.any = function (a) { var b = this.la; b.Ka = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;) { if (a(d)) return !0; b.s !== c && Ea(b); d = d.qa } return !1 }; Tb.prototype.all = function (a) { var b = this.la; b.Ka = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;) { if (!a(d)) return !1; b.s !== c && Ea(b); d = d.qa } return !0 }; Tb.prototype.each = function (a) { var b = this.la; b.Ka = null; var c = b.s; this.pa = null; for (var d = b.ga; null !== d;)a(d), b.s !== c && Ea(b), d = d.qa; return this };
    Tb.prototype.map = function (a) { var b = this.la; b.Ka = null; var c = b.s; this.pa = null; for (var d = new F, e = b.ga; null !== e;)d.add(a(e)), b.s !== c && Ea(b), e = e.qa; return d.iterator }; Tb.prototype.filter = function (a) { var b = this.la; b.Ka = null; var c = b.s; this.pa = null; for (var d = new F, e = b.ga; null !== e;)a(e) && d.add(e), b.s !== c && Ea(b), e = e.qa; return d.iterator }; Tb.prototype.zd = function () { this.value = this.key = null; this.na = -1; this.la.Ka = this }; Tb.prototype.toString = function () { return null !== this.pa ? "MapIterator@" + this.pa : "MapIterator" };
    na.Object.defineProperties(Tb.prototype, { iterator: { configurable: !0, get: function () { return this } }, count: { configurable: !0, get: function () { return this.la.Fb } } }); Tb.prototype.first = Tb.prototype.first; Tb.prototype.hasNext = Tb.prototype.fd; Tb.prototype.next = Tb.prototype.next; Tb.prototype.reset = Tb.prototype.reset; Tb.className = "MapIterator";
    function Ub(a) { qb(this); this.u = !1; this.Gb = {}; this.Fb = 0; this.Ue = this.Ka = null; this.s = 0; this.Ve = this.ga = null; void 0 !== a && ("function" === typeof a || "string" === typeof a ? Ha() : this.addAll(a)) } t = Ub.prototype; t.lb = function () { var a = this.s; a++; 999999999 < a && (a = 0); this.s = a }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { this.u = !1; return this }; t.toString = function () { return "Map()#" + Jb(this) };
    t.add = function (a, b) { this.u && ya(this, a); var c = a; Ia(a) && (c = Nb(a)); var d = this.Gb[c]; void 0 === d ? (this.Fb++ , a = new Ob(a, b), this.Gb[c] = a, c = this.Ve, null === c ? this.ga = a : (a.Al = c, c.qa = a), this.Ve = a, this.lb()) : d.value = b; return this }; t.set = function (a, b) { return this.add(a, b) }; t.addAll = function (a) { if (null === a) return this; if (Ka(a)) for (var b = a.length, c = 0; c < b; c++) { var d = a[c]; this.add(d.key, d.value) } else for (a = a.iterator; a.next();)b = a.value, this.add(b.key, b.value); return this }; t.first = function () { return this.ga };
    Ub.prototype.any = function (a) { for (var b = this.s, c = this.ga; null !== c;) { if (a(c)) return !0; this.s !== b && Ea(this); c = c.qa } return !1 }; Ub.prototype.all = function (a) { for (var b = this.s, c = this.ga; null !== c;) { if (!a(c)) return !1; this.s !== b && Ea(this); c = c.qa } return !0 }; Ub.prototype.each = function (a) { for (var b = this.s, c = this.ga; null !== c;)a(c), this.s !== b && Ea(this), c = c.qa; return this }; Ub.prototype.map = function (a) { for (var b = new Ub, c = this.s, d = this.ga; null !== d;)b.add(d.key, a(d)), this.s !== c && Ea(this), d = d.qa; return b };
    Ub.prototype.filter = function (a) { for (var b = new Ub, c = this.s, d = this.ga; null !== d;)a(d) && b.add(d.key, d.value), this.s !== c && Ea(this), d = d.qa; return b }; t = Ub.prototype; t.contains = function (a) { var b = a; return Ia(a) && (b = Jb(a), void 0 === b) ? !1 : void 0 !== this.Gb[b] }; t.has = function (a) { return this.contains(a) }; t.K = function (a) { var b = a; if (Ia(a) && (b = Jb(a), void 0 === b)) return null; a = this.Gb[b]; return void 0 === a ? null : a.value }; t.get = function (a) { return this.K(a) };
    t.remove = function (a) { if (null === a) return !1; this.u && ya(this, a); var b = a; if (Ia(a) && (b = Jb(a), void 0 === b)) return !1; a = this.Gb[b]; if (void 0 === a) return !1; var c = a.qa, d = a.Al; null !== c && (c.Al = d); null !== d && (d.qa = c); this.ga === a && (this.ga = c); this.Ve === a && (this.Ve = d); delete this.Gb[b]; this.Fb--; this.lb(); return !0 }; t.delete = function (a) { return this.remove(a) }; t.clear = function () { this.u && ya(this); this.Gb = {}; this.Fb = 0; null !== this.Ka && this.Ka.reset(); null !== this.Ue && this.Ue.reset(); this.Ve = this.ga = null; this.lb() };
    Ub.prototype.copy = function () { var a = new Ub, b = this.Gb, c; for (c in b) { var d = b[c]; a.add(d.key, d.value) } return a }; Ub.prototype.Oa = function () { var a = this.Gb, b = Array(this.Fb), c = 0, d; for (d in a) { var e = a[d]; b[c] = new Ob(e.key, e.value); c++ } return b }; Ub.prototype.$d = function () { return new Rb(this) };
    na.Object.defineProperties(Ub.prototype, {
        count: { configurable: !0, get: function () { return this.Fb } }, size: { configurable: !0, get: function () { return this.Fb } }, iterator: { configurable: !0, get: function () { if (0 >= this.count) return Cb; var a = this.Ka; return null !== a ? (a.reset(), a) : new Tb(this) } }, iteratorKeys: { configurable: !0, get: function () { return 0 >= this.count ? Cb : new Qb(this) } }, iteratorValues: {
            configurable: !0, get: function () {
                if (0 >= this.count) return Cb;
                var a = this.Ue; return null !== a ? (a.reset(), a) : new Sb(this)
            }
        }
    }); Ub.prototype.toKeySet = Ub.prototype.$d; Ub.prototype.toArray = Ub.prototype.Oa; Ub.prototype.clear = Ub.prototype.clear; Ub.prototype["delete"] = Ub.prototype.delete; Ub.prototype.remove = Ub.prototype.remove; Ub.prototype.get = Ub.prototype.get; Ub.prototype.getValue = Ub.prototype.K; Ub.prototype.has = Ub.prototype.has; Ub.prototype.contains = Ub.prototype.contains; Ub.prototype.first = Ub.prototype.first; Ub.prototype.addAll = Ub.prototype.addAll;
    Ub.prototype.set = Ub.prototype.set; Ub.prototype.add = Ub.prototype.add; Ub.prototype.thaw = Ub.prototype.ja; Ub.prototype.freeze = Ub.prototype.freeze; Ub.className = "Map"; function J(a, b) { void 0 === a ? this.H = this.G = 0 : "number" === typeof a && "number" === typeof b ? (this.G = a, this.H = b) : v("Invalid arguments to Point constructor: " + a + ", " + b); this.u = !1 } J.prototype.assign = function (a) { this.G = a.G; this.H = a.H; return this }; J.prototype.h = function (a, b) { this.G = a; this.H = b; return this };
    J.prototype.wg = function (a, b) { E && (z(a, "number", J, "setTo:x"), z(b, "number", J, "setTo:y"), this.ha()); this.G = a; this.H = b; return this }; J.prototype.set = function (a) { E && (w(a, J, J, "set:p"), this.ha()); this.G = a.G; this.H = a.H; return this }; J.prototype.copy = function () { var a = new J; a.G = this.G; a.H = this.H; return a }; t = J.prototype; t.ia = function () { this.u = !0; Object.freeze(this); return this }; t.J = function () { return Object.isFrozen(this) ? this : this.copy().freeze() }; t.freeze = function () { this.u = !0; return this };
    t.ja = function () { Object.isFrozen(this) && v("cannot thaw constant: " + this); this.u = !1; return this }; t.ha = function (a) { if (this.u) { var b = "The Point is frozen, so its properties cannot be set: " + this.toString(); void 0 !== a && (b += "  to value: " + a); v(b) } }; function Vb(a) { if ("string" === typeof a) { a = a.split(" "); for (var b = 0, c = 0; "" === a[b];)b++; var d = a[b++]; d && (c = parseFloat(d)); for (var e = 0; "" === a[b];)b++; (d = a[b++]) && (e = parseFloat(d)); return new J(c, e) } return new J }
    function Xb(a) { E && w(a, J); return a.x.toString() + " " + a.y.toString() } t.toString = function () { return "Point(" + this.x + "," + this.y + ")" }; t.A = function (a) { return a instanceof J ? this.G === a.x && this.H === a.y : !1 }; t.Hi = function (a, b) { return this.G === a && this.H === b }; t.Sa = function (a) { return K.B(this.G, a.x) && K.B(this.H, a.y) }; t.add = function (a) { E && (w(a, J, J, "add:p"), this.ha()); this.G += a.x; this.H += a.y; return this }; t.Zd = function (a) { E && (w(a, J, J, "subtract:p"), this.ha()); this.G -= a.x; this.H -= a.y; return this };
    t.offset = function (a, b) { E && (B(a, J, "offset:dx"), B(b, J, "offset:dy"), this.ha()); this.G += a; this.H += b; return this }; J.prototype.rotate = function (a) { E && (B(a, J, "rotate:angle"), this.ha()); if (0 === a) return this; var b = this.G, c = this.H; if (0 === b && 0 === c) return this; 360 <= a ? a -= 360 : 0 > a && (a += 360); if (90 === a) { a = 0; var d = 1 } else 180 === a ? (a = -1, d = 0) : 270 === a ? (a = 0, d = -1) : (d = a * Math.PI / 180, a = Math.cos(d), d = Math.sin(d)); this.G = a * b - d * c; this.H = d * b + a * c; return this }; t = J.prototype;
    t.scale = function (a, b) { E && (B(a, J, "scale:sx"), B(b, J, "scale:sy"), this.ha()); this.G *= a; this.H *= b; return this }; t.Ee = function (a) { E && w(a, J, J, "distanceSquaredPoint:p"); var b = a.x - this.G; a = a.y - this.H; return b * b + a * a }; t.ed = function (a, b) { E && (B(a, J, "distanceSquared:px"), B(b, J, "distanceSquared:py")); a -= this.G; b -= this.H; return a * a + b * b }; t.normalize = function () { E && this.ha(); var a = this.G, b = this.H, c = Math.sqrt(a * a + b * b); 0 < c && (this.G = a / c, this.H = b / c); return this };
    t.Xa = function (a) { E && w(a, J, J, "directionPoint:p"); return Yb(a.x - this.G, a.y - this.H) }; t.direction = function (a, b) { E && (B(a, J, "direction:px"), B(b, J, "direction:py")); return Yb(a - this.G, b - this.H) }; function Yb(a, b) { if (0 === a) return 0 < b ? 90 : 0 > b ? 270 : 0; if (0 === b) return 0 < a ? 0 : 180; if (isNaN(a) || isNaN(b)) return 0; var c = 180 * Math.atan(Math.abs(b / a)) / Math.PI; 0 > a ? c = 0 > b ? c + 180 : 180 - c : 0 > b && (c = 360 - c); return c }
    t.Sz = function (a, b, c, d) { E && (B(a, J, "projectOntoLineSegment:px"), B(b, J, "projectOntoLineSegment:py"), B(c, J, "projectOntoLineSegment:qx"), B(d, J, "projectOntoLineSegment:qy")); K.Vi(a, b, c, d, this.G, this.H, this); return this }; t.Tz = function (a, b) { E && (w(a, J, J, "projectOntoLineSegmentPoint:p"), w(b, J, J, "projectOntoLineSegmentPoint:q")); K.Vi(a.x, a.y, b.x, b.y, this.G, this.H, this); return this };
    t.dA = function (a, b, c, d) { E && (B(a, J, "snapToGrid:originx"), B(b, J, "snapToGrid:originy"), B(c, J, "snapToGrid:cellwidth"), B(d, J, "snapToGrid:cellheight")); K.bq(this.G, this.H, a, b, c, d, this); return this }; t.eA = function (a, b) { E && (w(a, J, J, "snapToGridPoint:p"), w(b, Zb, J, "snapToGridPoint:q")); K.bq(this.G, this.H, a.x, a.y, b.width, b.height, this); return this }; t.Xi = function (a, b) { E && (w(a, L, J, "setRectSpot:r"), w(b, M, J, "setRectSpot:spot"), this.ha()); this.G = a.x + b.x * a.width + b.offsetX; this.H = a.y + b.y * a.height + b.offsetY; return this };
    t.uk = function (a, b, c, d, e) { E && (B(a, J, "setSpot:x"), B(b, J, "setSpot:y"), B(c, J, "setSpot:w"), B(d, J, "setSpot:h"), (0 > c || 0 > d) && v("Point.setSpot:Width and height cannot be negative"), w(e, M, J, "setSpot:spot"), this.ha()); this.G = a + e.x * c + e.offsetX; this.H = b + e.y * d + e.offsetY; return this }; t.transform = function (a) { E && w(a, $b, J, "transform:t"); a.va(this); return this }; function ac(a, b) { E && w(b, $b, J, "transformInverted:t"); b.Wd(a); return a }
    function cc(a, b, c, d, e, f) { E && (B(a, J, "distanceLineSegmentSquared:px"), B(b, J, "distanceLineSegmentSquared:py"), B(c, J, "distanceLineSegmentSquared:ax"), B(d, J, "distanceLineSegmentSquared:ay"), B(e, J, "distanceLineSegmentSquared:bx"), B(f, J, "distanceLineSegmentSquared:by")); var g = e - c, h = f - d, k = g * g + h * h; c -= a; d -= b; var l = -c * g - d * h; if (0 >= l || l >= k) return g = e - a, h = f - b, Math.min(c * c + d * d, g * g + h * h); a = g * d - h * c; return a * a / k }
    function dc(a, b, c, d) { E && (B(a, J, "distanceSquared:px"), B(b, J, "distanceSquared:py"), B(c, J, "distanceSquared:qx"), B(d, J, "distanceSquared:qy")); a = c - a; b = d - b; return a * a + b * b } function ec(a, b, c, d) { E && (B(a, J, "direction:px"), B(b, J, "direction:py"), B(c, J, "direction:qx"), B(d, J, "direction:qy")); a = c - a; b = d - b; if (0 === a) return 0 < b ? 90 : 0 > b ? 270 : 0; if (0 === b) return 0 < a ? 0 : 180; if (isNaN(a) || isNaN(b)) return 0; d = 180 * Math.atan(Math.abs(b / a)) / Math.PI; 0 > a ? d = 0 > b ? d + 180 : 180 - d : 0 > b && (d = 360 - d); return d }
    t.o = function () { return isFinite(this.x) && isFinite(this.y) }; J.alloc = function () { var a = fc.pop(); return void 0 === a ? new J : a }; J.allocAt = function (a, b) { var c = fc.pop(); if (void 0 === c) return new J(a, b); c.x = a; c.y = b; return c }; J.free = function (a) { fc.push(a) };
    na.Object.defineProperties(J.prototype, { x: { configurable: !0, get: function () { return this.G }, set: function (a) { E && (z(a, "number", J, "x"), this.ha(a)); this.G = a } }, y: { configurable: !0, get: function () { return this.H }, set: function (a) { E && (z(a, "number", J, "y"), this.ha(a)); this.H = a } } }); J.prototype.isReal = J.prototype.o; J.prototype.setSpot = J.prototype.uk; J.prototype.setRectSpot = J.prototype.Xi; J.prototype.snapToGridPoint = J.prototype.eA; J.prototype.snapToGrid = J.prototype.dA;
    J.prototype.projectOntoLineSegmentPoint = J.prototype.Tz; J.prototype.projectOntoLineSegment = J.prototype.Sz; J.prototype.direction = J.prototype.direction; J.prototype.directionPoint = J.prototype.Xa; J.prototype.normalize = J.prototype.normalize; J.prototype.distanceSquared = J.prototype.ed; J.prototype.distanceSquaredPoint = J.prototype.Ee; J.prototype.scale = J.prototype.scale; J.prototype.rotate = J.prototype.rotate; J.prototype.offset = J.prototype.offset; J.prototype.subtract = J.prototype.Zd; J.prototype.add = J.prototype.add;
    J.prototype.equalsApprox = J.prototype.Sa; J.prototype.equalTo = J.prototype.Hi; J.prototype.equals = J.prototype.A; J.prototype.set = J.prototype.set; J.prototype.setTo = J.prototype.wg; var gc = null, hc = null, ic = null, jc = null, qc = null, fc = []; J.className = "Point"; J.parse = Vb; J.stringify = Xb; J.distanceLineSegmentSquared = cc; J.distanceSquared = dc; J.direction = ec; J.Origin = gc = (new J(0, 0)).ia(); J.InfiniteTopLeft = hc = (new J(-Infinity, -Infinity)).ia(); J.InfiniteBottomRight = ic = (new J(Infinity, Infinity)).ia();
    J.SixPoint = jc = (new J(6, 6)).ia(); J.NoPoint = qc = (new J(NaN, NaN)).ia(); J.parse = Vb; J.stringify = Xb; J.distanceLineSegmentSquared = cc; J.distanceSquared = dc; J.direction = ec; function Zb(a, b) { void 0 === a ? this.$ = this.aa = 0 : "number" === typeof a && (0 <= a || isNaN(a)) && "number" === typeof b && (0 <= b || isNaN(b)) ? (this.aa = a, this.$ = b) : v("Invalid arguments to Size constructor: " + a + ", " + b); this.u = !1 } var rc, sc, tc, uc, vc, wc, xc; Zb.prototype.assign = function (a) { this.aa = a.aa; this.$ = a.$; return this };
    Zb.prototype.h = function (a, b) { this.aa = a; this.$ = b; return this }; Zb.prototype.wg = function (a, b) { E && (z(a, "number", Zb, "setTo:w"), z(b, "number", Zb, "setTo:h"), 0 > a && Ca(a, ">= 0", Zb, "setTo:w"), 0 > b && Ca(b, ">= 0", Zb, "setTo:h"), this.ha()); this.aa = a; this.$ = b; return this }; Zb.prototype.set = function (a) { E && (w(a, Zb, Zb, "set:s"), this.ha()); this.aa = a.aa; this.$ = a.$; return this }; Zb.prototype.copy = function () { var a = new Zb; a.aa = this.aa; a.$ = this.$; return a }; t = Zb.prototype; t.ia = function () { this.u = !0; Object.freeze(this); return this };
    t.J = function () { return Object.isFrozen(this) ? this : this.copy().freeze() }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { Object.isFrozen(this) && v("cannot thaw constant: " + this); this.u = !1; return this }; t.ha = function (a) { if (this.u) { var b = "The Size is frozen, so its properties cannot be set: " + this.toString(); void 0 !== a && (b += "  to value: " + a); v(b) } };
    function yc(a) { if ("string" === typeof a) { a = a.split(" "); for (var b = 0, c = 0; "" === a[b];)b++; var d = a[b++]; d && (c = parseFloat(d)); for (var e = 0; "" === a[b];)b++; (d = a[b++]) && (e = parseFloat(d)); return new Zb(c, e) } return new Zb } function Ac(a) { E && w(a, Zb); return a.width.toString() + " " + a.height.toString() } t.toString = function () { return "Size(" + this.width + "," + this.height + ")" }; t.A = function (a) { return a instanceof Zb ? this.aa === a.width && this.$ === a.height : !1 }; t.Hi = function (a, b) { return this.aa === a && this.$ === b };
    t.Sa = function (a) { return K.B(this.aa, a.width) && K.B(this.$, a.height) }; t.o = function () { return isFinite(this.width) && isFinite(this.height) }; Zb.alloc = function () { var a = Bc.pop(); return void 0 === a ? new Zb : a }; Zb.free = function (a) { Bc.push(a) };
    na.Object.defineProperties(Zb.prototype, { width: { configurable: !0, get: function () { return this.aa }, set: function (a) { E && (z(a, "number", Zb, "width"), this.ha(a)); 0 > a && Ca(a, ">= 0", Zb, "width"); this.aa = a } }, height: { configurable: !0, get: function () { return this.$ }, set: function (a) { E && (z(a, "number", Zb, "height"), this.ha(a)); 0 > a && Ca(a, ">= 0", Zb, "height"); this.$ = a } } }); Zb.prototype.isReal = Zb.prototype.o; Zb.prototype.equalsApprox = Zb.prototype.Sa; Zb.prototype.equalTo = Zb.prototype.Hi;
    Zb.prototype.equals = Zb.prototype.A; Zb.prototype.set = Zb.prototype.set; Zb.prototype.setTo = Zb.prototype.wg; var Bc = []; Zb.className = "Size"; Zb.parse = yc; Zb.stringify = Ac; Zb.ZeroSize = rc = (new Zb(0, 0)).ia(); Zb.OneSize = sc = (new Zb(1, 1)).ia(); Zb.SixSize = tc = (new Zb(6, 6)).ia(); Zb.EightSize = uc = (new Zb(8, 8)).ia(); Zb.TenSize = vc = (new Zb(10, 10)).ia(); Zb.InfiniteSize = wc = (new Zb(Infinity, Infinity)).ia(); Zb.NoSize = xc = (new Zb(NaN, NaN)).ia(); Zb.parse = yc; Zb.stringify = Ac;
    function L(a, b, c, d) {
    void 0 === a ? this.$ = this.aa = this.H = this.G = 0 : a instanceof J ? (c = a.x, a = a.y, b instanceof J ? (d = b.x, b = b.y, this.G = Math.min(c, d), this.H = Math.min(a, b), this.aa = Math.abs(c - d), this.$ = Math.abs(a - b)) : b instanceof Zb ? (this.G = c, this.H = a, this.aa = b.aa, this.$ = b.$) : v("Incorrect arguments supplied to Rect constructor")) : "number" === typeof a && "number" === typeof b && "number" === typeof c && (0 <= c || isNaN(c)) && "number" === typeof d && (0 <= d || isNaN(d)) ? (this.G = a, this.H = b, this.aa = c, this.$ = d) : v("Invalid arguments to Rect constructor: " +
        a + ", " + b + ", " + c + ", " + d); this.u = !1
    } t = L.prototype; t.assign = function (a) { this.G = a.G; this.H = a.H; this.aa = a.aa; this.$ = a.$; return this }; t.h = function (a, b, c, d) { this.G = a; this.H = b; this.aa = c; this.$ = d; return this }; function Cc(a, b, c) { a.aa = b; a.$ = c } t.wg = function (a, b, c, d) { E && (z(a, "number", L, "setTo:x"), z(b, "number", L, "setTo:y"), z(c, "number", L, "setTo:w"), z(d, "number", L, "setTo:h"), 0 > c && Ca(c, ">= 0", L, "setTo:w"), 0 > d && Ca(d, ">= 0", L, "setTo:h"), this.ha()); this.G = a; this.H = b; this.aa = c; this.$ = d; return this };
    t.set = function (a) { E && (w(a, L, L, "set:r"), this.ha()); this.G = a.G; this.H = a.H; this.aa = a.aa; this.$ = a.$; return this }; t.ld = function (a) { E && (w(a, J, L, "setPoint:p"), this.ha()); this.G = a.x; this.H = a.y; return this }; t.bA = function (a) { E && (w(a, Zb, L, "setSize:s"), this.ha()); this.aa = a.aa; this.$ = a.$; return this }; L.prototype.copy = function () { var a = new L; a.G = this.G; a.H = this.H; a.aa = this.aa; a.$ = this.$; return a }; t = L.prototype; t.ia = function () { this.u = !0; Object.freeze(this); return this };
    t.J = function () { return Object.isFrozen(this) ? this : this.copy().freeze() }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { Object.isFrozen(this) && v("cannot thaw constant: " + this); this.u = !1; return this }; t.ha = function (a) { if (this.u) { var b = "The Rect is frozen, so its properties cannot be set: " + this.toString(); void 0 !== a && (b += "  to value: " + a); v(b) } };
    function Dc(a) { if ("string" === typeof a) { a = a.split(" "); for (var b = 0, c = 0; "" === a[b];)b++; var d = a[b++]; d && (c = parseFloat(d)); for (var e = 0; "" === a[b];)b++; (d = a[b++]) && (e = parseFloat(d)); for (var f = 0; "" === a[b];)b++; (d = a[b++]) && (f = parseFloat(d)); for (var g = 0; "" === a[b];)b++; (d = a[b++]) && (g = parseFloat(d)); return new L(c, e, f, g) } return new L } function Ec(a) { E && w(a, L); return a.x.toString() + " " + a.y.toString() + " " + a.width.toString() + " " + a.height.toString() }
    t.toString = function () { return "Rect(" + this.x + "," + this.y + "," + this.width + "," + this.height + ")" }; t.A = function (a) { return a instanceof L ? this.G === a.x && this.H === a.y && this.aa === a.width && this.$ === a.height : !1 }; t.Hi = function (a, b, c, d) { return this.G === a && this.H === b && this.aa === c && this.$ === d }; t.Sa = function (a) { return K.B(this.G, a.x) && K.B(this.H, a.y) && K.B(this.aa, a.width) && K.B(this.$, a.height) }; function Fc(a, b) { return K.da(a.G, b.x) && K.da(a.H, b.y) && K.da(a.aa, b.width) && K.da(a.$, b.height) }
    t.ea = function (a) { E && w(a, J, L, "containsPoint:p"); return this.G <= a.x && this.G + this.aa >= a.x && this.H <= a.y && this.H + this.$ >= a.y }; t.pf = function (a) { E && w(a, L, L, "containsRect:r"); return this.G <= a.x && a.x + a.width <= this.G + this.aa && this.H <= a.y && a.y + a.height <= this.H + this.$ };
    t.contains = function (a, b, c, d) { E ? (B(a, L, "contains:x"), B(b, L, "contains:y"), void 0 === c ? c = 0 : B(c, L, "contains:w"), void 0 === d ? d = 0 : B(d, L, "contains:h"), (0 > c || 0 > d) && v("Rect.contains:Width and height cannot be negative")) : (void 0 === c && (c = 0), void 0 === d && (d = 0)); return this.G <= a && a + c <= this.G + this.aa && this.H <= b && b + d <= this.H + this.$ }; t.reset = function () { E && this.ha(); this.$ = this.aa = this.H = this.G = 0 }; t.offset = function (a, b) { E && (B(a, L, "offset:dx"), B(b, L, "offset:dy"), this.ha()); this.G += a; this.H += b; return this };
    t.Xc = function (a, b) { E && (B(a, L, "inflate:w"), B(b, L, "inflate:h")); return Gc(this, b, a, b, a) }; t.Sp = function (a) { E && w(a, Hc, L, "addMargin:m"); return Gc(this, a.top, a.right, a.bottom, a.left) }; t.Vv = function (a) { E && w(a, Hc, L, "subtractMargin:m"); return Gc(this, -a.top, -a.right, -a.bottom, -a.left) }; t.vz = function (a, b, c, d) { E && (B(a, L, "grow:t"), B(b, L, "grow:r"), B(c, L, "grow:b"), B(d, L, "grow:l")); return Gc(this, a, b, c, d) };
    function Gc(a, b, c, d, e) { E && a.ha(); var f = a.aa; c + e <= -f ? (a.G += f / 2, a.aa = 0) : (a.G -= e, a.aa += c + e); c = a.$; b + d <= -c ? (a.H += c / 2, a.$ = 0) : (a.H -= b, a.$ += b + d); return a } t.zz = function (a) { E && w(a, L, L, "intersectRect:r"); return Kc(this, a.x, a.y, a.width, a.height) }; t.ov = function (a, b, c, d) { E && (B(a, L, "intersect:x"), B(b, L, "intersect:y"), B(c, L, "intersect:w"), B(d, L, "intersect:h"), (0 > c || 0 > d) && v("Rect.intersect:Width and height cannot be negative")); return Kc(this, a, b, c, d) };
    function Kc(a, b, c, d, e) { E && a.ha(); var f = Math.max(a.G, b), g = Math.max(a.H, c); b = Math.min(a.G + a.aa, b + d); c = Math.min(a.H + a.$, c + e); a.G = f; a.H = g; a.aa = Math.max(0, b - f); a.$ = Math.max(0, c - g); return a } t.Kc = function (a) { E && w(a, L, L, "intersectsRect:r"); return this.pv(a.x, a.y, a.width, a.height) };
    t.pv = function (a, b, c, d) { E && (B(a, L, "intersects:x"), B(b, L, "intersects:y"), B(a, L, "intersects:w"), B(b, L, "intersects:h"), (0 > c || 0 > d) && v("Rect.intersects:Width and height cannot be negative")); var e = this.aa, f = this.G; if (Infinity !== e && Infinity !== c && (e += f, c += a, isNaN(c) || isNaN(e) || f > c || a > e)) return !1; a = this.$; c = this.H; return Infinity !== a && Infinity !== d && (a += c, d += b, isNaN(d) || isNaN(a) || c > d || b > a) ? !1 : !0 };
    function Lc(a, b, c) { var d = a.aa, e = a.G, f = b.x - c; if (e > b.width + c + c + f || f > d + e) return !1; d = a.$; a = a.H; e = b.y - c; return a > b.height + c + c + e || e > d + a ? !1 : !0 } t.Le = function (a) { E && w(a, J, L, "unionPoint:p"); return Mc(this, a.x, a.y, 0, 0) }; t.Lc = function (a) { E && w(a, L, L, "unionRect:r"); return Mc(this, a.G, a.H, a.aa, a.$) };
    t.bw = function (a, b, c, d) { E ? (B(a, L, "union:x"), B(b, L, "union:y"), void 0 === c ? c = 0 : B(c, L, "union:w"), void 0 === d ? d = 0 : B(d, L, "union:h"), (0 > c || 0 > d) && v("Rect.union:Width and height cannot be negative"), this.ha()) : (void 0 === c && (c = 0), void 0 === d && (d = 0)); return Mc(this, a, b, c, d) }; function Mc(a, b, c, d, e) { var f = Math.min(a.G, b), g = Math.min(a.H, c); b = Math.max(a.G + a.aa, b + d); c = Math.max(a.H + a.$, c + e); a.G = f; a.H = g; a.aa = b - f; a.$ = c - g; return a }
    t.uk = function (a, b, c) { E && (B(a, L, "setSpot:x"), B(b, L, "setSpot:y"), w(c, M, L, "setSpot:spot"), this.ha()); this.G = a - c.offsetX - c.x * this.aa; this.H = b - c.offsetY - c.y * this.$; return this };
    function Qc(a, b, c, d, e, f, g, h) { E ? (B(a, L, "contains:rx"), B(b, L, "contains:ry"), B(c, L, "contains:rw"), B(d, L, "contains:rh"), B(e, L, "contains:x"), B(f, L, "contains:y"), void 0 === g ? g = 0 : B(g, L, "contains:w"), void 0 === h ? h = 0 : B(h, L, "contains:h"), (0 > c || 0 > d || 0 > g || 0 > h) && v("Rect.contains:Width and height cannot be negative")) : (void 0 === g && (g = 0), void 0 === h && (h = 0)); return a <= e && e + g <= a + c && b <= f && f + h <= b + d }
    function Rc(a, b, c, d, e, f, g, h) { E && (B(a, L, "intersects:rx"), B(b, L, "intersects:ry"), B(c, L, "intersects:rw"), B(d, L, "intersects:rh"), B(e, L, "intersects:x"), B(f, L, "intersects:y"), B(g, L, "intersects:w"), B(h, L, "intersects:h"), (0 > c || 0 > d || 0 > g || 0 > h) && v("Rect.intersects:Width and height cannot be negative")); return a > g + e || e > c + a ? !1 : b > h + f || f > d + b ? !1 : !0 } t.o = function () { return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height) }; t.Bz = function () { return 0 === this.width && 0 === this.height };
    L.alloc = function () { var a = Sc.pop(); return void 0 === a ? new L : a }; L.allocAt = function (a, b, c, d) { var e = Sc.pop(); return void 0 === e ? new L(a, b, c, d) : e.h(a, b, c, d) }; L.free = function (a) { Sc.push(a) };
    na.Object.defineProperties(L.prototype, {
        x: { configurable: !0, get: function () { return this.G }, set: function (a) { E && (z(a, "number", L, "x"), this.ha(a)); this.G = a } }, y: { configurable: !0, get: function () { return this.H }, set: function (a) { E && (z(a, "number", L, "y"), this.ha(a)); this.H = a } }, width: { configurable: !0, get: function () { return this.aa }, set: function (a) { E && (z(a, "number", L, "width"), this.ha(a)); 0 > a && Ca(a, ">= 0", L, "width"); this.aa = a } }, height: {
            configurable: !0, get: function () { return this.$ },
            set: function (a) { E && (z(a, "number", L, "height"), this.ha(a)); 0 > a && Ca(a, ">= 0", L, "height"); this.$ = a }
        }, left: { configurable: !0, get: function () { return this.G }, set: function (a) { E && (z(a, "number", L, "left"), this.ha(a)); this.G = a } }, top: { configurable: !0, get: function () { return this.H }, set: function (a) { E && (z(a, "number", L, "top"), this.ha(a)); this.H = a } }, right: { configurable: !0, get: function () { return this.G + this.aa }, set: function (a) { E && (B(a, L, "right"), this.ha(a)); this.G += a - (this.G + this.aa) } },
        bottom: { configurable: !0, get: function () { return this.H + this.$ }, set: function (a) { E && (B(a, L, "top"), this.ha(a)); this.H += a - (this.H + this.$) } }, position: { configurable: !0, get: function () { return new J(this.G, this.H) }, set: function (a) { E && (w(a, J, L, "position"), this.ha(a)); this.G = a.x; this.H = a.y } }, size: { configurable: !0, get: function () { return new Zb(this.aa, this.$) }, set: function (a) { E && (w(a, Zb, L, "size"), this.ha(a)); this.aa = a.width; this.$ = a.height } }, center: {
            configurable: !0,
            get: function () { return new J(this.G + this.aa / 2, this.H + this.$ / 2) }, set: function (a) { E && (w(a, J, L, "center"), this.ha(a)); this.G = a.x - this.aa / 2; this.H = a.y - this.$ / 2 }
        }, centerX: { configurable: !0, get: function () { return this.G + this.aa / 2 }, set: function (a) { E && (B(a, L, "centerX"), this.ha(a)); this.G = a - this.aa / 2 } }, centerY: { configurable: !0, get: function () { return this.H + this.$ / 2 }, set: function (a) { E && (B(a, L, "centerY"), this.ha(a)); this.H = a - this.$ / 2 } }
    }); L.prototype.isEmpty = L.prototype.Bz;
    L.prototype.isReal = L.prototype.o; L.prototype.setSpot = L.prototype.uk; L.prototype.union = L.prototype.bw; L.prototype.unionRect = L.prototype.Lc; L.prototype.unionPoint = L.prototype.Le; L.prototype.intersects = L.prototype.pv; L.prototype.intersectsRect = L.prototype.Kc; L.prototype.intersect = L.prototype.ov; L.prototype.intersectRect = L.prototype.zz; L.prototype.grow = L.prototype.vz; L.prototype.subtractMargin = L.prototype.Vv; L.prototype.addMargin = L.prototype.Sp; L.prototype.inflate = L.prototype.Xc; L.prototype.offset = L.prototype.offset;
    L.prototype.contains = L.prototype.contains; L.prototype.containsRect = L.prototype.pf; L.prototype.containsPoint = L.prototype.ea; L.prototype.equalsApprox = L.prototype.Sa; L.prototype.equalTo = L.prototype.Hi; L.prototype.equals = L.prototype.A; L.prototype.setSize = L.prototype.bA; L.prototype.setPoint = L.prototype.ld; L.prototype.set = L.prototype.set; L.prototype.setTo = L.prototype.wg; var Tc = null, Uc = null, Sc = []; L.className = "Rect"; L.parse = Dc; L.stringify = Ec; L.contains = Qc; L.intersects = Rc; L.ZeroRect = Tc = (new L(0, 0, 0, 0)).ia();
    L.NoRect = Uc = (new L(NaN, NaN, NaN, NaN)).ia(); L.parse = Dc; L.stringify = Ec; L.contains = Qc; L.intersects = Rc; function Hc(a, b, c, d) { void 0 === a ? this.ne = this.de = this.xe = this.ze = 0 : void 0 === b ? this.left = this.bottom = this.right = this.top = a : void 0 === c ? (this.top = a, this.right = b, this.bottom = a, this.left = b) : void 0 !== d ? (this.top = a, this.right = b, this.bottom = c, this.left = d) : v("Invalid arguments to Margin constructor: " + a + ", " + b + ", " + c + ", " + d); this.u = !1 }
    Hc.prototype.assign = function (a) { this.ze = a.ze; this.xe = a.xe; this.de = a.de; this.ne = a.ne; return this }; Hc.prototype.wg = function (a, b, c, d) { E && (z(a, "number", Hc, "setTo:t"), z(b, "number", Hc, "setTo:r"), z(c, "number", Hc, "setTo:b"), z(d, "number", Hc, "setTo:l"), this.ha()); this.ze = a; this.xe = b; this.de = c; this.ne = d; return this }; Hc.prototype.set = function (a) { E && (w(a, Hc, Hc, "assign:m"), this.ha()); this.ze = a.ze; this.xe = a.xe; this.de = a.de; this.ne = a.ne; return this };
    Hc.prototype.copy = function () { var a = new Hc; a.ze = this.ze; a.xe = this.xe; a.de = this.de; a.ne = this.ne; return a }; t = Hc.prototype; t.ia = function () { this.u = !0; Object.freeze(this); return this }; t.J = function () { return Object.isFrozen(this) ? this : this.copy().freeze() }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { Object.isFrozen(this) && v("cannot thaw constant: " + this); this.u = !1; return this };
    t.ha = function (a) { if (this.u) { var b = "The Margin is frozen, so its properties cannot be set: " + this.toString(); void 0 !== a && (b += "  to value: " + a); v(b) } };
    function Vc(a) { if ("string" === typeof a) { a = a.split(" "); for (var b = 0, c = NaN; "" === a[b];)b++; var d = a[b++]; d && (c = parseFloat(d)); if (isNaN(c)) return new Hc; for (var e = NaN; "" === a[b];)b++; (d = a[b++]) && (e = parseFloat(d)); if (isNaN(e)) return new Hc(c); for (var f = NaN; "" === a[b];)b++; (d = a[b++]) && (f = parseFloat(d)); if (isNaN(f)) return new Hc(c, e); for (var g = NaN; "" === a[b];)b++; (d = a[b++]) && (g = parseFloat(d)); return isNaN(g) ? new Hc(c, e) : new Hc(c, e, f, g) } return new Hc }
    function Xc(a) { E && w(a, Hc); return a.top.toString() + " " + a.right.toString() + " " + a.bottom.toString() + " " + a.left.toString() } t.toString = function () { return "Margin(" + this.top + "," + this.right + "," + this.bottom + "," + this.left + ")" }; t.A = function (a) { return a instanceof Hc ? this.ze === a.top && this.xe === a.right && this.de === a.bottom && this.ne === a.left : !1 }; t.Hi = function (a, b, c, d) { return this.ze === a && this.xe === b && this.de === c && this.ne === d };
    t.Sa = function (a) { return K.B(this.ze, a.top) && K.B(this.xe, a.right) && K.B(this.de, a.bottom) && K.B(this.ne, a.left) }; t.o = function () { return isFinite(this.top) && isFinite(this.right) && isFinite(this.bottom) && isFinite(this.left) }; Hc.alloc = function () { var a = Yc.pop(); return void 0 === a ? new Hc : a }; Hc.free = function (a) { Yc.push(a) };
    na.Object.defineProperties(Hc.prototype, {
        top: { configurable: !0, get: function () { return this.ze }, set: function (a) { E && (B(a, Hc, "top"), this.ha(a)); this.ze = a } }, right: { configurable: !0, get: function () { return this.xe }, set: function (a) { E && (B(a, Hc, "right"), this.ha(a)); this.xe = a } }, bottom: { configurable: !0, get: function () { return this.de }, set: function (a) { E && (B(a, Hc, "bottom"), this.ha(a)); this.de = a } }, left: {
            configurable: !0, get: function () { return this.ne }, set: function (a) {
                E &&
                (B(a, Hc, "left"), this.ha(a)); this.ne = a
            }
        }
    }); Hc.prototype.isReal = Hc.prototype.o; Hc.prototype.equalsApprox = Hc.prototype.Sa; Hc.prototype.equalTo = Hc.prototype.Hi; Hc.prototype.equals = Hc.prototype.A; Hc.prototype.set = Hc.prototype.set; Hc.prototype.setTo = Hc.prototype.wg; var Zc = null, cd = null, Yc = []; Hc.className = "Margin"; Hc.parse = Vc; Hc.stringify = Xc; Hc.ZeroMargin = Zc = (new Hc(0, 0, 0, 0)).ia(); Hc.TwoMargin = cd = (new Hc(2, 2, 2, 2)).ia(); Hc.parse = Vc; Hc.stringify = Xc;
    function $b() { this.m11 = 1; this.m21 = this.m12 = 0; this.m22 = 1; this.dy = this.dx = 0 } $b.prototype.set = function (a) { this.m11 = a.m11; this.m12 = a.m12; this.m21 = a.m21; this.m22 = a.m22; this.dx = a.dx; this.dy = a.dy; return this }; $b.prototype.copy = function () { var a = new $b; a.m11 = this.m11; a.m12 = this.m12; a.m21 = this.m21; a.m22 = this.m22; a.dx = this.dx; a.dy = this.dy; return a }; t = $b.prototype; t.toString = function () { return "Transform(" + this.m11 + "," + this.m12 + "," + this.m21 + "," + this.m22 + "," + this.dx + "," + this.dy + ")" };
    t.A = function (a) { return a instanceof $b ? this.m11 === a.m11 && this.m12 === a.m12 && this.m21 === a.m21 && this.m22 === a.m22 && this.dx === a.dx && this.dy === a.dy : !1 }; t.it = function () { return 0 === this.dx && 0 === this.dy && 1 === this.m11 && 0 === this.m12 && 0 === this.m21 && 1 === this.m22 }; t.reset = function () { this.m11 = 1; this.m21 = this.m12 = 0; this.m22 = 1; this.dy = this.dx = 0; return this };
    t.multiply = function (a) { var b = this.m12 * a.m11 + this.m22 * a.m12, c = this.m11 * a.m21 + this.m21 * a.m22, d = this.m12 * a.m21 + this.m22 * a.m22, e = this.m11 * a.dx + this.m21 * a.dy + this.dx, f = this.m12 * a.dx + this.m22 * a.dy + this.dy; this.m11 = this.m11 * a.m11 + this.m21 * a.m12; this.m12 = b; this.m21 = c; this.m22 = d; this.dx = e; this.dy = f; return this };
    t.uv = function (a) { var b = 1 / (a.m11 * a.m22 - a.m12 * a.m21), c = a.m22 * b, d = -a.m12 * b, e = -a.m21 * b, f = a.m11 * b, g = b * (a.m21 * a.dy - a.m22 * a.dx); a = b * (a.m12 * a.dx - a.m11 * a.dy); b = this.m11 * c + this.m21 * d; c = this.m12 * c + this.m22 * d; d = this.m11 * e + this.m21 * f; e = this.m12 * e + this.m22 * f; this.dx = this.m11 * g + this.m21 * a + this.dx; this.dy = this.m12 * g + this.m22 * a + this.dy; this.m11 = b; this.m12 = c; this.m21 = d; this.m22 = e; return this };
    t.gt = function () { var a = 1 / (this.m11 * this.m22 - this.m12 * this.m21), b = -this.m12 * a, c = -this.m21 * a, d = this.m11 * a, e = a * (this.m21 * this.dy - this.m22 * this.dx), f = a * (this.m12 * this.dx - this.m11 * this.dy); this.m11 = this.m22 * a; this.m12 = b; this.m21 = c; this.m22 = d; this.dx = e; this.dy = f; return this };
    $b.prototype.rotate = function (a, b, c) { E && (B(a, $b, "rotate:angle"), B(b, $b, "rotate:rx"), B(c, $b, "rotate:ry")); 360 <= a ? a -= 360 : 0 > a && (a += 360); if (0 === a) return this; this.translate(b, c); if (90 === a) { a = 0; var d = 1 } else 180 === a ? (a = -1, d = 0) : 270 === a ? (a = 0, d = -1) : (d = a * Math.PI / 180, a = Math.cos(d), d = Math.sin(d)); var e = this.m12 * a + this.m22 * d, f = this.m11 * -d + this.m21 * a, g = this.m12 * -d + this.m22 * a; this.m11 = this.m11 * a + this.m21 * d; this.m12 = e; this.m21 = f; this.m22 = g; this.translate(-b, -c); return this }; t = $b.prototype;
    t.translate = function (a, b) { E && (B(a, $b, "translate:x"), B(b, $b, "translate:y")); this.dx += this.m11 * a + this.m21 * b; this.dy += this.m12 * a + this.m22 * b; return this }; t.scale = function (a, b) { void 0 === b && (b = a); E && (B(a, $b, "translate:sx"), B(b, $b, "translate:sy")); this.m11 *= a; this.m12 *= a; this.m21 *= b; this.m22 *= b; return this }; t.va = function (a) { var b = a.x, c = a.y; return a.h(b * this.m11 + c * this.m21 + this.dx, b * this.m12 + c * this.m22 + this.dy) };
    t.Wd = function (a) { var b = 1 / (this.m11 * this.m22 - this.m12 * this.m21), c = a.x, d = a.y; return a.h(c * this.m22 * b + d * -this.m21 * b + b * (this.m21 * this.dy - this.m22 * this.dx), c * -this.m12 * b + d * this.m11 * b + b * (this.m12 * this.dx - this.m11 * this.dy)) };
    t.aw = function (a) { var b = a.G, c = a.H, d = b + a.aa, e = c + a.$, f = this.m11, g = this.m12, h = this.m21, k = this.m22, l = this.dx, m = this.dy, n = b * f + c * h + l, p = b * g + c * k + m, q = d * f + c * h + l, r = d * g + c * k + m; c = b * f + e * h + l; b = b * g + e * k + m; f = d * f + e * h + l; d = d * g + e * k + m; e = Math.min(n, q); n = Math.max(n, q); q = Math.min(p, r); p = Math.max(p, r); e = Math.min(e, c); n = Math.max(n, c); q = Math.min(q, b); p = Math.max(p, b); e = Math.min(e, f); n = Math.max(n, f); q = Math.min(q, d); p = Math.max(p, d); a.G = e; a.H = q; a.aa = n - e; a.$ = p - q; return a };
    $b.alloc = function () { var a = dd.pop(); return void 0 === a ? new $b : a }; $b.free = function (a) { dd.push(a) }; $b.prototype.transformRect = $b.prototype.aw; $b.prototype.invertedTransformPoint = $b.prototype.Wd; $b.prototype.transformPoint = $b.prototype.va; $b.prototype.scale = $b.prototype.scale; $b.prototype.translate = $b.prototype.translate; $b.prototype.rotate = $b.prototype.rotate; $b.prototype.invert = $b.prototype.gt; $b.prototype.multiplyInverted = $b.prototype.uv; $b.prototype.multiply = $b.prototype.multiply;
    $b.prototype.reset = $b.prototype.reset; $b.prototype.isIdentity = $b.prototype.it; $b.prototype.equals = $b.prototype.A; $b.prototype.set = $b.prototype.set; var dd = []; $b.className = "Transform"; $b.xF = "54a702f3e53909c447824c6706603faf4c"; function M(a, b, c, d) { void 0 === a ? this.Pd = this.Od = this.H = this.G = 0 : (void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), this.x = a, this.y = b, this.offsetX = c, this.offsetY = d); this.u = !1 }
    var ed, fd, gd, hd, pd, qd, rd, sd, td, ud, vd, wd, Ad, Bd, Cd, Dd, Ed, Fd, Gd, Hd, Id, Md, Nd, Od, Pd, Qd, Rd, Sd, Td, Ud, Vd, Wd, Xd, de, ee, fe; M.prototype.assign = function (a) { this.G = a.G; this.H = a.H; this.Od = a.Od; this.Pd = a.Pd; return this }; M.prototype.wg = function (a, b, c, d) { E && (ge(a, "setTo:x"), ge(b, "setTo:y"), he(c, "setTo:offx"), he(d, "setTo:offy"), this.ha()); this.G = a; this.H = b; this.Od = c; this.Pd = d; return this }; M.prototype.set = function (a) { E && (w(a, M, M, "set:s"), this.ha()); this.G = a.G; this.H = a.H; this.Od = a.Od; this.Pd = a.Pd; return this };
    M.prototype.copy = function () { var a = new M; a.G = this.G; a.H = this.H; a.Od = this.Od; a.Pd = this.Pd; return a }; t = M.prototype; t.ia = function () { this.u = !0; Object.freeze(this); return this }; t.J = function () { return Object.isFrozen(this) ? this : this.copy().freeze() }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { Object.isFrozen(this) && v("cannot thaw constant: " + this); this.u = !1; return this };
    t.ha = function (a) { if (this.u) { var b = "The Spot is frozen, so its properties cannot be set: " + this.toString(); void 0 !== a && (b += "  to value: " + a); v(b) } }; function ie(a, b) { a.G = NaN; a.H = NaN; a.Od = b; return a } function ge(a, b) { (isNaN(a) || 1 < a || 0 > a) && Ca(a, "0 <= " + b + " <= 1", M, b) } function he(a, b) { (isNaN(a) || Infinity === a || -Infinity === a) && Ca(a, "real number, not NaN or Infinity", M, b) }
    function je(a) {
        if ("string" === typeof a) {
            a = a.trim(); if ("None" === a) return ed; if ("TopLeft" === a) return fd; if ("Top" === a || "TopCenter" === a || "MiddleTop" === a) return gd; if ("TopRight" === a) return hd; if ("Left" === a || "LeftCenter" === a || "MiddleLeft" === a) return pd; if ("Center" === a) return qd; if ("Right" === a || "RightCenter" === a || "MiddleRight" === a) return rd; if ("BottomLeft" === a) return sd; if ("Bottom" === a || "BottomCenter" === a || "MiddleBottom" === a) return td; if ("BottomRight" === a) return ud; if ("TopSide" === a) return vd; if ("LeftSide" ===
                a) return wd; if ("RightSide" === a) return Ad; if ("BottomSide" === a) return Bd; if ("TopBottomSides" === a) return Cd; if ("LeftRightSides" === a) return Dd; if ("TopLeftSides" === a) return Ed; if ("TopRightSides" === a) return Fd; if ("BottomLeftSides" === a) return Gd; if ("BottomRightSides" === a) return Hd; if ("NotTopSide" === a) return Id; if ("NotLeftSide" === a) return Md; if ("NotRightSide" === a) return Nd; if ("NotBottomSide" === a) return Od; if ("AllSides" === a) return Pd; if ("Default" === a) return Qd; a = a.split(" "); for (var b = 0, c = 0; "" === a[b];)b++;
            var d = a[b++]; void 0 !== d && 0 < d.length && (c = parseFloat(d)); for (var e = 0; "" === a[b];)b++; d = a[b++]; void 0 !== d && 0 < d.length && (e = parseFloat(d)); for (var f = 0; "" === a[b];)b++; d = a[b++]; void 0 !== d && 0 < d.length && (f = parseFloat(d)); for (var g = 0; "" === a[b];)b++; d = a[b++]; void 0 !== d && 0 < d.length && (g = parseFloat(d)); return new M(c, e, f, g)
        } return new M
    } function ke(a) { E && w(a, M); return a.Za() ? a.x.toString() + " " + a.y.toString() + " " + a.offsetX.toString() + " " + a.offsetY.toString() : a.toString() }
    t.toString = function () {
        return this.Za() ? 0 === this.Od && 0 === this.Pd ? "Spot(" + this.x + "," + this.y + ")" : "Spot(" + this.x + "," + this.y + "," + this.offsetX + "," + this.offsetY + ")" : this.A(ed) ? "None" : this.A(fd) ? "TopLeft" : this.A(gd) ? "Top" : this.A(hd) ? "TopRight" : this.A(pd) ? "Left" : this.A(qd) ? "Center" : this.A(rd) ? "Right" : this.A(sd) ? "BottomLeft" : this.A(td) ? "Bottom" : this.A(ud) ? "BottomRight" : this.A(vd) ? "TopSide" : this.A(wd) ? "LeftSide" : this.A(Ad) ? "RightSide" : this.A(Bd) ? "BottomSide" : this.A(Cd) ? "TopBottomSides" : this.A(Dd) ? "LeftRightSides" :
            this.A(Ed) ? "TopLeftSides" : this.A(Fd) ? "TopRightSides" : this.A(Gd) ? "BottomLeftSides" : this.A(Hd) ? "BottomRightSides" : this.A(Id) ? "NotTopSide" : this.A(Md) ? "NotLeftSide" : this.A(Nd) ? "NotRightSide" : this.A(Od) ? "NotBottomSide" : this.A(Pd) ? "AllSides" : this.A(Qd) ? "Default" : "None"
    }; t.A = function (a) { return a instanceof M ? (this.G === a.x || isNaN(this.G) && isNaN(a.x)) && (this.H === a.y || isNaN(this.H) && isNaN(a.y)) && this.Od === a.offsetX && this.Pd === a.offsetY : !1 };
    t.yv = function () { return new M(.5 - (this.G - .5), .5 - (this.H - .5), -this.Od, -this.Pd) }; t.sf = function (a) { if (!this.tf()) return !1; if (!a.tf()) if (a.A(Rd)) a = wd; else if (a.A(Sd)) a = Ad; else if (a.A(Td)) a = vd; else if (a.A(Ud)) a = Bd; else return !1; a = a.offsetY; return (this.Pd & a) === a }; t.Za = function () { return !isNaN(this.x) && !isNaN(this.y) }; t.Nb = function () { return isNaN(this.x) || isNaN(this.y) }; t.tf = function () { return isNaN(this.x) && isNaN(this.y) && 1 === this.offsetX && 0 !== this.offsetY };
    t.kq = function () { return isNaN(this.x) && isNaN(this.y) && 0 === this.offsetX && 0 === this.offsetY }; t.Cb = function () { return isNaN(this.x) && isNaN(this.y) && -1 === this.offsetX && 0 === this.offsetY }; M.alloc = function () { var a = le.pop(); return void 0 === a ? new M : a }; M.free = function (a) { le.push(a) };
    na.Object.defineProperties(M.prototype, {
        x: { configurable: !0, get: function () { return this.G }, set: function (a) { E && (ge(a, "x"), this.ha(a)); this.G = a } }, y: { configurable: !0, get: function () { return this.H }, set: function (a) { E && (ge(a, "y"), this.ha(a)); this.H = a } }, offsetX: { configurable: !0, get: function () { return this.Od }, set: function (a) { E && (he(a, "offsetX"), this.ha(a)); this.Od = a } }, offsetY: {
            configurable: !0, get: function () { return this.Pd }, set: function (a) {
                E && (he(a, "offsetY"),
                    this.ha(a)); this.Pd = a
            }
        }
    }); M.prototype.isDefault = M.prototype.Cb; M.prototype.isNone = M.prototype.kq; M.prototype.isSide = M.prototype.tf; M.prototype.isNoSpot = M.prototype.Nb; M.prototype.isSpot = M.prototype.Za; M.prototype.includesSide = M.prototype.sf; M.prototype.opposite = M.prototype.yv; M.prototype.equals = M.prototype.A; M.prototype.set = M.prototype.set; M.prototype.setTo = M.prototype.wg; var le = []; M.className = "Spot"; M.parse = je; M.stringify = ke; M.None = ed = ie(new M(0, 0, 0, 0), 0).ia(); M.Default = Qd = ie(new M(0, 0, -1, 0), -1).ia();
    M.TopLeft = fd = (new M(0, 0, 0, 0)).ia(); M.TopCenter = gd = (new M(.5, 0, 0, 0)).ia(); M.TopRight = hd = (new M(1, 0, 0, 0)).ia(); M.LeftCenter = pd = (new M(0, .5, 0, 0)).ia(); M.Center = qd = (new M(.5, .5, 0, 0)).ia(); M.RightCenter = rd = (new M(1, .5, 0, 0)).ia(); M.BottomLeft = sd = (new M(0, 1, 0, 0)).ia(); M.BottomCenter = td = (new M(.5, 1, 0, 0)).ia(); M.BottomRight = ud = (new M(1, 1, 0, 0)).ia(); M.MiddleTop = Vd = gd; M.MiddleLeft = Wd = pd; M.MiddleRight = Xd = rd; M.MiddleBottom = de = td; M.Top = Td = gd; M.Left = Rd = pd; M.Right = Sd = rd; M.Bottom = Ud = td;
    M.TopSide = vd = ie(new M(0, 0, 1, 1), 1).ia(); M.LeftSide = wd = ie(new M(0, 0, 1, 2), 1).ia(); M.RightSide = Ad = ie(new M(0, 0, 1, 4), 1).ia(); M.BottomSide = Bd = ie(new M(0, 0, 1, 8), 1).ia(); M.TopBottomSides = Cd = ie(new M(0, 0, 1, 9), 1).ia(); M.LeftRightSides = Dd = ie(new M(0, 0, 1, 6), 1).ia(); M.TopLeftSides = Ed = ie(new M(0, 0, 1, 3), 1).ia(); M.TopRightSides = Fd = ie(new M(0, 0, 1, 5), 1).ia(); M.BottomLeftSides = Gd = ie(new M(0, 0, 1, 10), 1).ia(); M.BottomRightSides = Hd = ie(new M(0, 0, 1, 12), 1).ia(); M.NotTopSide = Id = ie(new M(0, 0, 1, 14), 1).ia();
    M.NotLeftSide = Md = ie(new M(0, 0, 1, 13), 1).ia(); M.NotRightSide = Nd = ie(new M(0, 0, 1, 11), 1).ia(); M.NotBottomSide = Od = ie(new M(0, 0, 1, 7), 1).ia(); M.AllSides = Pd = ie(new M(0, 0, 1, 15), 1).ia(); ee = (new M(.156, .156)).ia(); fe = (new M(.844, .844)).ia(); M.parse = je; M.stringify = ke;
    var K = {
        jA: "7da71ca0ad381e90", Ag: (Math.sqrt(2) - 1) / 3 * 4, jw: null, sqrt: function (a) { if (0 >= a) return 0; var b = K.jw; if (null === b) { b = []; for (var c = 0; 2E3 >= c; c++)b[c] = Math.sqrt(c); K.jw = b } return 1 > a ? (c = 1 / a, 2E3 >= c ? 1 / b[c | 0] : Math.sqrt(a)) : 2E3 >= a ? b[a | 0] : Math.sqrt(a) }, B: function (a, b) { a -= b; return .5 > a && -.5 < a }, da: function (a, b) { a -= b; return 5E-8 > a && -5E-8 < a }, Vb: function (a, b, c, d, e, f, g) {
        0 >= e && (e = 1E-6); if (a < c) { var h = a; var k = c } else h = c, k = a; if (b < d) { var l = b; var m = d } else l = d, m = b; if (a === c) return l <= g && g <= m && a - e <= f && f <= a + e; if (b === d) return h <=
            f && f <= k && b - e <= g && g <= b + e; k += e; h -= e; if (h <= f && f <= k && (m += e, l -= e, l <= g && g <= m)) if (k - h > m - l) if (a - c > e || c - a > e) { if (f = (d - b) / (c - a) * (f - a) + b, f - e <= g && g <= f + e) return !0 } else return !0; else if (b - d > e || d - b > e) { if (g = (c - a) / (d - b) * (g - b) + a, g - e <= f && f <= g + e) return !0 } else return !0; return !1
        }, Ps: function (a, b, c, d, e, f, g, h, k, l, m, n) {
            if (K.Vb(a, b, g, h, n, c, d) && K.Vb(a, b, g, h, n, e, f)) return K.Vb(a, b, g, h, n, l, m); var p = (a + c) / 2, q = (b + d) / 2, r = (c + e) / 2, u = (d + f) / 2; e = (e + g) / 2; f = (f + h) / 2; d = (p + r) / 2; c = (q + u) / 2; r = (r + e) / 2; u = (u + f) / 2; var x = (d + r) / 2, y = (c + u) / 2; return K.Ps(a,
                b, p, q, d, c, x, y, k, l, m, n) || K.Ps(x, y, r, u, e, f, g, h, k, l, m, n)
        }, wy: function (a, b, c, d, e, f, g, h, k) { var l = (c + e) / 2, m = (d + f) / 2; k.h((((a + c) / 2 + l) / 2 + (l + (e + g) / 2) / 2) / 2, (((b + d) / 2 + m) / 2 + (m + (f + h) / 2) / 2) / 2); return k }, vy: function (a, b, c, d, e, f, g, h) { var k = (c + e) / 2, l = (d + f) / 2; return ec(((a + c) / 2 + k) / 2, ((b + d) / 2 + l) / 2, (k + (e + g) / 2) / 2, (l + (f + h) / 2) / 2) }, Wl: function (a, b, c, d, e, f, g, h, k, l) {
            if (K.Vb(a, b, g, h, k, c, d) && K.Vb(a, b, g, h, k, e, f)) Mc(l, a, b, 0, 0), Mc(l, g, h, 0, 0); else {
                var m = (a + c) / 2, n = (b + d) / 2, p = (c + e) / 2, q = (d + f) / 2; e = (e + g) / 2; f = (f + h) / 2; d = (m + p) / 2; c = (n + q) /
                    2; p = (p + e) / 2; q = (q + f) / 2; var r = (d + p) / 2, u = (c + q) / 2; K.Wl(a, b, m, n, d, c, r, u, k, l); K.Wl(r, u, p, q, e, f, g, h, k, l)
            } return l
        }, Ce: function (a, b, c, d, e, f, g, h, k, l) { if (K.Vb(a, b, g, h, k, c, d) && K.Vb(a, b, g, h, k, e, f)) 0 === l.length && (l.push(a), l.push(b)), l.push(g), l.push(h); else { var m = (a + c) / 2, n = (b + d) / 2, p = (c + e) / 2, q = (d + f) / 2; e = (e + g) / 2; f = (f + h) / 2; d = (m + p) / 2; c = (n + q) / 2; p = (p + e) / 2; q = (q + f) / 2; var r = (d + p) / 2, u = (c + q) / 2; K.Ce(a, b, m, n, d, c, r, u, k, l); K.Ce(r, u, p, q, e, f, g, h, k, l) } return l }, Bv: function (a, b, c, d, e, f, g, h, k, l) {
            if (K.Vb(a, b, e, f, l, c, d)) return K.Vb(a,
                b, e, f, l, h, k); var m = (a + c) / 2, n = (b + d) / 2; c = (c + e) / 2; d = (d + f) / 2; var p = (m + c) / 2, q = (n + d) / 2; return K.Bv(a, b, m, n, p, q, g, h, k, l) || K.Bv(p, q, c, d, e, f, g, h, k, l)
        }, uA: function (a, b, c, d, e, f, g) { g.h(((a + c) / 2 + (c + e) / 2) / 2, ((b + d) / 2 + (d + f) / 2) / 2); return g }, Av: function (a, b, c, d, e, f, g, h) { if (K.Vb(a, b, e, f, g, c, d)) Mc(h, a, b, 0, 0), Mc(h, e, f, 0, 0); else { var k = (a + c) / 2, l = (b + d) / 2; c = (c + e) / 2; d = (d + f) / 2; var m = (k + c) / 2, n = (l + d) / 2; K.Av(a, b, k, l, m, n, g, h); K.Av(m, n, c, d, e, f, g, h) } return h }, tq: function (a, b, c, d, e, f, g, h) {
            if (K.Vb(a, b, e, f, g, c, d)) 0 === h.length && (h.push(a),
                h.push(b)), h.push(e), h.push(f); else { var k = (a + c) / 2, l = (b + d) / 2; c = (c + e) / 2; d = (d + f) / 2; var m = (k + c) / 2, n = (l + d) / 2; K.tq(a, b, k, l, m, n, g, h); K.tq(m, n, c, d, e, f, g, h) } return h
        }, Tp: function (a, b, c, d, e, f, g, h, k, l, m, n, p, q) {
            if (K.Vb(a, b, g, h, p, c, d) && K.Vb(a, b, g, h, p, e, f)) { var r = (a - g) * (l - n) - (b - h) * (k - m); if (0 === r) return !1; p = ((a * h - b * g) * (k - m) - (a - g) * (k * n - l * m)) / r; r = ((a * h - b * g) * (l - n) - (b - h) * (k * n - l * m)) / r; if ((k > m ? k - m : m - k) < (l > n ? l - n : n - l)) { if (b < h ? g = b : (g = h, h = b), r < g || r > h) return !1 } else if (a < g ? h = a : (h = g, g = a), p < h || p > g) return !1; q.h(p, r); return !0 } r =
                (a + c) / 2; var u = (b + d) / 2; c = (c + e) / 2; d = (d + f) / 2; e = (e + g) / 2; f = (f + h) / 2; var x = (r + c) / 2, y = (u + d) / 2; c = (c + e) / 2; d = (d + f) / 2; var A = (x + c) / 2, C = (y + d) / 2, G = (m - k) * (m - k) + (n - l) * (n - l), H = !1; K.Tp(a, b, r, u, x, y, A, C, k, l, m, n, p, q) && (a = (q.x - k) * (q.x - k) + (q.y - l) * (q.y - l), a < G && (G = a, H = !0)); a = q.x; b = q.y; K.Tp(A, C, c, d, e, f, g, h, k, l, m, n, p, q) && ((q.x - k) * (q.x - k) + (q.y - l) * (q.y - l) < G ? H = !0 : q.h(a, b)); return H
        }, Up: function (a, b, c, d, e, f, g, h, k, l, m, n, p) {
            var q = 0; if (K.Vb(a, b, g, h, p, c, d) && K.Vb(a, b, g, h, p, e, f)) {
                p = (a - g) * (l - n) - (b - h) * (k - m); if (0 === p) return q; var r = ((a *
                    h - b * g) * (k - m) - (a - g) * (k * n - l * m)) / p, u = ((a * h - b * g) * (l - n) - (b - h) * (k * n - l * m)) / p; if (r >= m) return q; if ((k > m ? k - m : m - k) < (l > n ? l - n : n - l)) { if (b < h ? (a = b, b = h) : a = h, u < a || u > b) return q } else if (a < g ? (b = a, a = g) : b = g, r < b || r > a) return q; 0 < p ? q++ : 0 > p && q--
            } else { r = (a + c) / 2; u = (b + d) / 2; var x = (c + e) / 2, y = (d + f) / 2; e = (e + g) / 2; f = (f + h) / 2; d = (r + x) / 2; c = (u + y) / 2; x = (x + e) / 2; y = (y + f) / 2; var A = (d + x) / 2, C = (c + y) / 2; q += K.Up(a, b, r, u, d, c, A, C, k, l, m, n, p); q += K.Up(A, C, x, y, e, f, g, h, k, l, m, n, p) } return q
        }, Vi: function (a, b, c, d, e, f, g) {
            if (K.da(a, c)) {
                b < d ? (c = b, b = d) : c = d; if (f < c) return g.h(a,
                    c), !1; if (f > b) return g.h(a, b), !1; g.h(a, f); return !0
            } if (K.da(b, d)) { a < c ? (d = a, a = c) : d = c; if (e < d) return g.h(d, b), !1; if (e > a) return g.h(a, b), !1; g.h(e, b); return !0 } e = ((a - e) * (a - c) + (b - f) * (b - d)) / ((c - a) * (c - a) + (d - b) * (d - b)); if (-5E-6 > e) return g.h(a, b), !1; if (1.000005 < e) return g.h(c, d), !1; g.h(a + e * (c - a), b + e * (d - b)); return !0
        }, Ie: function (a, b, c, d, e, f, g, h, k) {
            if (K.B(a, c) && K.B(b, d)) return k.h(a, b), !1; if (K.da(e, g)) return K.da(a, c) ? (K.Vi(a, b, c, d, e, f, k), !1) : K.Vi(a, b, c, d, e, (d - b) / (c - a) * (e - a) + b, k); h = (h - f) / (g - e); if (K.da(a, c)) {
                c = h *
                (a - e) + f; b < d ? (e = b, b = d) : e = d; if (c < e) return k.h(a, e), !1; if (c > b) return k.h(a, b), !1; k.h(a, c); return !0
            } g = (d - b) / (c - a); if (K.da(h, g)) return K.Vi(a, b, c, d, e, f, k), !1; e = (g * a - h * e + f - b) / (g - h); if (K.da(g, 0)) { a < c ? (d = a, a = c) : d = c; if (e < d) return k.h(d, b), !1; if (e > a) return k.h(a, b), !1; k.h(e, b); return !0 } return K.Vi(a, b, c, d, e, g * (e - a) + b, k)
        }, qA: function (a, b, c, d, e) { return K.Ie(c.x, c.y, d.x, d.y, a.x, a.y, b.x, b.y, e) }, pA: function (a, b, c, d, e, f, g, h, k, l) {
            function m(c, d) { var e = (c - a) * (c - a) + (d - b) * (d - b); e < n && (n = e, k.h(c, d)) } var n = Infinity; m(k.x,
                k.y); var p = 0, q = 0, r = 0, u = 0; e < g ? (p = e, q = g) : (p = g, q = e); f < h ? (r = e, u = g) : (r = g, u = e); p = (q - p) / 2 + l; l = (u - r) / 2 + l; e = (e + g) / 2; f = (f + h) / 2; if (0 === p || 0 === l) return k; if (.5 > (c > a ? c - a : a - c)) { p = 1 - (c - e) * (c - e) / (p * p); if (0 > p) return k; p = Math.sqrt(p); d = -l * p + f; m(c, l * p + f); m(c, d) } else { c = (d - b) / (c - a); d = 1 / (p * p) + c * c / (l * l); h = 2 * c * (b - c * a) / (l * l) - 2 * c * f / (l * l) - 2 * e / (p * p); p = h * h - 4 * d * (2 * c * a * f / (l * l) - 2 * b * f / (l * l) + f * f / (l * l) + e * e / (p * p) - 1 + (b - c * a) * (b - c * a) / (l * l)); if (0 > p) return k; p = Math.sqrt(p); l = (-h + p) / (2 * d); m(l, c * l - c * a + b); p = (-h - p) / (2 * d); m(p, c * p - c * a + b) } return k
        },
        Wc: function (a, b, c, d, e, f, g, h, k) { var l = 1E21, m = a, n = b; if (K.Ie(a, b, a, d, e, f, g, h, k)) { var p = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f); p < l && (l = p, m = k.x, n = k.y) } K.Ie(c, b, c, d, e, f, g, h, k) && (p = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), p < l && (l = p, m = k.x, n = k.y)); K.Ie(a, b, c, b, e, f, g, h, k) && (b = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), b < l && (l = b, m = k.x, n = k.y)); K.Ie(a, d, c, d, e, f, g, h, k) && (a = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), a < l && (l = a, m = k.x, n = k.y)); k.h(m, n); return 1E21 > l }, oA: function (a, b, c, d, e, f, g, h, k) {
            c = a - c; g = e - g; 0 === c || 0 === g ? 0 === c ? (b = (f - h) / g, h = a, e = b * h + (f -
                b * e)) : (f = (b - d) / c, h = e, e = f * h + (b - f * a)) : (d = (b - d) / c, h = (f - h) / g, a = b - d * a, h = (f - h * e - a) / (d - h), e = d * h + a); k.h(h, e); return k
        }, et: function (a, b, c) { var d = b.x, e = b.y, f = c.x, g = c.y, h = a.left, k = a.right, l = a.top, m = a.bottom; return d === f ? (e < g ? (f = e, e = g) : f = g, h <= d && d <= k && f <= m && e >= l) : e === g ? (d < f ? (g = d, d = f) : g = f, l <= e && e <= m && g <= k && d >= h) : a.ea(b) || a.ea(c) || K.dt(h, l, k, l, d, e, f, g) || K.dt(k, l, k, m, d, e, f, g) || K.dt(k, m, h, m, d, e, f, g) || K.dt(h, m, h, l, d, e, f, g) ? !0 : !1 }, dt: function (a, b, c, d, e, f, g, h) {
            return 0 >= K.Rs(a, b, c, d, e, f) * K.Rs(a, b, c, d, g, h) && 0 >= K.Rs(e,
                f, g, h, a, b) * K.Rs(e, f, g, h, c, d)
        }, Rs: function (a, b, c, d, e, f) { c -= a; d -= b; a = e - a; b = f - b; f = a * d - b * c; 0 === f && (f = a * c + b * d, 0 < f && (f = (a - c) * c + (b - d) * d, 0 > f && (f = 0))); return 0 > f ? -1 : 0 < f ? 1 : 0 }, qq: function (a) { 0 > a && (a += 360); 360 <= a && (a -= 360); return a }, hx: function (a, b, c, d, e, f) {
            var g = Math.PI; f || (d *= g / 180, e *= g / 180); var h = d > e ? -1 : 1; f = []; var k = g / 2, l = d; d = Math.min(2 * g, Math.abs(e - d)); if (1E-5 > d) return k = l + h * Math.min(d, k), h = a + c * Math.cos(l), l = b + c * Math.sin(l), a += c * Math.cos(k), b += c * Math.sin(k), c = (h + a) / 2, k = (l + b) / 2, f.push([h, l, c, k, c, k, a, b]), f;
            for (; 1E-5 < d;)e = l + h * Math.min(d, k), f.push(K.Dy(c, l, e, a, b)), d -= Math.abs(e - l), l = e; return f
        }, Dy: function (a, b, c, d, e) { var f = (c - b) / 2, g = a * Math.cos(f), h = a * Math.sin(f), k = -h, l = g * g + k * k, m = l + g * g + k * h; l = 4 / 3 * (Math.sqrt(2 * l * m) - m) / (g * h - k * g); h = g - l * k; g = k + l * g; k = -g; l = f + b; f = Math.cos(l); l = Math.sin(l); return [d + a * Math.cos(b), e + a * Math.sin(b), d + h * f - g * l, e + h * l + g * f, d + h * f - k * l, e + h * l + k * f, d + a * Math.cos(c), e + a * Math.sin(c)] }, bq: function (a, b, c, d, e, f, g) {
            c = Math.floor((a - c) / e) * e + c; d = Math.floor((b - d) / f) * f + d; var h = c; c + e - a < e / 2 && (h = c + e); a = d; d +
                f - b < f / 2 && (a = d + f); g.h(h, a); return g
        }, px: function (a, b) { var c = Math.max(a, b); a = Math.min(a, b); var d; do b = c % a, c = d = a, a = b; while (0 < b); return d }, Iy: function (a, b, c, d) { var e = 0 > c, f = 0 > d; if (a < b) { var g = 1; var h = 0 } else g = 0, h = 1; var k = 0 === g ? a : b; var l = 0 === g ? c : d; if (0 === g ? e : f) l = -l; g = h; c = 0 === g ? c : d; if (0 === g ? e : f) c = -c; return K.Jy(k, 0 === g ? a : b, l, c, 0, 0) }, Jy: function (a, b, c, d, e, f) {
            if (0 < d) if (0 < c) {
                e = a * a; f = b * b; a *= c; var g = b * d, h = -f + g, k = -f + Math.sqrt(a * a + g * g); b = h; for (var l = 0; 9999999999 > l; ++l) {
                    b = .5 * (h + k); if (b === h || b === k) break; var m = a / (b +
                        e), n = g / (b + f); m = m * m + n * n - 1; if (0 < m) h = b; else if (0 > m) k = b; else break
                } c = e * c / (b + e) - c; d = f * d / (b + f) - d; c = Math.sqrt(c * c + d * d)
            } else c = Math.abs(d - b); else d = a * a - b * b, f = a * c, f < d ? (d = f / d, f = b * Math.sqrt(Math.abs(1 - d * d)), c = a * d - c, c = Math.sqrt(c * c + f * f)) : c = Math.abs(c - a); return c
        }, be: new xb, Fm: new xb
    }; K.za = K.jA;
    function me(a) { E && 1 < arguments.length && v("Geometry constructor can take at most one optional argument, the Geometry type."); qb(this); this.u = !1; void 0 === a ? a = ne : E && tb(a, me, me, "constructor:type"); this.wa = a; this.Dc = this.nc = this.dd = this.cd = 0; this.kj = new F; this.ur = this.kj.s; this.br = (new L).freeze(); this.ta = !0; this.Rm = this.Ck = null; this.Sm = NaN; this.ef = fd; this.ff = ud; this.gl = this.il = NaN; this.Gf = oe }
    me.prototype.copy = function () { var a = new me; a.wa = this.wa; a.cd = this.cd; a.dd = this.dd; a.nc = this.nc; a.Dc = this.Dc; for (var b = this.kj.j, c = b.length, d = a.kj, e = 0; e < c; e++) { var f = b[e].copy(); d.add(f) } a.ur = this.ur; a.br.assign(this.br); a.ta = this.ta; a.Ck = this.Ck; a.Rm = this.Rm; a.Sm = this.Sm; a.ef = this.ef.J(); a.ff = this.ff.J(); a.il = this.il; a.gl = this.gl; a.Gf = this.Gf; return a }; t = me.prototype; t.ia = function () { this.freeze(); Object.freeze(this); return this };
    t.freeze = function () { this.u = !0; var a = this.figures; a.freeze(); a = a.j; for (var b = a.length, c = 0; c < b; c++)a[c].freeze(); return this }; t.ja = function () { Object.isFrozen(this) && v("cannot thaw constant: " + this); this.u = !1; var a = this.figures; a.ja(); a = a.j; for (var b = a.length, c = 0; c < b; c++)a[c].ja(); return this };
    t.Sa = function (a) { if (!(a instanceof me)) return !1; if (this.type !== a.type) return this.type === pe && a.type === ne ? ue(this, a) : a.type === pe && this.type === ne ? ue(a, this) : !1; if (this.type === ne) { var b = this.figures.j; a = a.figures.j; var c = b.length; if (c !== a.length) return !1; for (var d = 0; d < c; d++)if (!b[d].Sa(a[d])) return !1; return !0 } return K.B(this.startX, a.startX) && K.B(this.startY, a.startY) && K.B(this.endX, a.endX) && K.B(this.endY, a.endY) };
    function ue(a, b) { return a.type !== pe || b.type !== ne ? !1 : 1 === b.figures.count && (b = b.figures.O(0), 1 === b.segments.count && K.B(a.startX, b.startX) && K.B(a.startY, b.startY) && (b = b.segments.O(0), b.type === ve && K.B(a.endX, b.endX) && K.B(a.endY, b.endY))) ? !0 : !1 } function we(a) { return a.toString() } t.hb = function (a) { a.classType === me ? this.type = a : Fa(this, a) };
    t.toString = function (a) {
    void 0 === a && (a = -1); switch (this.type) {
        case pe: return 0 > a ? "M" + this.startX.toString() + " " + this.startY.toString() + "L" + this.endX.toString() + " " + this.endY.toString() : "M" + this.startX.toFixed(a) + " " + this.startY.toFixed(a) + "L" + this.endX.toFixed(a) + " " + this.endY.toFixed(a); case xe: var b = new L(this.startX, this.startY, 0, 0); b.bw(this.endX, this.endY, 0, 0); return 0 > a ? "M" + b.x.toString() + " " + b.y.toString() + "H" + b.right.toString() + "V" + b.bottom.toString() + "H" + b.left.toString() + "z" : "M" + b.x.toFixed(a) +
            " " + b.y.toFixed(a) + "H" + b.right.toFixed(a) + "V" + b.bottom.toFixed(a) + "H" + b.left.toFixed(a) + "z"; case ye: b = new L(this.startX, this.startY, 0, 0); b.bw(this.endX, this.endY, 0, 0); if (0 > a) return a = b.left.toString() + " " + (b.y + b.height / 2).toString(), "M" + a + "A" + (b.width / 2).toString() + " " + (b.height / 2).toString() + " 0 0 1 " + (b.right.toString() + " " + (b.y + b.height / 2).toString()) + "A" + (b.width / 2).toString() + " " + (b.height / 2).toString() + " 0 0 1 " + a; var c = b.left.toFixed(a) + " " + (b.y + b.height / 2).toFixed(a); return "M" + c + "A" + (b.width /
                2).toFixed(a) + " " + (b.height / 2).toFixed(a) + " 0 0 1 " + (b.right.toFixed(a) + " " + (b.y + b.height / 2).toFixed(a)) + "A" + (b.width / 2).toFixed(a) + " " + (b.height / 2).toFixed(a) + " 0 0 1 " + c; case ne: b = ""; c = this.figures.j; for (var d = c.length, e = 0; e < d; e++) { var f = c[e]; 0 < e && (b += " x "); f.isFilled && (b += "F "); b += f.toString(a) } return b; default: return this.type.toString()
    }
    };
    function ze(a, b) {
        function c() { return u >= G - 1 ? !0 : null !== k[u + 1].match(/[UuBbMmZzLlHhVvCcSsQqTtAaFfXx]/) } function d() { u++; return k[u] } function e() { var a = new J(parseFloat(d()), parseFloat(d())); x === x.toLowerCase() && (a.x = C.x + a.x, a.y = C.y + a.y); return a } function f() { return C = e() } function g() { return A = e() } function h() { var a = y.toLowerCase(); return "c" !== a && "s" !== a && "q" !== a && "t" !== a ? C : new J(2 * C.x - A.x, 2 * C.y - A.y) } void 0 === b && (b = !1); "string" !== typeof a && Ba(a, "string", me, "parse:str"); a = a.replace(/,/gm, " "); a = a.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm,
            "$1 $2"); a = a.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm, "$1 $2"); a = a.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([^\s])/gm, "$1 $2"); a = a.replace(/([^\s])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm, "$1 $2"); a = a.replace(/([0-9])([+\-])/gm, "$1 $2"); a = a.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 "); a = a.replace(/[\s\r\t\n]+/gm, " "); a = a.replace(/^\s+|\s+$/g, ""); var k = a.split(" "); for (a = 0; a < k.length; a++) {
                var l = k[a]; if (null !== l.match(/(\.[0-9]*)(\.)/gm)) {
                    for (var m =
                        Qa(), n = "", p = !1, q = 0; q < l.length; q++) { var r = l[q]; "." !== r || p ? "." === r ? (m.push(n), n = ".") : n += r : (p = !0, n += r) } m.push(n); k.splice(a, 1); for (l = 0; l < m.length; l++)k.splice(a + l, 0, m[l]); a += m.length - 1; Ta(m)
                }
            } var u = -1, x = "", y = ""; m = new J(0, 0); var A = new J(0, 0), C = new J(0, 0), G = k.length; a = Ae(null); n = l = !1; p = !0; for (q = null; !(u >= G - 1);)if (y = x, x = d(), "" !== x) switch (x.toUpperCase()) {
                case "X": p = !0; n = l = !1; break; case "M": q = f(); null === a.gc || !0 === p ? (Be(a, q.x, q.y, l, !n), p = !1) : a.moveTo(q.x, q.y); for (m = C; !c();)q = f(), a.lineTo(q.x, q.y); break;
                case "L": for (; !c();)q = f(), a.lineTo(q.x, q.y); break; case "H": for (; !c();)C = new J((x === x.toLowerCase() ? C.x : 0) + parseFloat(d()), C.y), a.lineTo(C.x, C.y); break; case "V": for (; !c();)C = new J(C.x, (x === x.toLowerCase() ? C.y : 0) + parseFloat(d())), a.lineTo(C.x, C.y); break; case "C": for (; !c();) { q = e(); r = g(); var H = f(); Ce(a, q.x, q.y, r.x, r.y, H.x, H.y) } break; case "S": for (; !c();)q = h(), r = g(), H = f(), Ce(a, q.x, q.y, r.x, r.y, H.x, H.y); break; case "Q": for (; !c();)q = g(), r = f(), He(a, q.x, q.y, r.x, r.y); break; case "T": for (; !c();)A = q = h(), r = f(), He(a,
                    q.x, q.y, r.x, r.y); break; case "B": for (; !c();) { q = parseFloat(d()); r = parseFloat(d()); H = parseFloat(d()); var O = parseFloat(d()), S = parseFloat(d()), T = S, ea = !1; c() || (T = parseFloat(d()), c() || (ea = 0 !== parseFloat(d()))); x === x.toLowerCase() && (H += C.x, O += C.y); a.arcTo(q, r, H, O, S, T, ea) } break; case "A": for (; !c();)q = Math.abs(parseFloat(d())), r = Math.abs(parseFloat(d())), H = parseFloat(d()), O = !!parseFloat(d()), S = !!parseFloat(d()), T = f(), Ie(a, q, r, H, O, S, T.x, T.y); break; case "Z": Je(a); C = m; break; case "F": q = ""; for (r = 1; k[u + r];)if (null !==
                        k[u + r].match(/[Uu]/)) r++; else if (null === k[u + r].match(/[UuBbMmZzLlHhVvCcSsQqTtAaFfXx]/)) r++; else { q = k[u + r]; break } q.match(/[Mm]/) ? l = !0 : 0 < a.gc.segments.length && (a.gc.isFilled = !0); break; case "U": q = ""; for (r = 1; k[u + r];)if (null !== k[u + r].match(/[Ff]/)) r++; else if (null === k[u + r].match(/[UuBbMmZzLlHhVvCcSsQqTtAaFfXx]/)) r++; else { q = k[u + r]; break } q.match(/[Mm]/) ? n = !0 : a.Aq(!1)
            }m = a.Zs; Ke = a; if (b) for (b = m.figures.iterator; b.next();)b.value.isFilled = !0; return m
    }
    function Le(a, b) { for (var c = a.length, d = J.alloc(), e = 0; e < c; e++) { var f = a[e]; d.x = f[0]; d.y = f[1]; b.va(d); f[0] = d.x; f[1] = d.y; d.x = f[2]; d.y = f[3]; b.va(d); f[2] = d.x; f[3] = d.y; d.x = f[4]; d.y = f[5]; b.va(d); f[4] = d.x; f[5] = d.y; d.x = f[6]; d.y = f[7]; b.va(d); f[6] = d.x; f[7] = d.y } J.free(d) } t.sv = function () { if (this.ta || this.ur !== this.figures.s) return !0; for (var a = this.figures.j, b = a.length, c = 0; c < b; c++)if (a[c].sv()) return !0; return !1 };
    me.prototype.computeBounds = function () { this.ta = !1; this.Rm = this.Ck = null; this.Sm = NaN; this.ur = this.figures.s; for (var a = this.figures.j, b = a.length, c = 0; c < b; c++) { var d = a[c]; d.ta = !1; var e = d.segments; d.zs = e.s; d = e.j; e = d.length; for (var f = 0; f < e; f++) { var g = d[f]; g.ta = !1; g.Me = null } } a = this.br; a.ja(); isNaN(this.il) || isNaN(this.gl) ? a.h(0, 0, 0, 0) : a.h(0, 0, this.il, this.gl); Me(this, a, !1); Mc(a, 0, 0, 0, 0); a.freeze() }; me.prototype.gx = function () { var a = new L; Me(this, a, !0); return a };
    function Me(a, b, c) {
        switch (a.type) {
            case pe: case xe: case ye: c ? b.h(a.cd, a.dd, 0, 0) : Mc(b, a.cd, a.dd, 0, 0); Mc(b, a.nc, a.Dc, 0, 0); break; case ne: var d = a.figures; a = d.j; d = d.length; for (var e = 0; e < d; e++) {
                var f = a[e]; c && 0 === e ? b.h(f.startX, f.startY, 0, 0) : Mc(b, f.startX, f.startY, 0, 0); for (var g = f.segments.j, h = g.length, k = f.startX, l = f.startY, m = 0; m < h; m++) {
                    var n = g[m]; switch (n.type) {
                        case ve: case Ne: k = n.endX; l = n.endY; Mc(b, k, l, 0, 0); break; case Oe: K.Wl(k, l, n.point1X, n.point1Y, n.point2X, n.point2Y, n.endX, n.endY, .5, b); k = n.endX; l = n.endY;
                            break; case Pe: K.Av(k, l, n.point1X, n.point1Y, n.endX, n.endY, .5, b); k = n.endX; l = n.endY; break; case Qe: case Re: var p = n.type === Qe ? Se(n, f) : Te(n, f, k, l), q = p.length; if (0 === q) { k = n.centerX; l = n.centerY; Mc(b, k, l, 0, 0); break } n = null; for (var r = 0; r < q; r++)n = p[r], K.Wl(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], .5, b); null !== n && (k = n[6], l = n[7]); break; default: v("Unknown Segment type: " + n.type)
                    }
                }
            } break; default: v("Unknown Geometry type: " + a.type)
        }
    }
    me.prototype.normalize = function () { this.u && ya(this); var a = this.gx(); this.offset(-a.x, -a.y); return new J(-a.x, -a.y) }; me.prototype.offset = function (a, b) { this.u && ya(this); E && (B(a, me, "offset"), B(b, me, "offset")); this.transform(1, 0, 0, 1, a, b); return this }; me.prototype.scale = function (a, b) { this.u && ya(this); E && (B(a, me, "scale:x"), B(b, me, "scale:y"), 0 === a && Ca(a, "scale must be non-zero", me, "scale:x"), 0 === b && Ca(b, "scale must be non-zero", me, "scale:y")); this.transform(a, 0, 0, b, 0, 0); return this };
    me.prototype.rotate = function (a, b, c) { this.u && ya(this); void 0 === b && (b = 0); void 0 === c && (c = 0); E && (B(a, me, "rotate:angle"), B(b, me, "rotate:x"), B(c, me, "rotate:y")); var d = $b.alloc(); d.reset(); d.rotate(a, b, c); this.transform(d.m11, d.m12, d.m21, d.m22, d.dx, d.dy); $b.free(d); return this }; t = me.prototype;
    t.transform = function (a, b, c, d, e, f) {
        switch (this.type) {
            case pe: case xe: case ye: var g = this.cd; var h = this.dd; this.cd = g * a + h * c + e; this.dd = g * b + h * d + f; g = this.nc; h = this.Dc; this.nc = g * a + h * c + e; this.Dc = g * b + h * d + f; break; case ne: for (var k = this.figures.j, l = k.length, m = 0; m < l; m++) {
                var n = k[m]; g = n.startX; h = n.startY; n.startX = g * a + h * c + e; n.startY = g * b + h * d + f; n = n.segments.j; for (var p = n.length, q = 0; q < p; q++) {
                    var r = n[q]; switch (r.type) {
                        case ve: case Ne: g = r.endX; h = r.endY; r.endX = g * a + h * c + e; r.endY = g * b + h * d + f; break; case Oe: g = r.point1X; h = r.point1Y;
                            r.point1X = g * a + h * c + e; r.point1Y = g * b + h * d + f; g = r.point2X; h = r.point2Y; r.point2X = g * a + h * c + e; r.point2Y = g * b + h * d + f; g = r.endX; h = r.endY; r.endX = g * a + h * c + e; r.endY = g * b + h * d + f; break; case Pe: g = r.point1X; h = r.point1Y; r.point1X = g * a + h * c + e; r.point1Y = g * b + h * d + f; g = r.endX; h = r.endY; r.endX = g * a + h * c + e; r.endY = g * b + h * d + f; break; case Qe: g = r.centerX; h = r.centerY; r.centerX = g * a + h * c + e; r.centerY = g * b + h * d + f; 0 !== b && (g = 180 * Math.atan2(b, a) / Math.PI, 0 > g && (g += 360), r.startAngle += g); 0 > a && (r.startAngle = 180 - r.startAngle, r.sweepAngle = -r.sweepAngle); 0 > d &&
                                (r.startAngle = -r.startAngle, r.sweepAngle = -r.sweepAngle); r.radiusX *= Math.sqrt(a * a + c * c); void 0 !== r.radiusY && (r.radiusY *= Math.sqrt(b * b + d * d)); break; case Re: g = r.endX; h = r.endY; r.endX = g * a + h * c + e; r.endY = g * b + h * d + f; 0 !== b && (g = 180 * Math.atan2(b, a) / Math.PI, 0 > g && (g += 360), r.xAxisRotation += g); 0 > a && (r.xAxisRotation = 180 - r.xAxisRotation, r.isClockwiseArc = !r.isClockwiseArc); 0 > d && (r.xAxisRotation = -r.xAxisRotation, r.isClockwiseArc = !r.isClockwiseArc); r.radiusX *= Math.sqrt(a * a + c * c); r.radiusY *= Math.sqrt(b * b + d * d); break; default: v("Unknown Segment type: " +
                                    r.type)
                    }
                }
            }
        }this.ta = !0; return this
    };
    t.ea = function (a, b, c, d) {
        var e = a.x; a = a.y; for (var f = this.bounds.x - 20, g = 0, h, k, l, m, n, p = this.figures.j, q = p.length, r = 0; r < q; r++) {
            var u = p[r]; if (u.isFilled) {
                if (c && u.ea(e, a, b)) return !0; var x = u.segments; h = u.startX; k = u.startY; for (var y = h, A = k, C = x.j, G = 0; G <= x.length; G++) {
                    var H = void 0; if (G !== x.length) { H = C[G]; var O = H.type; m = H.endX; n = H.endY } else O = ve, m = y, n = A; switch (O) {
                        case Ne: y = Ue(e, a, f, a, h, k, y, A); if (isNaN(y)) return !0; g += y; y = m; A = n; break; case ve: h = Ue(e, a, f, a, h, k, m, n); if (isNaN(h)) return !0; g += h; break; case Oe: l = K.Up(h,
                            k, H.point1X, H.point1Y, H.point2X, H.point2Y, m, n, f, a, e, a, .5); g += l; break; case Pe: l = K.Up(h, k, (h + 2 * H.point1X) / 3, (k + 2 * H.point1Y) / 3, (2 * H.point1X + m) / 3, (2 * H.point1Y + n) / 3, m, n, f, a, e, a, .5); g += l; break; case Qe: case Re: O = H.type === Qe ? Se(H, u) : Te(H, u, h, k); var S = O.length; if (0 === S) { h = Ue(e, a, f, a, h, k, H.centerX, H.centerY); if (isNaN(h)) return !0; g += h; break } H = null; for (var T = 0; T < S; T++) { H = O[T]; if (0 === T) { l = Ue(e, a, f, a, h, k, H[0], H[1]); if (isNaN(l)) return !0; g += l } l = K.Up(H[0], H[1], H[2], H[3], H[4], H[5], H[6], H[7], f, a, e, a, .5); g += l } null !==
                                H && (m = H[6], n = H[7]); break; default: v("Unknown Segment type: " + H.type)
                    }h = m; k = n
                } if (0 !== g) return !0; g = 0
            } else if (u.ea(e, a, d ? b : b + 2)) return !0
        } return 0 !== g
    }; function Ue(a, b, c, d, e, f, g, h) { if (K.Vb(e, f, g, h, .05, a, b)) return NaN; var k = (a - c) * (f - h); if (0 === k) return 0; var l = ((a * d - b * c) * (e - g) - (a - c) * (e * h - f * g)) / k; b = (a * d - b * c) * (f - h) / k; if (l >= a) return 0; if ((e > g ? e - g : g - e) < (f > h ? f - h : h - f)) if (f < h) { if (b < f || b > h) return 0 } else { if (b < h || b > f) return 0 } else if (e < g) { if (l < e || l > g) return 0 } else if (l < g || l > e) return 0; return 0 < k ? 1 : -1 }
    function Ve(a, b, c, d) { a = a.figures.j; for (var e = a.length, f = 0; f < e; f++)if (a[f].ea(b, c, d)) return !0; return !1 }
    t.kv = function (a, b) { 0 > a ? a = 0 : 1 < a && (a = 1); void 0 === b && (b = new J); if (this.type === pe) return b.h(this.startX + a * (this.endX - this.startX), this.startY + a * (this.endY - this.startY)), b; for (var c = this.flattenedSegments, d = this.flattenedLengths, e = c.length, f = this.flattenedTotalLength * a, g = 0, h = 0; h < e; h++) { var k = d[h], l = k.length; for (a = 0; a < l; a++) { var m = k[a]; if (g + m >= f) return d = (f - g) / m, c = c[h], e = c[2 * a], h = c[2 * a + 1], b.h(e + (c[2 * a + 2] - e) * d, h + (c[2 * a + 3] - h) * d), b; g += m } } b.h(NaN, NaN); return b };
    t.qx = function (a) {
        if (this.type === pe) { var b = this.startX, c = this.startY, d = this.endX, e = this.endY; if (b !== d || c !== e) { var f = a.x; a = a.y; if (b === d) { if (c < e) { var g = c; d = e } else g = e, d = c; return a <= g ? g === c ? 0 : 1 : a >= d ? d === c ? 0 : 1 : Math.abs(a - c) / (d - g) } return c === e ? (b < d ? g = b : (g = d, d = b), f <= g ? g === b ? 0 : 1 : f >= d ? d === b ? 0 : 1 : Math.abs(f - b) / (d - g)) : ((f - b) * (f - b) + (a - c) * (a - c)) / ((d - b) * (d - b) + (e - c) * (e - c)) } } else if (this.type === xe) {
            g = this.startX; var h = this.startY, k = this.endX; e = this.endY; if (g !== k || h !== e) {
                b = k - g; c = e - h; f = 2 * b + 2 * c; d = a.x; a = a.y; d = Math.min(Math.max(d,
                    g), k); a = Math.min(Math.max(a, h), e); g = Math.abs(d - g); k = Math.abs(d - k); h = Math.abs(a - h); e = Math.abs(a - e); var l = Math.min(g, k, h, e); if (l === h) return d / f; if (l === k) return (b + a) / f; if (l === e) return (2 * b + c - d) / f; if (l === g) return (2 * b + 2 * c - a) / f
            }
        } else {
            b = this.flattenedSegments; c = this.flattenedLengths; f = this.flattenedTotalLength; d = J.alloc(); e = Infinity; h = g = 0; k = b.length; for (var m = l = 0, n = 0; n < k; n++)for (var p = b[n], q = c[n], r = p.length, u = 0; u < r; u += 2) {
                var x = p[u], y = p[u + 1]; if (0 !== u) {
                    K.Vi(l, m, x, y, a.x, a.y, d); var A = (d.x - a.x) * (d.x - a.x) + (d.y -
                        a.y) * (d.y - a.y); A < e && (e = A, g = h, g += Math.sqrt((d.x - l) * (d.x - l) + (d.y - m) * (d.y - m))); h += q[(u - 2) / 2]
                } l = x; m = y
            } J.free(d); a = g / f; return 0 > a ? 0 : 1 < a ? 1 : a
        } return 0
    };
    function We(a) {
        if (null === a.Ck) {
            var b = a.Ck = [], c = a.Rm = [], d = [], e = []; if (a.type === pe) d.push(a.startX), d.push(a.startY), d.push(a.endX), d.push(a.endY), b.push(d), e.push(Math.sqrt((a.startX - a.endX) * (a.startX - a.endX) + (a.startY - a.endY) * (a.startY - a.endY))), c.push(e); else if (a.type === xe) d.push(a.startX), d.push(a.startY), d.push(a.endX), d.push(a.startY), d.push(a.endX), d.push(a.endY), d.push(a.startX), d.push(a.endY), d.push(a.startX), d.push(a.startY), b.push(d), e.push(Math.abs(a.startX - a.endX)), e.push(Math.abs(a.startY -
                a.endY)), e.push(Math.abs(a.startX - a.endX)), e.push(Math.abs(a.startY - a.endY)), c.push(e); else if (a.type === ye) {
                    var f = new Xe; f.startX = a.endX; f.startY = (a.startY + a.endY) / 2; var g = new Ye(Qe); g.startAngle = 0; g.sweepAngle = 360; g.centerX = (a.startX + a.endX) / 2; g.centerY = (a.startY + a.endY) / 2; g.radiusX = Math.abs(a.startX - a.endX) / 2; g.radiusY = Math.abs(a.startY - a.endY) / 2; f.add(g); a = Se(g, f); e = a.length; if (0 === e) d.push(g.centerX), d.push(g.centerY); else {
                        g = f.startX; f = f.startY; for (var h = 0; h < e; h++) {
                            var k = a[h]; K.Ce(g, f, k[2], k[3],
                                k[4], k[5], k[6], k[7], .5, d); g = k[6]; f = k[7]
                        }
                    } b.push(d); c.push(jf(d))
                } else for (a = a.figures.iterator; a.next();) {
                    e = a.value; d = []; d.push(e.startX); d.push(e.startY); g = e.startX; f = e.startY; h = g; k = f; for (var l = e.segments.j, m = l.length, n = 0; n < m; n++) {
                        var p = l[n]; switch (p.type) {
                            case Ne: 4 <= d.length && (b.push(d), c.push(jf(d))); d = []; d.push(p.endX); d.push(p.endY); g = p.endX; f = p.endY; h = g; k = f; break; case ve: d.push(p.endX); d.push(p.endY); g = p.endX; f = p.endY; break; case Oe: K.Ce(g, f, p.point1X, p.point1Y, p.point2X, p.point2Y, p.endX, p.endY,
                                .5, d); g = p.endX; f = p.endY; break; case Pe: K.tq(g, f, p.point1X, p.point1Y, p.endX, p.endY, .5, d); g = p.endX; f = p.endY; break; case Qe: var q = Se(p, e), r = q.length; if (0 === r) { d.push(p.centerX); d.push(p.centerY); g = p.centerX; f = p.centerY; break } for (var u = 0; u < r; u++) { var x = q[u]; K.Ce(g, f, x[2], x[3], x[4], x[5], x[6], x[7], .5, d); g = x[6]; f = x[7] } break; case Re: q = Te(p, e, g, f); r = q.length; if (0 === r) { d.push(p.centerX); d.push(p.centerY); g = p.centerX; f = p.centerY; break } for (u = 0; u < r; u++)x = q[u], K.Ce(g, f, x[2], x[3], x[4], x[5], x[6], x[7], .5, d), g = x[6],
                                    f = x[7]; break; default: v("Segment not of valid type: " + p.type)
                        }p.isClosed && (d.push(h), d.push(k))
                    } 4 <= d.length && (b.push(d), c.push(jf(d)))
                }
        }
    } function jf(a) { for (var b = [], c = 0, d = 0, e = a.length, f = 0; f < e; f += 2) { var g = a[f], h = a[f + 1]; 0 !== f && (c = Math.sqrt(dc(c, d, g, h)), b.push(c)); c = g; d = h } return b } t.add = function (a) { this.kj.add(a); return this }; t.Cm = function (a, b, c, d, e, f, g, h) { this.u && ya(this); this.ef = (new M(a, b, e, f)).freeze(); this.ff = (new M(c, d, g, h)).freeze(); return this };
    na.Object.defineProperties(me.prototype, {
        flattenedSegments: { configurable: !0, get: function () { We(this); return this.Ck } }, flattenedLengths: { configurable: !0, get: function () { We(this); return this.Rm } }, flattenedTotalLength: {
            configurable: !0, get: function () {
                var a = this.Sm; if (isNaN(a)) {
                    if (this.type === pe) { a = Math.abs(this.endX - this.startX); var b = Math.abs(this.endY - this.startY); a = Math.sqrt(a * a + b * b) } else if (this.type === xe) a = 2 * Math.abs(this.endX - this.startX) + 2 * Math.abs(this.endY -
                        this.startY); else { b = this.flattenedLengths; for (var c = b.length, d = a = 0; d < c; d++)for (var e = b[d], f = e.length, g = 0; g < f; g++)a += e[g] } this.Sm = a
                } return a
            }
        }, type: { configurable: !0, get: function () { return this.wa }, set: function (a) { this.wa !== a && (E && tb(a, me, me, "type"), this.u && ya(this, a), this.wa = a, this.ta = !0) } }, startX: { configurable: !0, get: function () { return this.cd }, set: function (a) { this.cd !== a && (E && B(a, me, "startX"), this.u && ya(this, a), this.cd = a, this.ta = !0) } }, startY: {
            configurable: !0,
            get: function () { return this.dd }, set: function (a) { this.dd !== a && (E && B(a, me, "startY"), this.u && ya(this, a), this.dd = a, this.ta = !0) }
        }, endX: { configurable: !0, get: function () { return this.nc }, set: function (a) { this.nc !== a && (E && B(a, me, "endX"), this.u && ya(this, a), this.nc = a, this.ta = !0) } }, endY: { configurable: !0, get: function () { return this.Dc }, set: function (a) { this.Dc !== a && (E && B(a, me, "endY"), this.u && ya(this, a), this.Dc = a, this.ta = !0) } }, figures: {
            configurable: !0, get: function () { return this.kj },
            set: function (a) { this.kj !== a && (E && w(a, F, me, "figures"), this.u && ya(this, a), this.kj = a, this.ta = !0) }
        }, spot1: { configurable: !0, get: function () { return this.ef }, set: function (a) { E && w(a, M, me, "spot1"); this.u && ya(this, a); this.ef = a.J() } }, spot2: { configurable: !0, get: function () { return this.ff }, set: function (a) { E && w(a, M, me, "spot2"); this.u && ya(this, a); this.ff = a.J() } }, defaultStretch: {
            configurable: !0, get: function () { return this.Gf }, set: function (a) {
                E && tb(a, N, me, "stretch"); this.u &&
                    ya(this, a); this.Gf = a
            }
        }, bounds: { configurable: !0, get: function () { this.sv() && this.computeBounds(); return this.br } }
    }); me.prototype.setSpots = me.prototype.Cm; me.prototype.add = me.prototype.add; me.prototype.getFractionForPoint = me.prototype.qx; me.prototype.getPointAlongPath = me.prototype.kv; me.prototype.transform = me.prototype.transform; me.prototype.rotate = me.prototype.rotate; me.prototype.scale = me.prototype.scale; me.prototype.offset = me.prototype.offset; me.prototype.normalize = me.prototype.normalize;
    me.prototype.computeBoundsWithoutOrigin = me.prototype.gx; me.prototype.equalsApprox = me.prototype.Sa; var pe = new D(me, "Line", 0), xe = new D(me, "Rectangle", 1), ye = new D(me, "Ellipse", 2), ne = new D(me, "Path", 3); me.className = "Geometry"; me.stringify = we; me.fillPath = function (a) { "string" !== typeof a && Ba(a, "string", me, "fillPath:str"); a = a.split(/[Xx]/); for (var b = a.length, c = "", d = 0; d < b; d++) { var e = a[d]; c = null !== e.match(/[Ff]/) ? 0 === d ? c + e : c + ("X" + (" " === e[0] ? "" : " ") + e) : c + ((0 === d ? "" : "X ") + "F" + (" " === e[0] ? "" : " ") + e) } return c };
    me.parse = ze; me.Line = pe; me.Rectangle = xe; me.Ellipse = ye; me.Path = ne; function Xe(a, b, c, d) { qb(this); this.u = !1; void 0 === c && (c = !0); this.Ir = c; void 0 === d && (d = !0); this.Mr = d; void 0 !== a ? (E && B(a, Xe, "sx"), this.cd = a) : this.cd = 0; void 0 !== b ? (E && B(b, Xe, "sy"), this.dd = b) : this.dd = 0; this.Fl = new F; this.zs = this.Fl.s; this.ta = !0 }
    Xe.prototype.copy = function () { var a = new Xe; a.Ir = this.Ir; a.Mr = this.Mr; a.cd = this.cd; a.dd = this.dd; for (var b = this.Fl.j, c = b.length, d = a.Fl, e = 0; e < c; e++) { var f = b[e].copy(); d.add(f) } a.zs = this.zs; a.ta = this.ta; return a }; t = Xe.prototype; t.Sa = function (a) { if (!(a instanceof Xe && K.B(this.startX, a.startX) && K.B(this.startY, a.startY))) return !1; var b = this.segments.j; a = a.segments.j; var c = b.length; if (c !== a.length) return !1; for (var d = 0; d < c; d++)if (!b[d].Sa(a[d])) return !1; return !0 };
    t.toString = function (a) { void 0 === a && (a = -1); var b = 0 > a ? "M" + this.startX.toString() + " " + this.startY.toString() : "M" + this.startX.toFixed(a) + " " + this.startY.toFixed(a); for (var c = this.segments.j, d = c.length, e = 0; e < d; e++)b += " " + c[e].toString(a); return b }; t.freeze = function () { this.u = !0; var a = this.segments; a.freeze(); var b = a.j; a = a.length; for (var c = 0; c < a; c++)b[c].freeze(); return this }; t.ja = function () { this.u = !1; var a = this.segments; a.ja(); a = a.j; for (var b = a.length, c = 0; c < b; c++)a[c].ja(); return this };
    t.sv = function () { if (this.ta) return !0; var a = this.segments; if (this.zs !== a.s) return !0; a = a.j; for (var b = a.length, c = 0; c < b; c++)if (a[c].ta) return !0; return !1 }; t.add = function (a) { this.Fl.add(a); return this };
    t.ea = function (a, b, c) {
        for (var d = this.startX, e = this.startY, f = d, g = e, h = this.segments.j, k = h.length, l = 0; l < k; l++) {
            var m = h[l]; switch (m.type) {
                case Ne: f = m.endX; g = m.endY; d = m.endX; e = m.endY; break; case ve: if (K.Vb(d, e, m.endX, m.endY, c, a, b)) return !0; d = m.endX; e = m.endY; break; case Oe: if (K.Ps(d, e, m.point1X, m.point1Y, m.point2X, m.point2Y, m.endX, m.endY, .5, a, b, c)) return !0; d = m.endX; e = m.endY; break; case Pe: if (K.Bv(d, e, m.point1X, m.point1Y, m.endX, m.endY, .5, a, b, c)) return !0; d = m.endX; e = m.endY; break; case Qe: case Re: var n = m.type ===
                    Qe ? Se(m, this) : Te(m, this, d, e), p = n.length; if (0 === p) { if (K.Vb(d, e, m.centerX, m.centerY, c, a, b)) return !0; d = m.centerX; e = m.centerY; break } for (var q = null, r = 0; r < p; r++)if (q = n[r], 0 === r && K.Vb(d, e, q[0], q[1], c, a, b) || K.Ps(q[0], q[1], q[2], q[3], q[4], q[5], q[6], q[7], .5, a, b, c)) return !0; null !== q && (d = q[6], e = q[7]); break; default: v("Unknown Segment type: " + m.type)
            }if (m.isClosed && (d !== f || e !== g) && K.Vb(d, e, f, g, c, a, b)) return !0
        } return !1
    };
    na.Object.defineProperties(Xe.prototype, {
        isFilled: { configurable: !0, get: function () { return this.Ir }, set: function (a) { E && z(a, "boolean", Xe, "isFilled"); this.u && ya(this, a); this.Ir = a } }, isShadowed: { configurable: !0, get: function () { return this.Mr }, set: function (a) { E && z(a, "boolean", Xe, "isShadowed"); this.u && ya(this, a); this.Mr = a } }, startX: { configurable: !0, get: function () { return this.cd }, set: function (a) { E && B(a, Xe, "startX"); this.u && ya(this, a); this.cd = a; this.ta = !0 } }, startY: {
            configurable: !0,
            enumerable: !0, get: function () { return this.dd }, set: function (a) { E && B(a, Xe, "startY"); this.u && ya(this, a); this.dd = a; this.ta = !0 }
        }, segments: { configurable: !0, get: function () { return this.Fl }, set: function (a) { E && w(a, F, Xe, "segments"); this.u && ya(this, a); this.Fl = a; this.ta = !0 } }
    }); Xe.prototype.add = Xe.prototype.add; Xe.prototype.equalsApprox = Xe.prototype.Sa; Xe.className = "PathFigure";
    function Ye(a, b, c, d, e, f, g, h) {
        qb(this); this.u = !1; void 0 === a ? a = ve : E && tb(a, Ye, Ye, "constructor:type"); this.wa = a; void 0 !== b ? (E && B(b, Ye, "ex"), this.nc = b) : this.nc = 0; void 0 !== c ? (E && B(c, Ye, "ey"), this.Dc = c) : this.Dc = 0; void 0 === d && (d = 0); void 0 === e && (e = 0); void 0 === f && (f = 0); void 0 === g && (g = 0); a === Re ? (a = f % 360, 0 > a && (a += 360), this.we = a, this.pi = 0, E && B(d, Ye, "x1"), this.ri = Math.max(d, 0), E && B(e, Ye, "y1"), this.$g = Math.max(e, 0), this.ml = "boolean" === typeof g ? !!g : !1, this.Ik = !!h) : (E && B(d, Ye, "x1"), this.we = d, E && B(e, Ye, "y1"), this.pi =
            e, E && B(f, Ye, "x2"), a === Qe && (f = Math.max(f, 0)), this.ri = f, "number" === typeof g ? (a === Qe && (g = Math.max(g, 0)), this.$g = g) : this.$g = 0, this.Ik = this.ml = !1); this.pj = !1; this.ta = !0; this.Me = null
    } Ye.prototype.copy = function () { var a = new Ye; a.wa = this.wa; a.nc = this.nc; a.Dc = this.Dc; a.we = this.we; a.pi = this.pi; a.ri = this.ri; a.$g = this.$g; a.ml = this.ml; a.Ik = this.Ik; a.pj = this.pj; a.ta = this.ta; return a }; t = Ye.prototype;
    t.Sa = function (a) {
        if (!(a instanceof Ye) || this.type !== a.type || this.isClosed !== a.isClosed) return !1; switch (this.type) {
            case Ne: case ve: return K.B(this.endX, a.endX) && K.B(this.endY, a.endY); case Oe: return K.B(this.endX, a.endX) && K.B(this.endY, a.endY) && K.B(this.point1X, a.point1X) && K.B(this.point1Y, a.point1Y) && K.B(this.point2X, a.point2X) && K.B(this.point2Y, a.point2Y); case Pe: return K.B(this.endX, a.endX) && K.B(this.endY, a.endY) && K.B(this.point1X, a.point1X) && K.B(this.point1Y, a.point1Y); case Qe: return K.B(this.startAngle,
                a.startAngle) && K.B(this.sweepAngle, a.sweepAngle) && K.B(this.centerX, a.centerX) && K.B(this.centerY, a.centerY) && K.B(this.radiusX, a.radiusX) && K.B(this.radiusY, a.radiusY); case Re: return this.isClockwiseArc === a.isClockwiseArc && this.isLargeArc === a.isLargeArc && K.B(this.xAxisRotation, a.xAxisRotation) && K.B(this.endX, a.endX) && K.B(this.endY, a.endY) && K.B(this.radiusX, a.radiusX) && K.B(this.radiusY, a.radiusY); default: return !1
        }
    }; t.hb = function (a) { a.classType === Ye ? this.type = a : Fa(this, a) };
    t.toString = function (a) {
    void 0 === a && (a = -1); switch (this.type) {
        case Ne: a = 0 > a ? "M" + this.endX.toString() + " " + this.endY.toString() : "M" + this.endX.toFixed(a) + " " + this.endY.toFixed(a); break; case ve: a = 0 > a ? "L" + this.endX.toString() + " " + this.endY.toString() : "L" + this.endX.toFixed(a) + " " + this.endY.toFixed(a); break; case Oe: a = 0 > a ? "C" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.point2X.toString() + " " + this.point2Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : "C" + this.point1X.toFixed(a) +
            " " + this.point1Y.toFixed(a) + " " + this.point2X.toFixed(a) + " " + this.point2Y.toFixed(a) + " " + this.endX.toFixed(a) + " " + this.endY.toFixed(a); break; case Pe: a = 0 > a ? "Q" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : "Q" + this.point1X.toFixed(a) + " " + this.point1Y.toFixed(a) + " " + this.endX.toFixed(a) + " " + this.endY.toFixed(a); break; case Qe: a = 0 > a ? "B" + this.startAngle.toString() + " " + this.sweepAngle.toString() + " " + this.centerX.toString() + " " + this.centerY.toString() +
                " " + this.radiusX.toString() + " " + this.radiusY.toString() : "B" + this.startAngle.toFixed(a) + " " + this.sweepAngle.toFixed(a) + " " + this.centerX.toFixed(a) + " " + this.centerY.toFixed(a) + " " + this.radiusX.toFixed(a) + " " + this.radiusY.toFixed(a); break; case Re: a = 0 > a ? "A" + this.radiusX.toString() + " " + this.radiusY.toString() + " " + this.xAxisRotation.toString() + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + this.endX.toString() + " " + this.endY.toString() : "A" + this.radiusX.toFixed(a) + " " + this.radiusY.toFixed(a) +
                    " " + this.xAxisRotation.toFixed(a) + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + this.endX.toFixed(a) + " " + this.endY.toFixed(a); break; default: a = this.type.toString()
    }return a + (this.pj ? "z" : "")
    }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { this.u = !1; return this }; t.close = function () { this.pj = !0; return this };
    function Se(a, b) { if (null !== a.Me && !1 === b.ta) return a.Me; var c = a.radiusX, d = a.radiusY; void 0 === d && (d = c); if (0 === c || 0 === d) return a.Me = [], a.Me; b = a.we; var e = a.pi, f = K.hx(0, 0, c < d ? c : d, a.startAngle, a.startAngle + a.sweepAngle, !1); if (c !== d) { var g = $b.alloc(); g.reset(); c < d ? g.scale(1, d / c) : g.scale(c / d, 1); Le(f, g); $b.free(g) } c = f.length; for (d = 0; d < c; d++)g = f[d], g[0] += b, g[1] += e, g[2] += b, g[3] += e, g[4] += b, g[5] += e, g[6] += b, g[7] += e; a.Me = f; return a.Me }
    function Te(a, b, c, d) {
        function e(a, b, c, d) { return (a * d < b * c ? -1 : 1) * Math.acos((a * c + b * d) / (Math.sqrt(a * a + b * b) * Math.sqrt(c * c + d * d))) } if (null !== a.Me && !1 === b.ta) return a.Me; b = a.ri; var f = a.$g; 0 === b && (b = 1E-4); 0 === f && (f = 1E-4); var g = Math.PI / 180 * a.we, h = a.ml, k = a.Ik, l = a.nc, m = a.Dc, n = Math.cos(g), p = Math.sin(g), q = n * (c - l) / 2 + p * (d - m) / 2; g = -p * (c - l) / 2 + n * (d - m) / 2; var r = q * q / (b * b) + g * g / (f * f); 1 < r && (b *= Math.sqrt(r), f *= Math.sqrt(r)); r = (h === k ? -1 : 1) * Math.sqrt((b * b * f * f - b * b * g * g - f * f * q * q) / (b * b * g * g + f * f * q * q)); isNaN(r) && (r = 0); h = r * b * g / f; r = r * -f *
            q / b; isNaN(h) && (h = 0); isNaN(r) && (r = 0); c = (c + l) / 2 + n * h - p * r; d = (d + m) / 2 + p * h + n * r; m = e(1, 0, (q - h) / b, (g - r) / f); n = (q - h) / b; l = (g - r) / f; q = (-q - h) / b; h = (-g - r) / f; g = e(n, l, q, h); q = (n * q + l * h) / (Math.sqrt(n * n + l * l) * Math.sqrt(q * q + h * h)); -1 >= q ? g = Math.PI : 1 <= q && (g = 0); !k && 0 < g && (g -= 2 * Math.PI); k && 0 > g && (g += 2 * Math.PI); k = b > f ? 1 : b / f; q = b > f ? f / b : 1; b = K.hx(0, 0, b > f ? b : f, m, m + g, !0); f = $b.alloc(); f.reset(); f.translate(c, d); f.rotate(a.we, 0, 0); f.scale(k, q); Le(b, f); $b.free(f); a.Me = b; return a.Me
    }
    na.Object.defineProperties(Ye.prototype, {
        isClosed: { configurable: !0, get: function () { return this.pj }, set: function (a) { this.pj !== a && (this.pj = a, this.ta = !0) } }, type: { configurable: !0, get: function () { return this.wa }, set: function (a) { E && tb(a, Ye, Ye, "type"); this.u && ya(this, a); this.wa = a; this.ta = !0 } }, endX: { configurable: !0, get: function () { return this.nc }, set: function (a) { E && B(a, Ye, "endX"); this.u && ya(this, a); this.nc = a; this.ta = !0 } }, endY: {
            configurable: !0, get: function () { return this.Dc },
            set: function (a) { E && B(a, Ye, "endY"); this.u && ya(this, a); this.Dc = a; this.ta = !0 }
        }, point1X: { configurable: !0, get: function () { return this.we }, set: function (a) { E && B(a, Ye, "point1X"); this.u && ya(this, a); this.we = a; this.ta = !0 } }, point1Y: { configurable: !0, get: function () { return this.pi }, set: function (a) { E && B(a, Ye, "point1Y"); this.u && ya(this, a); this.pi = a; this.ta = !0 } }, point2X: {
            configurable: !0, get: function () { return this.ri }, set: function (a) {
                E && B(a, Ye, "point2X"); this.u && ya(this, a); this.ri =
                    a; this.ta = !0
            }
        }, point2Y: { configurable: !0, get: function () { return this.$g }, set: function (a) { E && B(a, Ye, "point2Y"); this.u && ya(this, a); this.$g = a; this.ta = !0 } }, centerX: { configurable: !0, get: function () { return this.we }, set: function (a) { E && B(a, Ye, "centerX"); this.u && ya(this, a); this.we = a; this.ta = !0 } }, centerY: { configurable: !0, get: function () { return this.pi }, set: function (a) { E && B(a, Ye, "centerY"); this.u && ya(this, a); this.pi = a; this.ta = !0 } }, radiusX: {
            configurable: !0,
            get: function () { return this.ri }, set: function (a) { E && B(a, Ye, "radiusX"); 0 > a && Ca(a, ">= zero", Ye, "radiusX"); this.u && ya(this, a); this.ri = a; this.ta = !0 }
        }, radiusY: { configurable: !0, get: function () { return this.$g }, set: function (a) { E && B(a, Ye, "radiusY"); 0 > a && Ca(a, ">= zero", Ye, "radiusY"); this.u && ya(this, a); this.$g = a; this.ta = !0 } }, startAngle: {
            configurable: !0, get: function () { return this.nc }, set: function (a) {
            this.nc !== a && (this.u && ya(this, a), E && B(a, Ye, "startAngle"), a %= 360, 0 > a && (a += 360), this.nc =
                a, this.ta = !0)
            }
        }, sweepAngle: { configurable: !0, get: function () { return this.Dc }, set: function (a) { E && B(a, Ye, "sweepAngle"); this.u && ya(this, a); 360 < a && (a = 360); -360 > a && (a = -360); this.Dc = a; this.ta = !0 } }, isClockwiseArc: { configurable: !0, get: function () { return this.Ik }, set: function (a) { this.u && ya(this, a); this.Ik = a; this.ta = !0 } }, isLargeArc: { configurable: !0, get: function () { return this.ml }, set: function (a) { this.u && ya(this, a); this.ml = a; this.ta = !0 } }, xAxisRotation: {
            configurable: !0,
            get: function () { return this.we }, set: function (a) { E && B(a, Ye, "xAxisRotation"); a %= 360; 0 > a && (a += 360); this.u && ya(this, a); this.we = a; this.ta = !0 }
        }
    }); Ye.prototype.equalsApprox = Ye.prototype.Sa; var Ne = new D(Ye, "Move", 0), ve = new D(Ye, "Line", 1), Oe = new D(Ye, "Bezier", 2), Pe = new D(Ye, "QuadraticBezier", 3), Qe = new D(Ye, "Arc", 4), Re = new D(Ye, "SvgArc", 4); Ye.className = "PathSegment"; Ye.Move = Ne; Ye.Line = ve; Ye.Bezier = Oe; Ye.QuadraticBezier = Pe; Ye.Arc = Qe; Ye.SvgArc = Re;
    function kf() { this.D = null; this.Hu = (new J(0, 0)).freeze(); this.Yt = (new J(0, 0)).freeze(); this.Vq = this.bs = 0; this.Wq = 1; this.Qr = ""; this.Ks = this.mr = !1; this.lr = this.Yq = 0; this.Dg = this.zr = this.Kr = !1; this.tr = null; this.Is = 0; this.Sd = this.Hs = null } kf.prototype.copy = function () { var a = new kf; return this.clone(a) };
    kf.prototype.clone = function (a) { a.D = this.D; a.Hu.assign(this.viewPoint); a.Yt.assign(this.documentPoint); a.bs = this.bs; a.Vq = this.Vq; a.Wq = this.Wq; a.Qr = this.Qr; a.mr = this.mr; a.Ks = this.Ks; a.Yq = this.Yq; a.lr = this.lr; a.Kr = this.Kr; a.zr = this.zr; a.Dg = this.Dg; a.tr = this.tr; a.Is = this.Is; a.Hs = this.Hs; a.Sd = this.Sd; return a };
    kf.prototype.toString = function () { var a = "^"; 0 !== this.modifiers && (a += "M:" + this.modifiers); 0 !== this.button && (a += "B:" + this.button); "" !== this.key && (a += "K:" + this.key); 0 !== this.clickCount && (a += "C:" + this.clickCount); 0 !== this.delta && (a += "D:" + this.delta); this.handled && (a += "h"); this.bubbles && (a += "b"); null !== this.documentPoint && (a += "@" + this.documentPoint.toString()); return a }; kf.prototype.fq = function (a, b) { var c = this.diagram; if (null === c) return b; lf(c, this.event, a, b); return b };
    kf.prototype.mz = function (a, b) { var c = this.diagram; if (null === c) return b; lf(c, this.event, a, b); b.assign(c.Dt(b)); return b };
    na.Object.defineProperties(kf.prototype, {
        diagram: { configurable: !0, get: function () { return this.D }, set: function (a) { this.D = a } }, viewPoint: { configurable: !0, get: function () { return this.Hu }, set: function (a) { w(a, J, kf, "viewPoint"); this.Hu.assign(a) } }, documentPoint: { configurable: !0, get: function () { return this.Yt }, set: function (a) { w(a, J, kf, "documentPoint"); this.Yt.assign(a) } }, modifiers: {
            configurable: !0, get: function () { return this.bs }, set: function (a) {
            this.bs =
                a
            }
        }, button: { configurable: !0, get: function () { return this.Vq }, set: function (a) { this.Vq = a; if (null === this.event) switch (a) { case 0: this.buttons = 1; break; case 1: this.buttons = 4; break; case 2: this.buttons = 2 } } }, buttons: { configurable: !0, get: function () { return this.Wq }, set: function (a) { this.Wq = a } }, key: { configurable: !0, get: function () { return this.Qr }, set: function (a) { this.Qr = a } }, down: { configurable: !0, get: function () { return this.mr }, set: function (a) { this.mr = a } }, up: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Ks }, set: function (a) { this.Ks = a }
        }, clickCount: { configurable: !0, get: function () { return this.Yq }, set: function (a) { this.Yq = a } }, delta: { configurable: !0, get: function () { return this.lr }, set: function (a) { this.lr = a } }, isMultiTouch: { configurable: !0, get: function () { return this.Kr }, set: function (a) { this.Kr = a } }, handled: { configurable: !0, get: function () { return this.zr }, set: function (a) { this.zr = a } }, bubbles: {
            configurable: !0,
            get: function () { return this.Dg }, set: function (a) { this.Dg = a }
        }, event: { configurable: !0, get: function () { return this.tr }, set: function (a) { this.tr = a } }, isTouchEvent: { configurable: !0, get: function () { var a = qa.TouchEvent, b = this.event; return a && b instanceof a ? !0 : (a = qa.PointerEvent) && b instanceof a && ("touch" === b.pointerType || "pen" === b.pointerType) } }, timestamp: { configurable: !0, get: function () { return this.Is }, set: function (a) { this.Is = a } }, targetDiagram: {
            configurable: !0,
            get: function () { return this.Hs }, set: function (a) { this.Hs = a }
        }, targetObject: { configurable: !0, get: function () { return this.Sd }, set: function (a) { this.Sd = a } }, control: { configurable: !0, get: function () { return 0 !== (this.modifiers & 1) }, set: function (a) { this.modifiers = a ? this.modifiers | 1 : this.modifiers & -2 } }, shift: { configurable: !0, get: function () { return 0 !== (this.modifiers & 4) }, set: function (a) { this.modifiers = a ? this.modifiers | 4 : this.modifiers & -5 } }, alt: {
            configurable: !0,
            get: function () { return 0 !== (this.modifiers & 2) }, set: function (a) { this.modifiers = a ? this.modifiers | 2 : this.modifiers & -3 }
        }, meta: { configurable: !0, get: function () { return 0 !== (this.modifiers & 8) }, set: function (a) { this.modifiers = a ? this.modifiers | 8 : this.modifiers & -9 } }, left: {
            configurable: !0, get: function () { var a = this.event; return null === a || "mousedown" !== a.type && "mouseup" !== a.type && "pointerdown" !== a.type && "pointerup" !== a.type ? 0 !== (this.buttons & 1) : 0 === this.button }, set: function (a) {
            this.buttons =
                a ? this.buttons | 1 : this.buttons & -2
            }
        }, right: { configurable: !0, get: function () { var a = this.event; return null === a || "mousedown" !== a.type && "mouseup" !== a.type && "pointerdown" !== a.type && "pointerup" !== a.type ? 0 !== (this.buttons & 2) : 2 === this.button }, set: function (a) { this.buttons = a ? this.buttons | 2 : this.buttons & -3 } }, middle: {
            configurable: !0, get: function () {
                var a = this.event; return null === a || "mousedown" !== a.type && "mouseup" !== a.type && "pointerdown" !== a.type && "pointerup" !== a.type ? 0 !== (this.buttons &
                    4) : 1 === this.button
            }, set: function (a) { this.buttons = a ? this.buttons | 4 : this.buttons & -5 }
        }
    }); kf.prototype.getMultiTouchDocumentPoint = kf.prototype.mz; kf.prototype.getMultiTouchViewPoint = kf.prototype.fq; kf.className = "InputEvent"; function mf() { this.D = null; this.Wa = ""; this.ms = this.Fs = null } mf.prototype.copy = function () { var a = new mf; a.D = this.D; a.Wa = this.Wa; a.Fs = this.Fs; a.ms = this.ms; return a };
    mf.prototype.toString = function () { var a = "*" + this.name; null !== this.subject && (a += ":" + this.subject.toString()); null !== this.parameter && (a += "(" + this.parameter.toString() + ")"); return a };
    na.Object.defineProperties(mf.prototype, { diagram: { configurable: !0, get: function () { return this.D }, set: function (a) { this.D = a } }, name: { configurable: !0, get: function () { return this.Wa }, set: function (a) { this.Wa = a } }, subject: { configurable: !0, get: function () { return this.Fs }, set: function (a) { this.Fs = a } }, parameter: { configurable: !0, get: function () { return this.ms }, set: function (a) { this.ms = a } } }); mf.className = "DiagramEvent";
    function nf() { this.$m = of; this.Hj = this.$r = ""; this.Go = this.Ho = this.Mo = this.No = this.Lo = this.D = this.ac = null } nf.prototype.clear = function () { this.Go = this.Ho = this.Mo = this.No = this.Lo = this.D = this.ac = null };
    nf.prototype.copy = function () { var a = new nf; a.$m = this.$m; a.$r = this.$r; a.Hj = this.Hj; a.ac = this.ac; a.D = this.D; a.Lo = this.Lo; var b = this.No; a.No = Ia(b) && "function" === typeof b.J ? b.J() : b; b = this.Mo; a.Mo = Ia(b) && "function" === typeof b.J ? b.J() : b; b = this.Ho; a.Ho = Ia(b) && "function" === typeof b.J ? b.J() : b; b = this.Go; a.Go = Ia(b) && "function" === typeof b.J ? b.J() : b; return a }; nf.prototype.hb = function (a) { a.classType === nf ? this.change = a : Fa(this, a) };
    nf.prototype.toString = function () {
        var a = ""; a = this.change === pf ? a + "* " : this.change === of ? a + (null !== this.model ? "!m" : "!d") : a + ((null !== this.model ? "!m" : "!d") + this.change); this.propertyName && "string" === typeof this.propertyName && (a += " " + this.propertyName); this.modelChange && this.modelChange !== this.propertyName && (a += " " + this.modelChange); a += ": "; this.change === pf ? null !== this.oldValue && (a += " " + this.oldValue) : (null !== this.object && (a += Wa(this.object)), null !== this.oldValue && (a += "  old: " + Wa(this.oldValue)), null !==
            this.oldParam && (a += " " + this.oldParam), null !== this.newValue && (a += "  new: " + Wa(this.newValue)), null !== this.newParam && (a += " " + this.newParam)); return a
    }; nf.prototype.K = function (a) { return a ? this.oldValue : this.newValue }; nf.prototype.oz = function (a) { return a ? this.oldParam : this.newParam }; nf.prototype.canUndo = function () { return null !== this.model || null !== this.diagram ? !0 : !1 }; nf.prototype.undo = function () { this.canUndo() && (null !== this.model ? this.model.Vj(this, !0) : null !== this.diagram && this.diagram.Vj(this, !0)) };
    nf.prototype.canRedo = function () { return null !== this.model || null !== this.diagram ? !0 : !1 }; nf.prototype.redo = function () { this.canRedo() && (null !== this.model ? this.model.Vj(this, !1) : null !== this.diagram && this.diagram.Vj(this, !1)) };
    na.Object.defineProperties(nf.prototype, {
        model: { configurable: !0, get: function () { return this.ac }, set: function (a) { this.ac = a } }, diagram: { configurable: !0, get: function () { return this.D }, set: function (a) { this.D = a } }, change: { configurable: !0, get: function () { return this.$m }, set: function (a) { E && tb(a, nf, nf, "change"); this.$m = a } }, modelChange: { configurable: !0, get: function () { return this.$r }, set: function (a) { E && z(a, "string", nf, "modelChange"); this.$r = a } }, propertyName: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Hj }, set: function (a) { E && "string" !== typeof a && z(a, "function", nf, "propertyName"); this.Hj = a }
        }, isTransactionFinished: { configurable: !0, get: function () { return this.$m === pf && ("CommittedTransaction" === this.Hj || "FinishedUndo" === this.Hj || "FinishedRedo" === this.Hj) } }, object: { configurable: !0, get: function () { return this.Lo }, set: function (a) { this.Lo = a } }, oldValue: {
            configurable: !0, get: function () { return this.No }, set: function (a) {
            this.No =
                a
            }
        }, oldParam: { configurable: !0, get: function () { return this.Mo }, set: function (a) { this.Mo = a } }, newValue: { configurable: !0, get: function () { return this.Ho }, set: function (a) { this.Ho = a } }, newParam: { configurable: !0, get: function () { return this.Go }, set: function (a) { this.Go = a } }
    }); nf.prototype.redo = nf.prototype.redo; nf.prototype.canRedo = nf.prototype.canRedo; nf.prototype.undo = nf.prototype.undo; nf.prototype.canUndo = nf.prototype.canUndo; nf.prototype.getParam = nf.prototype.oz;
    nf.prototype.getValue = nf.prototype.K; nf.prototype.clear = nf.prototype.clear; var pf = new D(nf, "Transaction", -1), of = new D(nf, "Property", 0), qf = new D(nf, "Insert", 1), rf = new D(nf, "Remove", 2); nf.className = "ChangedEvent"; nf.Transaction = pf; nf.Property = of; nf.Insert = qf; nf.Remove = rf; function sf() { this.w = (new F).freeze(); this.Wa = ""; this.l = !1 }
    sf.prototype.toString = function (a) { var b = "Transaction: " + this.name + " " + this.changes.count.toString() + (this.isComplete ? "" : ", incomplete"); if (void 0 !== a && 0 < a) { a = this.changes.count; for (var c = 0; c < a; c++) { var d = this.changes.O(c); null !== d && (b += "\n  " + d.toString()) } } return b }; sf.prototype.clear = function () { var a = this.changes; a.ja(); for (var b = a.count - 1; 0 <= b; b--) { var c = a.O(b); null !== c && c.clear() } a.clear(); a.freeze() }; sf.prototype.canUndo = function () { return this.isComplete };
    sf.prototype.undo = function () { if (this.canUndo()) for (var a = this.changes.count - 1; 0 <= a; a--) { var b = this.changes.O(a); null !== b && b.undo() } }; sf.prototype.canRedo = function () { return this.isComplete }; sf.prototype.redo = function () { if (this.canRedo()) for (var a = this.changes.count, b = 0; b < a; b++) { var c = this.changes.O(b); null !== c && c.redo() } };
    na.Object.defineProperties(sf.prototype, { changes: { configurable: !0, get: function () { return this.w } }, name: { configurable: !0, get: function () { return this.Wa }, set: function (a) { this.Wa = a } }, isComplete: { configurable: !0, get: function () { return this.l }, set: function (a) { this.l = a } } }); sf.prototype.redo = sf.prototype.redo; sf.prototype.canRedo = sf.prototype.canRedo; sf.prototype.undo = sf.prototype.undo; sf.prototype.canUndo = sf.prototype.canUndo; sf.prototype.clear = sf.prototype.clear;
    sf.className = "Transaction"; function tf() { this.ou = new I; this.Fc = !1; this.L = (new F).freeze(); this.ie = -1; this.w = 999; this.ke = !1; this.jr = null; this.Bi = 0; this.l = !1; E && (this.l = !0); this.te = (new F).freeze(); this.wl = new F; this.eu = !0; this.iu = !1 }
    tf.prototype.toString = function (a) { var b = "UndoManager " + this.historyIndex + "<" + this.history.count + "<=" + this.maxHistoryLength; b += "["; for (var c = this.nestedTransactionNames.count, d = 0; d < c; d++)0 < d && (b += " "), b += this.nestedTransactionNames.O(d); b += "]"; if (void 0 !== a && 0 < a) for (c = this.history.count, d = 0; d < c; d++)b += "\n " + this.history.O(d).toString(a - 1); return b };
    tf.prototype.clear = function () { var a = this.history; a.ja(); for (var b = a.count - 1; 0 <= b; b--) { var c = a.O(b); null !== c && c.clear() } a.clear(); this.ie = -1; a.freeze(); this.ke = !1; this.jr = null; this.Bi = 0; this.te.ja(); this.te.clear(); this.te.freeze(); this.wl.clear() }; tf.prototype.copyProperties = function (a) { this.isEnabled = a.isEnabled; this.maxHistoryLength = a.maxHistoryLength; this.checksTransactionLevel = a.checksTransactionLevel }; t = tf.prototype; t.Xw = function (a) { this.ou.add(a) }; t.Gx = function (a) { this.ou.remove(a) };
    t.Ca = function (a) { void 0 === a && (a = ""); null === a && (a = ""); if (this.isUndoingRedoing) return !1; !0 === this.eu && (this.eu = !1, this.Bi++ , this.zb("StartingFirstTransaction", a, this.currentTransaction), 0 < this.Bi && this.Bi--); this.isEnabled && (this.te.ja(), this.te.add(a), this.te.freeze(), null === this.currentTransaction ? this.wl.add(0) : this.wl.add(this.currentTransaction.changes.count)); this.Bi++; var b = 1 === this.transactionLevel; b && this.zb("StartedTransaction", a, this.currentTransaction); return b };
    t.ab = function (a) { void 0 === a && (a = ""); return uf(this, !0, a) }; t.xf = function () { return uf(this, !1, "") };
    function uf(a, b, c) {
        if (a.isUndoingRedoing) return !1; a.checksTransactionLevel && 1 > a.transactionLevel && Ga("Ending transaction without having started a transaction: " + c); var d = 1 === a.transactionLevel; d && b && a.zb("CommittingTransaction", c, a.currentTransaction); var e = 0; if (0 < a.transactionLevel && (a.Bi-- , a.isEnabled)) { var f = a.te.count; 0 < f && ("" === c && (c = a.te.O(0)), a.te.ja(), a.te.nb(f - 1), a.te.freeze()); f = a.wl.count; 0 < f && (e = a.wl.O(f - 1), a.wl.nb(f - 1)) } f = a.currentTransaction; if (d) {
            if (b) {
            a.iu = !1; if (a.isEnabled && null !==
                f) { b = f; b.isComplete = !0; b.name = c; d = a.history; d.ja(); for (e = d.count - 1; e > a.historyIndex; e--)f = d.O(e), null !== f && f.clear(), d.nb(e), a.iu = !0; e = a.maxHistoryLength; 0 <= e && (0 === e ? d.clear() : d.count >= e && (f = d.O(0), null !== f && f.clear(), d.nb(0), a.ie--)); 0 !== e && (d.add(b), a.ie++); d.freeze(); f = b } a.zb("CommittedTransaction", c, f)
            } else { a.ke = !0; try { a.isEnabled && null !== f && (f.isComplete = !0, f.undo()) } finally { a.zb("RolledBackTransaction", c, f), a.ke = !1 } null !== f && f.clear() } a.jr = null; return !0
        } if (a.isEnabled && !b && null !== f) {
            a = e; c =
                f.changes; for (b = c.count - 1; b >= a; b--)d = c.O(b), null !== d && d.undo(), c.ja(), c.nb(b); c.freeze()
        } return !1
    } tf.prototype.canUndo = function () { if (!this.isEnabled || 0 < this.transactionLevel) return !1; var a = this.transactionToUndo; return null !== a && a.canUndo() ? !0 : !1 }; tf.prototype.undo = function () { if (this.canUndo()) { var a = this.transactionToUndo; try { this.ke = !0, this.zb("StartingUndo", "Undo", a), this.ie-- , a.undo() } catch (b) { Ga("undo error: " + b.toString()) } finally { this.zb("FinishedUndo", "Undo", a), this.ke = !1 } } };
    tf.prototype.canRedo = function () { if (!this.isEnabled || 0 < this.transactionLevel) return !1; var a = this.transactionToRedo; return null !== a && a.canRedo() ? !0 : !1 }; tf.prototype.redo = function () { if (this.canRedo()) { var a = this.transactionToRedo; try { this.ke = !0, this.zb("StartingRedo", "Redo", a), this.ie++ , a.redo() } catch (b) { Ga("redo error: " + b.toString()) } finally { this.zb("FinishedRedo", "Redo", a), this.ke = !1 } } };
    tf.prototype.zb = function (a, b, c) { void 0 === c && (c = null); var d = new nf; d.change = pf; d.propertyName = a; d.object = c; d.oldValue = b; for (a = this.models; a.next();)b = a.value, d.model = b, b.Qs(d) };
    tf.prototype.nv = function (a) { if (this.isEnabled && !this.isUndoingRedoing && !this.skipsEvent(a)) { var b = this.currentTransaction; null === b && (this.jr = b = new sf); var c = a.copy(); b = b.changes; b.ja(); b.add(c); b.freeze(); this.checksTransactionLevel && 0 >= this.transactionLevel && !this.eu && (a = a.diagram, null !== a && !1 === a.Ti || Ga("Change not within a transaction: " + c.toString())) } };
    tf.prototype.skipsEvent = function (a) { if (null === a || 0 > a.change.value) return !0; a = a.object; if (void 0 !== a.layer) { if (a = a.layer, null !== a && a.isTemporary) return !0 } else if (a.isTemporary) return !0; return !1 };
    na.Object.defineProperties(tf.prototype, {
        models: { configurable: !0, get: function () { return this.ou.iterator } }, isEnabled: { configurable: !0, get: function () { return this.Fc }, set: function (a) { this.Fc = a } }, transactionToUndo: { configurable: !0, get: function () { return 0 <= this.historyIndex && this.historyIndex <= this.history.count - 1 ? this.history.O(this.historyIndex) : null } }, transactionToRedo: {
            configurable: !0, get: function () {
                return this.historyIndex < this.history.count -
                    1 ? this.history.O(this.historyIndex + 1) : null
            }
        }, isUndoingRedoing: { configurable: !0, get: function () { return this.ke } }, history: { configurable: !0, get: function () { return this.L } }, maxHistoryLength: { configurable: !0, get: function () { return this.w }, set: function (a) { this.w = a } }, historyIndex: { configurable: !0, get: function () { return this.ie } }, currentTransaction: { configurable: !0, get: function () { return this.jr } }, transactionLevel: {
            configurable: !0,
            get: function () { return this.Bi }
        }, isInTransaction: { configurable: !0, get: function () { return 0 < this.Bi } }, checksTransactionLevel: { configurable: !0, get: function () { return this.l }, set: function (a) { this.l = a } }, nestedTransactionNames: { configurable: !0, get: function () { return this.te } }
    }); tf.prototype.handleChanged = tf.prototype.nv; tf.prototype.redo = tf.prototype.redo; tf.prototype.undo = tf.prototype.undo; tf.prototype.canUndo = tf.prototype.canUndo;
    tf.prototype.rollbackTransaction = tf.prototype.xf; tf.prototype.commitTransaction = tf.prototype.ab; tf.prototype.startTransaction = tf.prototype.Ca; tf.prototype.removeModel = tf.prototype.Gx; tf.prototype.addModel = tf.prototype.Xw; tf.prototype.clear = tf.prototype.clear; tf.className = "UndoManager"; function vf() { 0 < arguments.length && Da(vf); qb(this); this.D = yf; this.Wa = ""; this.Fc = !0; this.Wb = !1; this.Iq = null; this.jy = new kf; this.Ns = -1 } vf.prototype.ib = function (a) { this.D = a };
    vf.prototype.toString = function () { return "" !== this.name ? this.name + " Tool" : Va(this.constructor) }; vf.prototype.updateAdornments = function () { }; vf.prototype.canStart = function () { return this.isEnabled }; vf.prototype.doStart = function () { }; vf.prototype.doActivate = function () { this.isActive = !0 }; vf.prototype.doDeactivate = function () { this.isActive = !1 }; vf.prototype.doStop = function () { }; vf.prototype.doCancel = function () { this.transactionResult = null; this.stopTool() };
    vf.prototype.stopTool = function () { var a = this.diagram; a.currentTool === this && (a.currentTool = null, a.currentCursor = "") }; vf.prototype.doMouseDown = function () { !this.isActive && this.canStart() && this.doActivate() }; vf.prototype.doMouseMove = function () { }; vf.prototype.doMouseUp = function () { this.stopTool() }; vf.prototype.doMouseWheel = function () { }; vf.prototype.canStartMultiTouch = function () { return !0 };
    vf.prototype.standardPinchZoomStart = function () { var a = this.diagram, b = a.lastInput, c = b.fq(0, J.allocAt(NaN, NaN)), d = b.fq(1, J.allocAt(NaN, NaN)); if (c.o() && d.o() && (this.doCancel(), a.fm("hasGestureZoom"))) { a.Oo = a.scale; var e = d.x - c.x, f = d.y - c.y; a.Nw = Math.sqrt(e * e + f * f); b.bubbles = !1 } J.free(c); J.free(d) };
    vf.prototype.standardPinchZoomMove = function () { var a = this.diagram, b = a.lastInput, c = b.fq(0, J.allocAt(NaN, NaN)), d = b.fq(1, J.allocAt(NaN, NaN)); if (c.o() && d.o() && (this.doCancel(), a.fm("hasGestureZoom"))) { var e = d.x - c.x, f = d.y - c.y; f = Math.sqrt(e * e + f * f) / a.Nw; e = new J((Math.min(d.x, c.x) + Math.max(d.x, c.x)) / 2, (Math.min(d.y, c.y) + Math.max(d.y, c.y)) / 2); f *= a.Oo; var g = a.commandHandler; if (f !== a.scale && g.canResetZoom(f)) { var h = a.zoomPoint; a.zoomPoint = e; g.resetZoom(f); a.zoomPoint = h } b.bubbles = !1 } J.free(c); J.free(d) };
    vf.prototype.doKeyDown = function () { "Esc" === this.diagram.lastInput.key && this.doCancel() }; vf.prototype.doKeyUp = function () { }; vf.prototype.Ca = function (a) { void 0 === a && (a = this.name); this.transactionResult = null; return this.diagram.Ca(a) }; vf.prototype.yg = function () { var a = this.diagram; return null === this.transactionResult ? a.xf() : a.ab(this.transactionResult) };
    vf.prototype.standardMouseSelect = function () {
        var a = this.diagram; if (a.allowSelect) {
            var b = a.lastInput, c = a.dm(b.documentPoint, !1); if (null !== c) if (kb ? b.meta : b.control) { a.ba("ChangingSelection", a.selection); for (b = c; null !== b && !b.canSelect();)b = b.containingGroup; null !== b && (b.isSelected = !b.isSelected); a.ba("ChangedSelection", a.selection) } else if (b.shift) {
                if (!c.isSelected) {
                    a.ba("ChangingSelection", a.selection); for (b = c; null !== b && !b.canSelect();)b = b.containingGroup; null !== b && (b.isSelected = !0); a.ba("ChangedSelection",
                        a.selection)
                }
            } else { if (!c.isSelected) { for (b = c; null !== b && !b.canSelect();)b = b.containingGroup; null !== b && a.select(b) } } else !b.left || (kb ? b.meta : b.control) || b.shift || a.Vp()
        }
    }; vf.prototype.standardMouseClick = function (a, b) { void 0 === a && (a = null); void 0 === b && (b = function (a) { return !a.layer.isTemporary }); var c = this.diagram, d = c.lastInput; a = c.Tb(d.documentPoint, a, b); d.targetObject = a; zf(a, d, c); return d.handled };
    function zf(a, b, c) {
    b.handled = !1; if (null === a || a.ug()) {
        var d = 0; b.left ? d = 1 === b.clickCount ? 1 : 2 === b.clickCount ? 2 : 1 : b.right && 1 === b.clickCount && (d = 3); var e = "ObjectSingleClicked"; if (null !== a) { switch (d) { case 1: e = "ObjectSingleClicked"; break; case 2: e = "ObjectDoubleClicked"; break; case 3: e = "ObjectContextClicked" }0 !== d && c.ba(e, a) } else { switch (d) { case 1: e = "BackgroundSingleClicked"; break; case 2: e = "BackgroundDoubleClicked"; break; case 3: e = "BackgroundContextClicked" }0 !== d && c.ba(e) } if (null !== a) for (; null !== a;) {
            c = null; switch (d) {
                case 1: c =
                    a.click; break; case 2: c = a.doubleClick ? a.doubleClick : a.click; break; case 3: c = a.contextClick
            }if (null !== c && (c(b, a), b.handled)) break; a = a.panel
        } else { a = null; switch (d) { case 1: a = c.click; break; case 2: a = c.doubleClick ? c.doubleClick : c.click; break; case 3: a = c.contextClick }null !== a && a(b) }
    }
    }
    vf.prototype.standardMouseOver = function () {
        var a = this.diagram, b = a.lastInput; if (!0 !== a.animationManager.sb) {
            var c = a.skipsUndoManager; a.skipsUndoManager = !0; var d = a.viewportBounds.ea(b.documentPoint) ? a.Tb(b.documentPoint, null, null) : null; b.targetObject = d; var e = !1; if (d !== a.Nk) {
                var f = a.Nk, g = f; a.Nk = d; this.doCurrentObjectChanged(f, d); for (b.handled = !1; null !== f;) { var h = f.mouseLeave; if (null !== h) { if (d === f) break; if (null !== d && d.tg(f)) break; h(b, f, d); e = !0; if (b.handled) break } f = f.panel } f = g; for (b.handled = !1; null !== d;) {
                    g =
                    d.mouseEnter; if (null !== g) { if (f === d) break; if (null !== f && f.tg(d)) break; g(b, d, f); e = !0; if (b.handled) break } d = d.panel
                } d = a.Nk
            } if (null !== d) { f = d; for (g = ""; null !== f;) { g = f.cursor; if ("" !== g) break; f = f.panel } a.currentCursor = g; b.handled = !1; for (f = d; null !== f;) { d = f.mouseOver; if (null !== d && (d(b, f), e = !0, b.handled)) break; f = f.panel } } else a.currentCursor = "", d = a.mouseOver, null !== d && (d(b), e = !0); e && a.ec(); a.skipsUndoManager = c
        }
    }; vf.prototype.doCurrentObjectChanged = function () { };
    vf.prototype.standardMouseWheel = function () {
        var a = this.diagram, b = a.lastInput, c = b.delta; if (0 !== c && a.documentBounds.o()) {
            var d = a.commandHandler, e = a.toolManager.mouseWheelBehavior; if (null !== d && (e === Af && !b.shift || e === Bf && b.control) && (0 < c ? d.canIncreaseZoom() : d.canDecreaseZoom())) e = a.zoomPoint, a.zoomPoint = b.viewPoint, 0 < c ? d.increaseZoom() : d.decreaseZoom(), a.zoomPoint = e, b.bubbles = !1; else if (e === Af && b.shift || e === Bf && !b.control) {
                d = a.position.copy(); var f = 0 < c ? c : -c, g = b.event, h = g.deltaMode; e = g.deltaX; g = g.deltaY;
                if (gb || ib || jb) h = 1, 0 < e && (e = 3), 0 > e && (e = -3), 0 < g && (g = 3), 0 > g && (g = -3); if (void 0 === h || void 0 === e || void 0 === g || 0 === e && 0 === g || b.shift) !b.shift && a.allowVerticalScroll ? (f = 3 * f * a.scrollVerticalLineChange, 0 < c ? a.scroll("pixel", "up", f) : a.scroll("pixel", "down", f)) : b.shift && a.allowHorizontalScroll && (f = 3 * f * a.scrollHorizontalLineChange, 0 < c ? a.scroll("pixel", "left", f) : a.scroll("pixel", "right", f)); else {
                    switch (h) { case 0: c = "pixel"; break; case 1: c = "line"; break; case 2: c = "page"; break; default: c = "pixel" }0 !== e && a.allowHorizontalScroll &&
                        (0 < e ? a.scroll(c, "left", -e) : a.scroll(c, "right", e)); 0 !== g && a.allowVerticalScroll && (0 < g ? a.scroll(c, "up", -g) : a.scroll(c, "down", g))
                } a.position.A(d) || (b.bubbles = !1)
            }
        }
    }; vf.prototype.standardWaitAfter = function (a, b) { E && z(a, "number", vf, "standardWaitAfter:delay"); void 0 === b && (b = this.diagram.lastInput); this.cancelWaitAfter(); var c = this, d = b.clone(this.jy); this.Ns = wa(function () { c.doWaitAfter(d) }, a) }; vf.prototype.cancelWaitAfter = function () { -1 !== this.Ns && qa.clearTimeout(this.Ns); this.Ns = -1 };
    vf.prototype.doWaitAfter = function () { }; vf.prototype.findToolHandleAt = function (a, b) { a = this.diagram.Tb(a, function (a) { for (; null !== a && !(a.panel instanceof Cf);)a = a.panel; return a }); return null === a ? null : a.part.category === b ? a : null }; vf.prototype.isBeyondDragSize = function (a, b) { var c = this.diagram; void 0 === a && (a = c.firstInput.viewPoint); void 0 === b && (b = c.lastInput.viewPoint); var d = c.toolManager.dragSize, e = d.width; d = d.height; c.firstInput.isTouchEvent && (e += 6, d += 6); return Math.abs(b.x - a.x) > e || Math.abs(b.y - a.y) > d };
    na.Object.defineProperties(vf.prototype, {
        diagram: { configurable: !0, get: function () { return this.D }, set: function (a) { a instanceof P && (this.D = a) } }, name: { configurable: !0, get: function () { return this.Wa }, set: function (a) { z(a, "string", vf, "name"); this.Wa = a } }, isEnabled: { configurable: !0, get: function () { return this.Fc }, set: function (a) { z(a, "boolean", vf, "isEnabled"); this.Fc = a } }, isActive: {
            configurable: !0, get: function () { return this.Wb }, set: function (a) {
                z(a, "boolean",
                    vf, "isActive"); this.Wb = a
            }
        }, transactionResult: { configurable: !0, get: function () { return this.Iq }, set: function (a) { null !== a && z(a, "string", vf, "transactionResult"); this.Iq = a } }
    }); vf.prototype.stopTransaction = vf.prototype.yg; vf.prototype.startTransaction = vf.prototype.Ca; vf.className = "Tool"; function $a() { vf.call(this); this.name = "ToolManager"; this.Nc = new F; this.Oc = new F; this.zg = new F; this.ca = this.Ma = 850; this.w = (new Zb(2, 2)).ia(); this.Xb = 5E3; this.Na = Bf; this.L = Df; this.ir = this.l = null; this.Oj = -1 }
    ma($a, vf); $a.prototype.initializeStandardTools = function () { }; $a.prototype.updateAdornments = function (a) { var b = this.currentToolTip; if (b instanceof Cf && this.ir === a) { var c = b.adornedObject; (null !== a ? c.part === a : null === c) ? this.showToolTip(b, c) : this.hideToolTip() } };
    $a.prototype.doMouseDown = function () {
        var a = this.diagram, b = a.lastInput; b.isTouchEvent && this.gestureBehavior === Ef && (b.bubbles = !1); if (b.isMultiTouch) { this.cancelWaitAfter(); if (this.gestureBehavior === Ff) { b.bubbles = !0; return } if (this.gestureBehavior === Ef) return; if (a.currentTool.canStartMultiTouch()) { a.currentTool.standardPinchZoomStart(); return } } var c = a.undoManager; E && c.checksTransactionLevel && 0 !== c.transactionLevel && Ga("WARNING: In ToolManager.doMouseDown: UndoManager.transactionLevel is not zero"); c = this.mouseDownTools.length;
        for (var d = 0; d < c; d++) { var e = this.mouseDownTools.O(d); e.ib(this.diagram); if (e.canStart()) { a.doFocus(); a.currentTool = e; a.currentTool === e && (e.isActive || e.doActivate(), e.doMouseDown()); return } } 1 === a.lastInput.button && (this.mouseWheelBehavior === Bf ? this.mouseWheelBehavior = Af : this.mouseWheelBehavior === Af && (this.mouseWheelBehavior = Bf)); this.doActivate(); this.standardWaitAfter(this.holdDelay, b)
    };
    $a.prototype.doMouseMove = function () {
        var a = this.diagram, b = a.lastInput; if (b.isMultiTouch) { if (this.gestureBehavior === Ff) { b.bubbles = !0; return } if (this.gestureBehavior === Ef) return; if (a.currentTool.canStartMultiTouch()) { a.currentTool.standardPinchZoomMove(); return } } if (this.isActive) for (var c = this.mouseMoveTools.length, d = 0; d < c; d++) { var e = this.mouseMoveTools.O(d); e.ib(this.diagram); if (e.canStart()) { a.doFocus(); a.currentTool = e; a.currentTool === e && (e.isActive || e.doActivate(), e.doMouseMove()); return } } Gf(this,
            a); a = b.event; null === a || "mousemove" !== a.type && "pointermove" !== a.type && a.cancelable || (b.bubbles = !0)
    }; function Gf(a, b) { a.standardMouseOver(); a.isBeyondDragSize() && a.standardWaitAfter(a.isActive ? a.holdDelay : a.hoverDelay, b.lastInput) } $a.prototype.doCurrentObjectChanged = function (a, b) { a = this.currentToolTip; null === a || null !== b && a instanceof Cf && (b === a || b.tg(a)) || this.hideToolTip() };
    $a.prototype.doWaitAfter = function (a) { var b = this.diagram; b.Ea && (this.doMouseHover(), this.isActive || this.doToolTip(), a.isTouchEvent && !b.lastInput.handled && (a = a.copy(), a.button = 2, a.buttons = 2, b.lastInput = a, b.Ql = !0, b.doMouseUp())) };
    $a.prototype.doMouseHover = function () { var a = this.diagram, b = a.lastInput; null === b.targetObject && (b.targetObject = a.Tb(b.documentPoint, null, null)); var c = b.targetObject; if (null !== c) for (b.handled = !1; null !== c;) { a = this.isActive ? c.mouseHold : c.mouseHover; if (null !== a && (a(b, c), b.handled)) break; c = c.panel } else c = this.isActive ? a.mouseHold : a.mouseHover, null !== c && c(b) };
    $a.prototype.doToolTip = function () { var a = this.diagram, b = a.lastInput; null === b.targetObject && (b.targetObject = a.Tb(b.documentPoint, null, null)); b = b.targetObject; if (null !== b) { if (a = this.currentToolTip, !(a instanceof Cf) || b !== a && !b.tg(a)) { for (; null !== b;) { a = b.toolTip; if (null !== a) { this.showToolTip(a, b); return } b = b.panel } this.hideToolTip() } } else b = a.toolTip, null !== b ? this.showToolTip(b, null) : this.hideToolTip() };
    $a.prototype.showToolTip = function (a, b) {
    !E || a instanceof Cf || a instanceof Hf || v("showToolTip:tooltip must be an Adornment or HTMLInfo."); null !== b && w(b, N, $a, "showToolTip:obj"); var c = this.diagram; a !== this.currentToolTip && this.hideToolTip(); if (a instanceof Cf) {
    a.layerName = "Tool"; a.selectable = !1; a.scale = 1 / c.scale; a.category = "ToolTip"; null !== a.placeholder && (a.placeholder.scale = c.scale); var d = a.diagram; null !== d && d !== c && d.remove(a); c.add(a); null !== b ? a.adornedObject = b : a.data = c.model; a.bc(); this.positionToolTip(a,
        b)
    } else a instanceof Hf && a !== this.currentToolTip && a.show(b, c, this); this.currentToolTip = a; -1 !== this.Oj && (qa.clearTimeout(this.Oj), this.Oj = -1); a = this.toolTipDuration; if (0 < a && Infinity !== a) { var e = this; this.Oj = wa(function () { e.hideToolTip() }, a) }
    };
    $a.prototype.positionToolTip = function (a) { if (null === a.placeholder) { var b = this.diagram, c = b.lastInput.documentPoint.copy(), d = a.measuredBounds, e = b.viewportBounds; b.lastInput.isTouchEvent && (c.x -= d.width); c.x + d.width > e.right && (c.x -= d.width + 5 / b.scale); c.x < e.x && (c.x = e.x); c.y = c.y + 20 / b.scale + d.height > e.bottom ? c.y - (d.height + 5 / b.scale) : c.y + 20 / b.scale; c.y < e.y && (c.y = e.y); a.position = c } };
    $a.prototype.hideToolTip = function () { -1 !== this.Oj && (qa.clearTimeout(this.Oj), this.Oj = -1); var a = this.diagram, b = this.currentToolTip; null !== b && (b instanceof Cf ? (a.remove(b), null !== this.ir && this.ir.wf(b.category), b.data = null, b.adornedObject = null) : b instanceof Hf && null !== b.hide && b.hide(a, this), this.currentToolTip = null) };
    $a.prototype.doMouseUp = function () { this.cancelWaitAfter(); var a = this.diagram; if (this.isActive) for (var b = this.mouseUpTools.length, c = 0; c < b; c++) { var d = this.mouseUpTools.O(c); d.ib(this.diagram); if (d.canStart()) { a.doFocus(); a.currentTool = d; a.currentTool === d && (d.isActive || d.doActivate(), d.doMouseUp()); return } } a.doFocus(); this.doDeactivate() }; $a.prototype.doMouseWheel = function () { this.standardMouseWheel() }; $a.prototype.doKeyDown = function () { var a = this.diagram; null !== a.commandHandler && a.commandHandler.doKeyDown() };
    $a.prototype.doKeyUp = function () { var a = this.diagram; null !== a.commandHandler && a.commandHandler.doKeyUp() }; $a.prototype.findTool = function (a) { z(a, "string", $a, "findTool:name"); for (var b = this.mouseDownTools.length, c = 0; c < b; c++) { var d = this.mouseDownTools.O(c); if (d.name === a) return d } b = this.mouseMoveTools.length; for (c = 0; c < b; c++)if (d = this.mouseMoveTools.O(c), d.name === a) return d; b = this.mouseUpTools.length; for (c = 0; c < b; c++)if (d = this.mouseUpTools.O(c), d.name === a) return d; return null };
    $a.prototype.replaceTool = function (a, b) {
        z(a, "string", $a, "replaceTool:name"); null !== b && (w(b, vf, $a, "replaceTool:newtool"), b.ib(this.diagram)); for (var c = this.mouseDownTools.length, d = 0; d < c; d++) { var e = this.mouseDownTools.O(d); if (e.name === a) return null !== b ? this.mouseDownTools.jd(d, b) : this.mouseDownTools.nb(d), e } c = this.mouseMoveTools.length; for (d = 0; d < c; d++)if (e = this.mouseMoveTools.O(d), e.name === a) return null !== b ? this.mouseMoveTools.jd(d, b) : this.mouseMoveTools.nb(d), e; c = this.mouseUpTools.length; for (d = 0; d <
            c; d++)if (e = this.mouseUpTools.O(d), e.name === a) return null !== b ? this.mouseUpTools.jd(d, b) : this.mouseUpTools.nb(d), e; return null
    }; function If(a, b, c, d) { z(b, "string", $a, "replaceStandardTool:name"); w(d, F, $a, "replaceStandardTool:list"); null !== c && (w(c, vf, $a, "replaceStandardTool:newtool"), c.name = b, c.ib(a.diagram)); a.findTool(b) ? a.replaceTool(b, c) : null !== c && d.add(c) }
    na.Object.defineProperties($a.prototype, {
        mouseWheelBehavior: { configurable: !0, get: function () { return this.Na }, set: function (a) { tb(a, $a, $a, "mouseWheelBehavior"); this.Na = a } }, gestureBehavior: { configurable: !0, get: function () { return this.L }, set: function (a) { tb(a, $a, $a, "gestureBehavior"); this.L = a } }, currentToolTip: {
            configurable: !0, get: function () { return this.l }, set: function (a) {
            !E || null === a || a instanceof Cf || a instanceof Hf || v("ToolManager.currentToolTip must be an Adornment or HTMLInfo.");
                this.l = a; this.ir = null !== a && a instanceof Cf ? a.adornedPart : null
            }
        }, mouseDownTools: { configurable: !0, get: function () { return this.Nc } }, mouseMoveTools: { configurable: !0, get: function () { return this.Oc } }, mouseUpTools: { configurable: !0, get: function () { return this.zg } }, hoverDelay: { configurable: !0, get: function () { return this.Ma }, set: function (a) { z(a, "number", $a, "hoverDelay"); this.Ma = a } }, holdDelay: {
            configurable: !0, get: function () { return this.ca }, set: function (a) {
                z(a,
                    "number", $a, "holdDelay"); this.ca = a
            }
        }, dragSize: { configurable: !0, get: function () { return this.w }, set: function (a) { w(a, Zb, $a, "dragSize"); this.w = a.J() } }, toolTipDuration: { configurable: !0, get: function () { return this.Xb }, set: function (a) { z(a, "number", $a, "toolTipDuration"); this.Xb = a } }
    }); var Bf = new D($a, "WheelScroll", 0), Af = new D($a, "WheelZoom", 1), Jf = new D($a, "WheelNone", 2), Df = new D($a, "GestureZoom", 3), Ef = new D($a, "GestureCancel", 4), Ff = new D($a, "GestureNone", 5); $a.className = "ToolManager";
    $a.WheelScroll = Bf; $a.WheelZoom = Af; $a.WheelNone = Jf; $a.GestureZoom = Df; $a.GestureCancel = Ef; $a.GestureNone = Ff; function Kf() { vf.call(this); 0 < arguments.length && Da(Kf); this.name = "Dragging"; this.L = this.Nc = !0; this.w = this.Na = this.ca = this.dg = null; this.Cn = this.Oc = !1; this.Ll = new J(NaN, NaN); this.Ds = new J; this.Xb = !0; this.Uk = 100; this.Kg = []; this.zg = (new I).freeze(); this.Ma = new Lf } ma(Kf, vf);
    Kf.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; if (a.isReadOnly && !a.allowDragOut || !a.allowMove && !a.allowCopy && !a.allowDragOut || !a.allowSelect) return !1; var b = a.lastInput; return !b.left || a.currentTool !== this && (!this.isBeyondDragSize() || b.isTouchEvent && b.timestamp - a.firstInput.timestamp < this.Uk) ? !1 : null !== this.findDraggablePart() };
    Kf.prototype.findDraggablePart = function () { var a = this.diagram; a = a.dm(a.firstInput.documentPoint, !1); if (null === a) return null; for (; null !== a && !a.canSelect();)a = a.containingGroup; return null !== a && (a.canMove() || a.canCopy()) ? a : null };
    Kf.prototype.standardMouseSelect = function () { var a = this.diagram; if (a.allowSelect) { var b = a.dm(a.firstInput.documentPoint, !1); if (null !== b) { for (; null !== b && !b.canSelect();)b = b.containingGroup; this.currentPart = b; null === this.currentPart || this.currentPart.isSelected || (a.ba("ChangingSelection", a.selection), b = a.lastInput, (kb ? b.meta : b.control) || b.shift || Mf(a), this.currentPart.isSelected = !0, a.ba("ChangedSelection", a.selection)) } } };
    Kf.prototype.doActivate = function () {
        var a = this.diagram; null === this.currentPart && this.standardMouseSelect(); var b = this.currentPart; null !== b && (b.canMove() || b.canCopy()) && (Nf = null, this.isActive = !0, this.Ll.set(a.position), Of(this, a.selection), this.Kg.length = 0, this.draggedParts = this.computeEffectiveCollection(a.selection, this.dragOptions), a.Yi = !0, !0 === a.Ge("temporaryPixelRatio") && 30 < a.$w && Yf(a), Zf(a, this.draggedParts), this.Ca("Drag"), this.startPoint = a.firstInput.documentPoint, a.isMouseCaptured = !0, a.allowDragOut &&
            (this.isDragOutStarted = !0, this.Cn = !1, Nf = this, $f = this.diagram, this.doSimulatedDragOut()))
    }; function Of(a, b) { if (a.dragsLink) { var c = a.diagram; c.allowRelink && (c.model.hk() && 1 === b.count && b.first() instanceof Q ? (a.draggedLink = b.first(), a.draggedLink.canRelinkFrom() && a.draggedLink.canRelinkTo() && a.draggedLink.Wj(), a.dg = c.toolManager.findTool("Relinking"), null === a.dg && (a.dg = new ag, a.dg.ib(c))) : (a.draggedLink = null, a.dg = null)) } }
    Kf.prototype.computeEffectiveCollection = function (a, b) { return this.diagram.commandHandler.computeEffectiveCollection(a, b) }; Kf.prototype.rd = function (a) { return void 0 === a ? new bg(gc) : this.isGridSnapEnabled ? new bg(new J(Math.round(a.x), Math.round(a.y))) : new bg(a.copy()) };
    Kf.prototype.doDeactivate = function () { this.isActive = !1; var a = this.diagram; a.yf(); cg(this); dg(a, this.draggedParts); this.draggedParts = this.currentPart = null; this.Cn = this.isDragOutStarted = !1; if (0 < eg.count) { for (var b = eg, c = b.length, d = 0; d < c; d++) { var e = b.O(d); fg(e); gg(e); cg(e); e.diagram.yf() } b.clear() } fg(this); this.Ll.h(NaN, NaN); Nf = $f = null; gg(this); a.isMouseCaptured = !1; a.currentCursor = ""; a.Yi = !1; this.yg(); hg(a, !0) };
    function cg(a) { var b = a.diagram, c = b.skipsUndoManager; b.skipsUndoManager = !0; ig(a, b.lastInput, null); b.skipsUndoManager = c; a.Kg.length = 0 } function jg() { var a = Nf; gg(a); kg(a); var b = a.diagram; a.Ll.o() && (b.position = a.Ll); b.yf() } Kf.prototype.doCancel = function () { gg(this); kg(this); var a = this.diagram; this.Ll.o() && (a.position = this.Ll); this.stopTool() }; Kf.prototype.doKeyDown = function () { this.isActive && ("Esc" === this.diagram.lastInput.key ? this.doCancel() : this.doMouseMove()) };
    Kf.prototype.doKeyUp = function () { this.isActive && this.doMouseMove() }; function lg(a, b) { var c = Infinity, d = Infinity, e = -Infinity, f = -Infinity; for (a = a.iterator; a.next();) { var g = a.value; if (g.dc() && g.isVisible()) { var h = g.location; g = h.x; h = h.y; isNaN(g) || isNaN(h) || (g < c && (c = g), h < d && (d = h), g > e && (e = g), h > f && (f = h)) } } Infinity === c ? b.h(0, 0, 0, 0) : b.h(c, d, e - c, f - d) }
    function mg(a, b) {
        if (null === a.copiedParts) {
            var c = a.diagram; if ((!b || !c.isReadOnly && !c.isModelReadOnly) && null !== a.draggedParts) {
                var d = c.undoManager; d.isEnabled && d.isInTransaction ? null !== d.currentTransaction && 0 < d.currentTransaction.changes.count && (c.undoManager.xf(), c.Ca("Drag")) : kg(a); c.skipsUndoManager = !b; c.partManager.addsToTemporaryLayer = !b; a.startPoint = c.firstInput.documentPoint; b = a.copiesEffectiveCollection ? a.draggedParts.$d() : c.selection; c = c.ak(b, c, !0); for (b = c.iterator; b.next();)b.value.location =
                    b.key.location; b = L.alloc(); lg(c, b); L.free(b); b = new Ub; for (d = a.draggedParts.iterator; d.next();) { var e = d.key; e.dc() && e.canCopy() && (e = c.K(e), null !== e && (e.bc(), b.add(e, a.rd(e.location)))) } for (c = c.iterator; c.next();)d = c.value, d instanceof Q && d.canCopy() && b.add(d, a.rd()); a.copiedParts = b; Of(a, b.$d()); null !== a.draggedLink && (c = a.draggedLink, b = c.routeBounds, ng(c, a.startPoint.x - (b.x + b.width / 2), a.startPoint.y - (b.y + b.height / 2)))
            }
        }
    }
    function gg(a) { var b = a.diagram; if (null !== a.copiedParts && (b.wt(a.copiedParts.$d(), !1), a.copiedParts = null, null !== a.draggedParts)) for (var c = a.draggedParts.iterator; c.next();)c.key instanceof Q && (c.value.point = new J(0, 0)); b.skipsUndoManager = !1; b.partManager.addsToTemporaryLayer = !1; a.startPoint = b.firstInput.documentPoint }
    function fg(a) { if (null !== a.draggedLink) { if (a.dragsLink && null !== a.dg) { var b = a.dg; b.diagram.remove(b.temporaryFromNode); b.diagram.remove(b.temporaryToNode) } a.draggedLink = null; a.dg = null } } function og(a, b, c) { var d = a.diagram, e = a.startPoint, f = J.alloc(); f.assign(d.lastInput.documentPoint); a.moveParts(b, f.Zd(e), c); J.free(f); !0 === d.Ge("temporaryPixelRatio") && null === d.jh && 30 < d.$w && (Yf(d), d.tt()) } Kf.prototype.moveParts = function (a, b, c) { var d = this.diagram; null !== d && pg(d, a, b, this.dragOptions, c) };
    function kg(a) { if (null !== a.draggedParts) { for (var b = a.diagram, c = a.draggedParts.iterator; c.next();) { var d = c.key; d.dc() && (d.location = c.value.point) } for (c = a.draggedParts.iterator; c.next();)if (d = c.key, d instanceof Q && d.suspendsRouting) { var e = c.value.point; a.draggedParts.add(d, a.rd()); ng(d, -e.x, -e.y) } b.hd() } } function qg(a, b) { if (null === b) return !0; b = b.part; return null === b || b instanceof Cf || b.layer.isTemporary || a.draggedParts && a.draggedParts.contains(b) || a.copiedParts && a.copiedParts.contains(b) ? !0 : !1 }
    function tg(a, b) {
        var c = a.diagram; a.dragsLink && (null !== a.draggedLink && (a.draggedLink.fromNode = null, a.draggedLink.toNode = null), ug(a, !1)); var d = vg(c, b, null, function (b) { return !qg(a, b) }), e = c.lastInput; e.targetObject = d; var f = c.skipsUndoManager, g = !1; try { c.skipsUndoManager = !0; g = ig(a, e, d); if (!a.isActive && null === Nf) return; if (null === d || c.handlesDragDropForTopLevelParts) { var h = c.mouseDragOver; null !== h && (h(e), g = !0) } if (!a.isActive && null === Nf) return; a.doDragOver(b, d); if (!a.isActive && null === Nf) return } finally {
        c.skipsUndoManager =
            f, g && c.hd()
        } (c.allowHorizontalScroll || c.allowVerticalScroll) && c.Ts(e.viewPoint)
    } function ig(a, b, c) { var d = !1, e = a.Kg.length, f = 0 < e ? a.Kg[0] : null; if (c === f) return !1; b.handled = !1; for (var g = 0; g < e; g++) { var h = a.Kg[g], k = h.mouseDragLeave; if (null !== k && (k(b, h, c), d = !0, b.handled)) break } a.Kg.length = 0; if (!a.isActive && null === Nf || null === c) return d; b.handled = !1; for (e = c; null !== e;)a.Kg.push(e), e = wg(e); e = a.Kg.length; for (c = 0; c < e && (g = a.Kg[c], h = g.mouseDragEnter, null === h || (h(b, g, f), d = !0, !b.handled)); c++); return d }
    function wg(a) { var b = a.panel; return null !== b ? b : a instanceof R && !(a instanceof xg) && (a = a.containingGroup, null !== a && a.handlesDragDropForMembers) ? a : null } function yg(a, b, c) { var d = a.dg; if (null === d) return null; var e = a.diagram.qg(b, d.portGravity, function (a) { return d.findValidLinkablePort(a, c) }); a = J.alloc(); var f = Infinity, g = null; for (e = e.iterator; e.next();) { var h = e.value; if (null !== h.part) { var k = h.oa(qd, a); k = b.Ee(k); k < f && (g = h, f = k) } } J.free(a); return g }
    function ug(a, b) {
        var c = a.draggedLink; if (null !== c && !(2 > c.pointsCount)) {
            var d = a.diagram; if (!d.isReadOnly) {
                var e = a.dg; if (null !== e) {
                    var f = null, g = null; null === c.fromNode && (f = yg(a, c.i(0), !1), null !== f && (g = f.part)); var h = null, k = null; null === c.toNode && (h = yg(a, c.i(c.pointsCount - 1), !0), null !== h && (k = h.part)); e.isValidLink(g, f, k, h) ? b ? (c.defaultFromPoint = c.i(0), c.defaultToPoint = c.i(c.pointsCount - 1), c.suspendsRouting = !1, c.fromNode = g, null !== f && (c.fromPortId = f.portId), c.toNode = k, null !== h && (c.toPortId = h.portId), c.fromPort !==
                        d.Ax && d.ba("LinkRelinked", c, d.Ax), c.toPort !== d.Bx && d.ba("LinkRelinked", c, d.Bx)) : zg(e, g, f, k, h) : zg(e, null, null, null, null)
                }
            }
        }
    } Kf.prototype.doDragOver = function () { };
    function Ag(a, b) {
        var c = a.diagram; a.dragsLink && ug(a, !0); cg(a); var d = vg(c, b, null, function (b) { return !qg(a, b) }), e = c.lastInput; e.targetObject = d; if (null !== d) { e.handled = !1; for (var f = d; null !== f;) { var g = f.mouseDrop; if (null !== g && (g(e, f), e.handled)) break; Bg(a, e, f); f = wg(f) } } else f = c.mouseDrop, null !== f && f(e); if (a.isActive || null !== Nf) {
            for (e = (a.copiedParts || a.draggedParts).iterator; e.next();)f = e.key, f instanceof V && f.linksConnected.each(function (a) { a.suspendsRouting = !1 }); a.doDropOnto(b, d); if (a.isActive || null !==
                Nf) { b = L.alloc(); for (d = c.selection.iterator; d.next();)e = d.value, e instanceof V && Cg(a, c, e, b); L.free(b) }
        }
    } function Bg(a, b, c) { a = a.diagram; c instanceof R && null === c.containingGroup && !(c instanceof xg) && a.handlesDragDropForTopLevelParts && (c = a.mouseDrop, null !== c && c(b)) }
    function Cg(a, b, c, d) { var e = !1; c.getAvoidableRect(d); b.viewportBounds.pf(d) && (e = !0); b = b.links; for (a = a.copiedParts || a.draggedParts; b.next();) { var f = b.value; if (!e || Dg(f)) a.contains(f) && a.contains(c) || !f.Xd(c) && f.isAvoiding && Lc(f.actualBounds, d, 0) && f.Ta() } } Kf.prototype.doDropOnto = function () { };
    Kf.prototype.doMouseMove = function () { if (this.isActive) { var a = this.diagram, b = a.lastInput; this.simulatedMouseMove(b.event, null, b.targetDiagram || null) || null === this.currentPart || null === this.draggedParts || (this.mayCopy() ? (a.currentCursor = "copy", mg(this, !1), Zf(a, this.copiedParts), og(this, this.copiedParts, !1), dg(a, this.copiedParts)) : this.mayMove() ? (gg(this), og(this, this.draggedParts, !0)) : this.mayDragOut() ? (a.currentCursor = "no-drop", mg(this, !1), og(this, this.copiedParts, !1)) : gg(this), tg(this, a.lastInput.documentPoint)) } };
    Kf.prototype.doMouseUp = function () {
        if (this.isActive) {
            var a = this.diagram, b = a.lastInput; if (!this.simulatedMouseUp(b.event, null, b.documentPoint, b.targetDiagram)) {
                var c = !1; (b = this.mayCopy()) && null !== this.copiedParts ? (gg(this), mg(this, !0), Zf(a, this.copiedParts), og(this, this.copiedParts, !1), dg(a, this.copiedParts), null !== this.copiedParts && a.Nv(this.copiedParts.$d())) : (c = !0, gg(this), this.mayMove() && (og(this, this.draggedParts, !0), tg(this, a.lastInput.documentPoint))); this.Cn = !0; Ag(this, a.lastInput.documentPoint);
                if (this.isActive) { var d = b ? this.copiedParts.$d() : this.draggedParts.$d(); this.copiedParts = null; if (c && null !== this.draggedParts) for (c = this.draggedParts.iterator; c.next();) { var e = c.key; e instanceof V && (e = e.containingGroup, null === e || null === e.placeholder || this.draggedParts.contains(e) || e.placeholder.v()) } a.Ya(); dg(a, this.draggedParts); this.transactionResult = b ? "Copy" : "Move"; a.ba(b ? "SelectionCopied" : "SelectionMoved", d) } this.stopTool()
            }
        }
    };
    Kf.prototype.simulatedMouseMove = function (a, b, c) {
        if (null === Nf) return !1; var d = Nf.diagram; c instanceof P || (c = null); var e = $f; c !== e && (null !== e && e !== d && (e.yf(), Nf.isDragOutStarted = !1, e = e.toolManager.findTool("Dragging"), null !== e && e.doSimulatedDragLeave()), $f = c, null !== c && c !== d && (jg(), e = c.toolManager.findTool("Dragging"), null !== e && (eg.contains(e) || eg.add(e), e.doSimulatedDragEnter()))); if (null === c || c === d || !c.allowDrop || c.isReadOnly || !c.allowInsert) return !1; d = c.toolManager.findTool("Dragging"); null !== d && (null !==
            a ? (void 0 !== a.targetTouches && (0 < a.targetTouches.length ? a = a.targetTouches[0] : 0 < a.changedTouches.length && (a = a.changedTouches[0])), b = c.getMouse(a)) : null === b && (b = new J), c.lastInput.documentPoint = b, c.lastInput.viewPoint = c.Ct(b), c.lastInput.down = !1, c.lastInput.up = !1, d.doSimulatedDragOver()); return !0
    };
    Kf.prototype.simulatedMouseUp = function (a, b, c, d) {
        if (null === Nf) return !1; null === d && (d = b); b = $f; var e = Nf.diagram; if (d !== b) { var f = b.toolManager.findTool("Dragging"); if (null !== b && b !== e && null !== f) return b.yf(), Nf.isDragOutStarted = !1, f.doSimulatedDragLeave(), !1; $f = d; b = d.toolManager.findTool("Dragging"); null !== d && null !== b && (jg(), eg.contains(b) || eg.add(b), b.doSimulatedDragEnter()) } return null === d ? (Nf.doCancel(), !0) : d !== this.diagram ? (null !== a ? (void 0 !== a.targetTouches && (0 < a.targetTouches.length ? a = a.targetTouches[0] :
            0 < a.changedTouches.length && (a = a.changedTouches[0])), c = d.getMouse(a)) : null === c && (c = new J), d.lastInput.documentPoint = c, d.lastInput.viewPoint = d.Ct(c), d.lastInput.down = !1, d.lastInput.up = !0, a = d.toolManager.findTool("Dragging"), null !== a && a.doSimulatedDrop(), a = Nf, null !== a && (d = a.mayCopy(), a.transactionResult = d ? "Copy" : "Move", a.stopTool()), !0) : !1
    };
    Kf.prototype.mayCopy = function () { if (!this.isCopyEnabled) return !1; var a = this.diagram; if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowCopy || (kb ? !a.lastInput.alt : !a.lastInput.control)) return !1; for (a = a.selection.iterator; a.next();) { var b = a.value; if (b.dc() && b.canCopy()) return !0 } return null !== this.draggedLink && this.dragsLink && this.draggedLink.canCopy() ? !0 : !1 };
    Kf.prototype.mayDragOut = function () { if (!this.isCopyEnabled) return !1; var a = this.diagram; if (!a.allowDragOut || !a.allowCopy || a.allowMove) return !1; for (a = a.selection.iterator; a.next();) { var b = a.value; if (b.dc() && b.canCopy()) return !0 } return null !== this.draggedLink && this.dragsLink && this.draggedLink.canCopy() ? !0 : !1 };
    Kf.prototype.mayMove = function () { var a = this.diagram; if (a.isReadOnly || !a.allowMove) return !1; for (a = a.selection.iterator; a.next();) { var b = a.value; if (b.dc() && b.canMove()) return !0 } return null !== this.draggedLink && this.dragsLink && this.draggedLink.canMove() ? !0 : !1 }; Kf.prototype.computeBorder = function (a, b, c) { return this.Cn || null === this.draggedParts || this.draggedParts.contains(a) ? null : c.assign(b) }; Kf.prototype.jz = function () { return Nf };
    Kf.prototype.mayDragIn = function () { var a = this.diagram; if (!a.allowDrop || a.isReadOnly || a.isModelReadOnly || !a.allowInsert) return !1; var b = Nf; return null === b || b.diagram.model.dataFormat !== a.model.dataFormat ? !1 : !0 }; Kf.prototype.doSimulatedDragEnter = function () { if (this.mayDragIn()) { var a = this.diagram; a.animationManager.xd(); Eg(a); a.animationManager.xd(); a = Nf; null !== a && (a.diagram.currentCursor = "copy", a.diagram.Yi = !1) } }; Kf.prototype.doSimulatedDragLeave = function () { var a = Nf; null !== a && a.doSimulatedDragOut(); this.doCancel() };
    Kf.prototype.doSimulatedDragOver = function () { var a = this.diagram, b = Nf; null !== b && null !== b.draggedParts && this.mayDragIn() && (a.currentCursor = "copy", Fg(this, b.draggedParts.$d(), !1, a.firstInput), og(this, this.copiedParts, !1), tg(this, a.lastInput.documentPoint)) };
    Kf.prototype.doSimulatedDrop = function () { var a = this.diagram, b = Nf; if (null !== b) { var c = b.diagram; b.Cn = !0; gg(this); this.mayDragIn() && (this.Ca("Drop"), Fg(this, b.draggedParts.$d(), !0, a.lastInput), og(this, this.copiedParts, !1), null !== this.copiedParts && a.Nv(this.copiedParts.$d()), Ag(this, a.lastInput.documentPoint), a.Ya(), b = a.selection, null !== this.copiedParts ? this.transactionResult = "ExternalCopy" : b = new I, this.copiedParts = null, a.doFocus(), a.ba("ExternalObjectsDropped", b, c), this.yg()) } };
    function Fg(a, b, c, d) {
        if (null === a.copiedParts) {
            var e = a.diagram; if (!e.isReadOnly && !e.isModelReadOnly) {
            e.skipsUndoManager = !c; e.partManager.addsToTemporaryLayer = !c; a.startPoint = d.documentPoint; c = e.ak(b, e, !0); var f = L.alloc(); lg(b, f); d = f.x + f.width / 2; e = f.y + f.height / 2; L.free(f); f = a.Ds; var g = new Ub, h = J.alloc(); for (b = b.iterator; b.next();) {
                var k = b.value, l = c.K(k); k.dc() && k.canCopy() ? (k = k.location, h.h(f.x - (d - k.x), f.y - (e - k.y)), l.location = h, l.bc(), g.add(l, a.rd(h))) : l instanceof Q && k.canCopy() && (ng(l, f.x - d, f.y - e),
                    g.add(l, a.rd()))
            } J.free(h); a.copiedParts = g; Of(a, g.$d()); null !== a.draggedLink && (c = a.draggedLink, d = c.routeBounds, ng(c, a.startPoint.x - (d.x + d.width / 2), a.startPoint.y - (d.y + d.height / 2)))
            }
        }
    } Kf.prototype.doSimulatedDragOut = function () { var a = this.diagram; a.Yi = !1; this.mayCopy() || this.mayMove() ? a.currentCursor = "" : a.currentCursor = "no-drop" }; Kf.prototype.computeMove = function (a, b, c, d) { c = this.diagram; return null !== c ? c.computeMove(a, b, this.dragOptions, d) : new J };
    na.Object.defineProperties(Kf.prototype, {
        isCopyEnabled: { configurable: !0, get: function () { return this.Nc }, set: function (a) { z(a, "boolean", Kf, "isCopyEnabled"); this.Nc = a } }, copiesEffectiveCollection: { configurable: !0, get: function () { return this.L }, set: function (a) { z(a, "boolean", Kf, "copiesEffectiveCollection"); this.L = a } }, dragOptions: { configurable: !0, get: function () { return this.Ma }, set: function (a) { w(a, Lf, Kf, "dragOptions"); this.Ma = a } }, isGridSnapEnabled: {
            configurable: !0,
            enumerable: !0, get: function () { return this.dragOptions.isGridSnapEnabled }, set: function (a) { z(a, "boolean", Kf, "isGridSnapEnabled"); this.dragOptions.isGridSnapEnabled = a }
        }, isComplexRoutingRealtime: { configurable: !0, get: function () { return this.Xb }, set: function (a) { z(a, "boolean", Kf, "isComplexRoutingRealtime"); this.Xb = a } }, isGridSnapRealtime: {
            configurable: !0, get: function () { return this.dragOptions.isGridSnapRealtime }, set: function (a) {
                z(a, "boolean", Kf, "isGridSnapRealtime"); this.dragOptions.isGridSnapRealtime =
                    a
            }
        }, gridSnapCellSize: { configurable: !0, get: function () { return this.dragOptions.gridSnapCellSize }, set: function (a) { w(a, Zb, Kf, "gridSnapCellSize"); null === this.diagram || this.dragOptions.gridSnapCellSize.A(a) || (a = a.J(), this.dragOptions.gridSnapCellSize = a) } }, gridSnapCellSpot: { configurable: !0, get: function () { return this.dragOptions.gridSnapCellSpot }, set: function (a) { w(a, M, Kf, "gridSnapCellSpot"); this.dragOptions.gridSnapCellSpot.A(a) || (a = a.J(), this.dragOptions.gridSnapCellSpot = a) } },
        gridSnapOrigin: { configurable: !0, get: function () { return this.dragOptions.gridSnapOrigin }, set: function (a) { w(a, J, Kf, "gridSnapOrigin"); this.dragOptions.gridSnapOrigin.A(a) || (a = a.J(), this.dragOptions.gridSnapOrigin = a) } }, dragsLink: { configurable: !0, get: function () { return this.dragOptions.dragsLink }, set: function (a) { z(a, "boolean", Kf, "dragsLink"); this.dragOptions.dragsLink = a } }, dragsTree: {
            configurable: !0, get: function () { return this.dragOptions.dragsTree }, set: function (a) {
                z(a,
                    "boolean", Kf, "dragsTree"); this.dragOptions.dragsTree = a
            }
        }, currentPart: { configurable: !0, get: function () { return this.ca }, set: function (a) { null !== a && w(a, R, Kf, "currentPart"); this.ca = a } }, copiedParts: { configurable: !0, get: function () { return this.w }, set: function (a) { this.w = a } }, draggedParts: { configurable: !0, get: function () { return this.Na }, set: function (a) { this.Na = a } }, draggingParts: {
            configurable: !0, get: function () {
                return null !== this.copiedParts ? this.copiedParts.$d() :
                    null !== this.draggedParts ? this.draggedParts.$d() : this.zg
            }
        }, draggedLink: { configurable: !0, get: function () { return this.diagram.draggedLink }, set: function (a) { null !== a && w(a, Q, Kf, "draggedLink"); this.diagram.draggedLink = a } }, isDragOutStarted: { configurable: !0, get: function () { return this.Oc }, set: function (a) { this.Oc = a } }, startPoint: { configurable: !0, get: function () { return this.Ds }, set: function (a) { w(a, J, Kf, "startPoint"); this.Ds.A(a) || this.Ds.assign(a) } }, delay: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Uk }, set: function (a) { z(a, "number", Kf, "delay"); this.Uk = a }
        }
    }); Kf.prototype.getDraggingSource = Kf.prototype.jz; var eg = null, Nf = null, $f = null; Kf.className = "DraggingTool"; eg = new F; Za("draggingTool", function () { return this.findTool("Dragging") }, function (a) { If(this, "Dragging", a, this.mouseMoveTools) }); $a.prototype.doCancel = function () { null !== Nf && Nf.doCancel(); vf.prototype.doCancel.call(this) };
    function Gg() {
    0 < arguments.length && Da(Gg); vf.call(this); this.zg = 100; this.ca = !1; var a = new Q, b = new Hg; b.isPanelMain = !0; b.stroke = "blue"; a.add(b); b = new Hg; b.toArrow = "Standard"; b.fill = "blue"; b.stroke = "blue"; a.add(b); a.layerName = "Tool"; this.Km = a; a = new V; b = new Hg; b.portId = ""; b.figure = "Rectangle"; b.fill = null; b.stroke = "magenta"; b.strokeWidth = 2; b.desiredSize = sc; a.add(b); a.selectable = !1; a.layerName = "Tool"; this.Im = a; this.Jm = b; a = new V; b = new Hg; b.portId = ""; b.figure = "Rectangle"; b.fill = null; b.stroke = "magenta"; b.strokeWidth =
        2; b.desiredSize = sc; a.add(b); a.selectable = !1; a.layerName = "Tool"; this.Gq = a; this.Hq = b; this.Oc = this.Nc = this.Na = this.Ma = this.Xb = null; this.L = !0; this.Wx = new Ub; this.Gm = this.ki = this.Hm = null
    } ma(Gg, vf); Gg.prototype.doStop = function () { this.diagram.yf(); this.originalToPort = this.originalToNode = this.originalFromPort = this.originalFromNode = this.originalLink = null; this.validPortsCache.clear(); this.targetPort = null };
    Gg.prototype.copyPortProperties = function (a, b, c, d, e) { if (null !== a && null !== b && null !== c && null !== d) { var f = b.Fe(), g = Zb.alloc(); g.width = b.naturalBounds.width * f; g.height = b.naturalBounds.height * f; d.desiredSize = g; Zb.free(g); e ? (d.toSpot = b.toSpot, d.toEndSegmentLength = b.toEndSegmentLength) : (d.fromSpot = b.fromSpot, d.fromEndSegmentLength = b.fromEndSegmentLength); c.locationSpot = qd; f = J.alloc(); c.location = b.oa(qd, f); J.free(f); d.angle = b.Ni(); null !== this.portTargeted && this.portTargeted(a, b, c, d, e) } };
    Gg.prototype.setNoTargetPortProperties = function (a, b, c) { null !== b && (b.desiredSize = sc, b.fromSpot = ed, b.toSpot = ed); null !== a && (a.location = this.diagram.lastInput.documentPoint); null !== this.portTargeted && this.portTargeted(null, null, a, b, c) }; Gg.prototype.doMouseDown = function () { this.isActive && this.doMouseMove() };
    Gg.prototype.doMouseMove = function () {
        if (this.isActive) {
            var a = this.diagram; this.targetPort = this.findTargetPort(this.isForwards); if (null !== this.targetPort && this.targetPort.part instanceof V) { var b = this.targetPort.part; this.isForwards ? this.copyPortProperties(b, this.targetPort, this.temporaryToNode, this.temporaryToPort, !0) : this.copyPortProperties(b, this.targetPort, this.temporaryFromNode, this.temporaryFromPort, !1) } else this.isForwards ? this.setNoTargetPortProperties(this.temporaryToNode, this.temporaryToPort,
                !0) : this.setNoTargetPortProperties(this.temporaryFromNode, this.temporaryFromPort, !1); (a.allowHorizontalScroll || a.allowVerticalScroll) && a.Ts(a.lastInput.viewPoint)
        }
    }; Gg.prototype.findValidLinkablePort = function (a, b) { if (null === a) return null; var c = a.part; if (!(c instanceof V)) return null; for (; null !== a;) { var d = b ? a.toLinkable : a.fromLinkable; if (!0 === d && (null !== a.portId || a instanceof V) && (b ? this.isValidTo(c, a) : this.isValidFrom(c, a))) return a; if (!1 === d) break; a = a.panel } return null };
    Gg.prototype.findTargetPort = function (a) {
        var b = this.diagram, c = b.lastInput.documentPoint, d = this.portGravity; 0 >= d && (d = .1); var e = this, f = b.qg(c, d, function (b) { return e.findValidLinkablePort(b, a) }, null, !0); d = Infinity; b = null; for (f = f.iterator; f.next();) {
            var g = f.value, h = g.part; if (h instanceof V) {
                var k = g.oa(qd, J.alloc()), l = c.x - k.x, m = c.y - k.y; J.free(k); k = l * l + m * m; k < d && (l = this.validPortsCache.K(g), null !== l ? l && (b = g, d = k) : a && this.isValidLink(this.originalFromNode, this.originalFromPort, h, g) || !a && this.isValidLink(h,
                    g, this.originalToNode, this.originalToPort) ? (this.validPortsCache.add(g, !0), b = g, d = k) : this.validPortsCache.add(g, !1))
            }
        } return null !== b && (c = b.part, c instanceof V && (null === c.layer || c.layer.allowLink)) ? b : null
    };
    Gg.prototype.isValidFrom = function (a, b) { if (null === a || null === b) return this.isUnconnectedLinkValid; if (this.diagram.currentTool === this && (null !== a.layer && !a.layer.allowLink || !0 !== b.fromLinkable)) return !1; var c = b.fromMaxLinks; if (Infinity > c) { if (null !== this.originalLink && a === this.originalFromNode && b === this.originalFromPort) return !0; b = b.portId; null === b && (b = ""); if (a.aq(b).count >= c) return !1 } return !0 };
    Gg.prototype.isValidTo = function (a, b) { if (null === a || null === b) return this.isUnconnectedLinkValid; if (this.diagram.currentTool === this && (null !== a.layer && !a.layer.allowLink || !0 !== b.toLinkable)) return !1; var c = b.toMaxLinks; if (Infinity > c) { if (null !== this.originalLink && a === this.originalToNode && b === this.originalToPort) return !0; b = b.portId; null === b && (b = ""); if (a.ud(b).count >= c) return !1 } return !0 };
    Gg.prototype.isInSameNode = function (a, b) { if (null === a || null === b) return !1; if (a === b) return !0; a = a.part; b = b.part; return null !== a && a === b }; Gg.prototype.isLinked = function (a, b) { if (null === a || null === b) return !1; var c = a.part; if (!(c instanceof V)) return !1; a = a.portId; null === a && (a = ""); var d = b.part; if (!(d instanceof V)) return !1; b = b.portId; null === b && (b = ""); for (b = d.ud(b); b.next();)if (d = b.value, d.fromNode === c && d.fromPortId === a) return !0; return !1 };
    Gg.prototype.isValidLink = function (a, b, c, d) {
        if (!this.isValidFrom(a, b) || !this.isValidTo(c, d) || !(null === b || null === d || (b.fromLinkableSelfNode && d.toLinkableSelfNode || !this.isInSameNode(b, d)) && (b.fromLinkableDuplicates && d.toLinkableDuplicates || !this.isLinked(b, d))) || null !== this.originalLink && (null !== a && this.isLabelDependentOnLink(a, this.originalLink) || null !== c && this.isLabelDependentOnLink(c, this.originalLink)) || null !== a && null !== c && (null === a.data && null !== c.data || null !== a.data && null === c.data) || !this.isValidCycle(a,
            c, this.originalLink)) return !1; if (null !== a) { var e = a.linkValidation; if (null !== e && !e(a, b, c, d, this.originalLink)) return !1 } if (null !== c && (e = c.linkValidation, null !== e && !e(a, b, c, d, this.originalLink))) return !1; e = this.linkValidation; return null !== e ? e(a, b, c, d, this.originalLink) : !0
    }; Gg.prototype.isLabelDependentOnLink = function (a, b) { if (null === a) return !1; var c = a.labeledLink; if (null === c) return !1; if (c === b) return !0; var d = new I; d.add(a); return Ig(this, c, b, d) };
    function Ig(a, b, c, d) { if (b === c) return !0; var e = b.fromNode; if (null !== e && e.isLinkLabel && (d.add(e), Ig(a, e.labeledLink, c, d))) return !0; b = b.toNode; return null !== b && b.isLinkLabel && (d.add(b), Ig(a, b.labeledLink, c, d)) ? !0 : !1 }
    Gg.prototype.isValidCycle = function (a, b, c) {
    void 0 === c && (c = null); if (null === a || null === b) return this.isUnconnectedLinkValid; var d = this.diagram.validCycle; if (d !== Jg) {
        if (d === Kg) { d = c || this.temporaryLink; if (null !== d && !d.isTreeLink) return !0; for (d = b.linksConnected; d.next();) { var e = d.value; if (e !== c && e.isTreeLink && e.toNode === b) return !1 } return !Lg(this, a, b, c, !0) } if (d === Mg) {
            d = c || this.temporaryLink; if (null !== d && !d.isTreeLink) return !0; for (d = a.linksConnected; d.next();)if (e = d.value, e !== c && e.isTreeLink && e.fromNode ===
                a) return !1; return !Lg(this, a, b, c, !0)
        } if (d === Ng) return a === b ? a = !0 : (d = new I, d.add(b), a = Og(this, d, a, b, c)), !a; if (d === Pg) return !Lg(this, a, b, c, !1); if (d === Qg) return a === b ? a = !0 : (d = new I, d.add(b), a = Rg(this, d, a, b, c)), !a
    } return !0
    }; function Lg(a, b, c, d, e) { if (b === c) return !0; if (null === b || null === c) return !1; for (var f = b.linksConnected; f.next();) { var g = f.value; if (g !== d && (!e || g.isTreeLink) && g.toNode === b && (g = g.fromNode, g !== b && Lg(a, g, c, d, e))) return !0 } return !1 }
    function Og(a, b, c, d, e) { if (c === d) return !0; if (null === c || null === d || b.contains(c)) return !1; b.add(c); for (var f = c.linksConnected; f.next();) { var g = f.value; if (g !== e && g.toNode === c && (g = g.fromNode, g !== c && Og(a, b, g, d, e))) return !0 } return !1 } function Rg(a, b, c, d, e) { if (c === d) return !0; if (null === c || null === d || b.contains(c)) return !1; b.add(c); for (var f = c.linksConnected; f.next();) { var g = f.value; if (g !== e) { var h = g.fromNode; g = g.toNode; h = h === c ? g : h; if (h !== c && Rg(a, b, h, d, e)) return !0 } } return !1 }
    na.Object.defineProperties(Gg.prototype, {
        portGravity: { configurable: !0, get: function () { return this.zg }, set: function (a) { z(a, "number", Gg, "portGravity"); 0 <= a && (this.zg = a) } }, isUnconnectedLinkValid: { configurable: !0, get: function () { return this.ca }, set: function (a) { z(a, "boolean", Gg, "isUnconnectedLinkValid"); this.ca = a } }, temporaryLink: { configurable: !0, get: function () { return this.Km }, set: function (a) { w(a, Q, Gg, "temporaryLink"); this.Km = a } }, temporaryFromNode: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Im }, set: function (a) { w(a, V, Gg, "temporaryFromNode"); this.Im = a }
        }, temporaryFromPort: { configurable: !0, get: function () { return this.Jm }, set: function (a) { w(a, N, Gg, "temporaryFromPort"); this.Jm = a } }, temporaryToNode: { configurable: !0, get: function () { return this.Gq }, set: function (a) { w(a, V, Gg, "temporaryToNode"); this.Gq = a } }, temporaryToPort: {
            configurable: !0, get: function () { return this.Hq }, set: function (a) {
                w(a, N, Gg, "temporaryToPort"); this.Hq =
                    a
            }
        }, originalLink: { configurable: !0, get: function () { return this.Xb }, set: function (a) { null !== a && w(a, Q, Gg, "originalLink"); this.Xb = a } }, originalFromNode: { configurable: !0, get: function () { return this.Ma }, set: function (a) { null !== a && w(a, V, Gg, "originalFromNode"); this.Ma = a } }, originalFromPort: { configurable: !0, get: function () { return this.Na }, set: function (a) { null !== a && w(a, N, Gg, "originalFromPort"); this.Na = a } }, originalToNode: {
            configurable: !0, get: function () { return this.Nc },
            set: function (a) { null !== a && w(a, V, Gg, "originalToNode"); this.Nc = a }
        }, originalToPort: { configurable: !0, get: function () { return this.Oc }, set: function (a) { null !== a && w(a, N, Gg, "originalToPort"); this.Oc = a } }, isForwards: { configurable: !0, get: function () { return this.L }, set: function (a) { z(a, "boolean", Gg, "isForwards"); this.L = a } }, validPortsCache: { configurable: !0, get: function () { return this.Wx } }, targetPort: {
            configurable: !0, get: function () { return this.Hm }, set: function (a) {
            null !==
                a && w(a, N, Gg, "targetPort"); this.Hm = a
            }
        }, linkValidation: { configurable: !0, get: function () { return this.ki }, set: function (a) { null !== a && z(a, "function", Gg, "linkValidation"); this.ki = a } }, portTargeted: { configurable: !0, get: function () { return this.Gm }, set: function (a) { null !== a && z(a, "function", Gg, "portTargeted"); this.Gm = a } }
    }); Gg.className = "LinkingBaseTool"; function Sg() { 0 < arguments.length && Da(Sg); Gg.call(this); this.name = "Linking"; this.w = {}; this.l = null; this.M = Tg; this.Eh = null } ma(Sg, Gg);
    Sg.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; return a.isReadOnly || a.isModelReadOnly || !a.allowLink || !a.model.jt() || !a.lastInput.left || a.currentTool !== this && !this.isBeyondDragSize() ? !1 : null !== this.findLinkablePort() };
    Sg.prototype.findLinkablePort = function () { var a = this.diagram, b = this.startObject; null === b && (b = a.Tb(a.firstInput.documentPoint, null, null)); if (null === b || !(b.part instanceof V)) return null; a = this.direction; if (a === Tg || a === Ug) { var c = this.findValidLinkablePort(b, !1); if (null !== c) return this.isForwards = !0, c } if (a === Tg || a === $g) if (b = this.findValidLinkablePort(b, !0), null !== b) return this.isForwards = !1, b; return null };
    Sg.prototype.doActivate = function () {
        var a = this.diagram, b = this.findLinkablePort(); null !== b && (this.Ca(this.name), a.isMouseCaptured = !0, a.currentCursor = "pointer", this.isForwards ? (null === this.temporaryToNode || this.temporaryToNode.location.o() || (this.temporaryToNode.location = a.lastInput.documentPoint), this.originalFromPort = b, b = this.originalFromPort.part, b instanceof V && (this.originalFromNode = b), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort,
            !1)) : (null === this.temporaryFromNode || this.temporaryFromNode.location.o() || (this.temporaryFromNode.location = a.lastInput.documentPoint), this.originalToPort = b, b = this.originalToPort.part, b instanceof V && (this.originalToNode = b), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0)), a.add(this.temporaryFromNode), a.add(this.temporaryToNode), null !== this.temporaryLink && (null !== this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode),
                null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.temporaryLink.isTreeLink = this.isNewTreeLink(), this.temporaryLink.Ta(), a.add(this.temporaryLink)), this.isActive = !0)
    }; Sg.prototype.doDeactivate = function () { this.isActive = !1; var a = this.diagram; a.remove(this.temporaryLink); a.remove(this.temporaryFromNode); a.remove(this.temporaryToNode); a.isMouseCaptured = !1; a.currentCursor = ""; this.yg() }; Sg.prototype.doStop = function () { Gg.prototype.doStop.call(this); this.startObject = null };
    Sg.prototype.doMouseUp = function () {
        if (this.isActive) {
            var a = this.diagram, b = this.transactionResult = null, c = null, d = null, e = null, f = this.targetPort = this.findTargetPort(this.isForwards); if (null !== f) { var g = f.part; g instanceof V && (this.isForwards ? (null !== this.originalFromNode && (b = this.originalFromNode, c = this.originalFromPort), d = g, e = f) : (b = g, c = f, null !== this.originalToNode && (d = this.originalToNode, e = this.originalToPort))) } else this.isForwards ? null !== this.originalFromNode && this.isUnconnectedLinkValid && (b = this.originalFromNode,
                c = this.originalFromPort) : null !== this.originalToNode && this.isUnconnectedLinkValid && (d = this.originalToNode, e = this.originalToPort); null !== b || null !== d ? (g = this.insertLink(b, c, d, e), null !== g ? (null === f && (this.isForwards ? g.defaultToPoint = a.lastInput.documentPoint : g.defaultFromPoint = a.lastInput.documentPoint), a.allowSelect && a.select(g), this.transactionResult = this.name, a.ba("LinkDrawn", g)) : (a.model.Ru(), this.doNoLink(b, c, d, e))) : this.isForwards ? this.doNoLink(this.originalFromNode, this.originalFromPort, null, null) :
                    this.doNoLink(null, null, this.originalToNode, this.originalToPort)
        } this.stopTool()
    }; Sg.prototype.isNewTreeLink = function () { var a = this.archetypeLinkData; if (null === a) return !0; if (a instanceof Q) return a.isTreeLink; var b = this.diagram; if (null === b) return !0; a = b.partManager.getLinkCategoryForData(a); b = b.partManager.findLinkTemplateForCategory(a); return null !== b ? b.isTreeLink : !0 }; Sg.prototype.insertLink = function (a, b, c, d) { return this.diagram.partManager.insertLink(a, b, c, d) }; Sg.prototype.doNoLink = function () { };
    na.Object.defineProperties(Sg.prototype, {
        archetypeLinkData: { configurable: !0, get: function () { return this.w }, set: function (a) { null !== a && z(a, "object", Sg, "archetypeLinkData"); a instanceof N && w(a, Q, Sg, "archetypeLinkData"); this.w = a } }, archetypeLabelNodeData: { configurable: !0, get: function () { return this.l }, set: function (a) { null !== a && z(a, "object", Sg, "archetypeLabelNodeData"); a instanceof N && w(a, V, Sg, "archetypeLabelNodeData"); this.l = a } }, direction: {
            configurable: !0, get: function () { return this.M },
            set: function (a) { tb(a, Sg, Sg, "direction"); this.M = a }
        }, startObject: { configurable: !0, get: function () { return this.Eh }, set: function (a) { null !== a && w(a, N, Sg, "startObject"); this.Eh = a } }
    }); var Tg = new D(Sg, "Either", 0), Ug = new D(Sg, "ForwardsOnly", 0), $g = new D(Sg, "BackwardsOnly", 0); Sg.className = "LinkingTool"; Sg.Either = Tg; Sg.ForwardsOnly = Ug; Sg.BackwardsOnly = $g;
    function ag() { 0 < arguments.length && Da(ag); Gg.call(this); this.name = "Relinking"; var a = new Hg; a.figure = "Diamond"; a.desiredSize = uc; a.fill = "lightblue"; a.stroke = "dodgerblue"; a.cursor = "pointer"; a.segmentIndex = 0; this.w = a; a = new Hg; a.figure = "Diamond"; a.desiredSize = uc; a.fill = "lightblue"; a.stroke = "dodgerblue"; a.cursor = "pointer"; a.segmentIndex = -1; this.Eh = a; this.l = null; this.Mw = new L } ma(ag, Gg);
    ag.prototype.updateAdornments = function (a) {
        if (null !== a && a instanceof Q) {
            var b = "RelinkFrom", c = null; if (a.isSelected && !this.diagram.isReadOnly) { var d = a.selectionObject; null !== d && a.canRelinkFrom() && a.actualBounds.o() && a.isVisible() && d.actualBounds.o() && d.uf() && (c = a.dk(b), null === c && (c = this.makeAdornment(d, !1), a.qh(b, c))) } null === c && a.wf(b); b = "RelinkTo"; c = null; a.isSelected && !this.diagram.isReadOnly && (d = a.selectionObject, null !== d && a.canRelinkTo() && a.actualBounds.o() && a.isVisible() && d.actualBounds.o() && d.uf() &&
                (c = a.dk(b), null === c ? (c = this.makeAdornment(d, !0), a.qh(b, c)) : c.v())); null === c && a.wf(b)
        }
    }; ag.prototype.makeAdornment = function (a, b) { var c = new Cf; c.type = W.Link; b = b ? this.toHandleArchetype : this.fromHandleArchetype; null !== b && c.add(b.copy()); c.adornedObject = a; return c };
    ag.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; if (a.isReadOnly || a.isModelReadOnly || !a.allowRelink || !a.model.jt() || !a.lastInput.left) return !1; var b = this.findToolHandleAt(a.firstInput.documentPoint, "RelinkFrom"); null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, "RelinkTo")); return null !== b };
    ag.prototype.doActivate = function () {
        var a = this.diagram; if (null === this.originalLink) { var b = this.handle; null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, "RelinkFrom"), null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, "RelinkTo"))); if (null === b) return; var c = b.part; if (!(c instanceof Cf && c.adornedPart instanceof Q)) return; this.handle = b; this.isForwards = null === c || "RelinkTo" === c.category; this.originalLink = c.adornedPart } this.Ca(this.name); a.isMouseCaptured = !0; a.currentCursor = "pointer";
        this.originalFromPort = this.originalLink.fromPort; this.originalFromNode = this.originalLink.fromNode; this.originalToPort = this.originalLink.toPort; this.originalToNode = this.originalLink.toNode; this.Mw.set(this.originalLink.actualBounds); null !== this.originalLink && 0 < this.originalLink.pointsCount && (null === this.originalLink.fromNode && (null !== this.temporaryFromPort && (this.temporaryFromPort.desiredSize = rc), null !== this.temporaryFromNode && (this.temporaryFromNode.location = this.originalLink.i(0))), null === this.originalLink.toNode &&
            (null !== this.temporaryToPort && (this.temporaryToPort.desiredSize = rc), null !== this.temporaryToNode && (this.temporaryToNode.location = this.originalLink.i(this.originalLink.pointsCount - 1)))); this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, !1); this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0); a.add(this.temporaryFromNode); a.add(this.temporaryToNode); null !== this.temporaryLink && (null !==
                this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode), null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.copyLinkProperties(this.originalLink, this.temporaryLink), this.temporaryLink.Ta(), a.add(this.temporaryLink)); this.isActive = !0
    };
    ag.prototype.copyLinkProperties = function (a, b) { if (null !== a && null !== b) { b.adjusting = a.adjusting; b.corner = a.corner; var c = a.curve; if (c === ah || c === bh) c = ch; b.curve = c; b.curviness = a.curviness; b.isTreeLink = a.isTreeLink; b.points = a.points; b.routing = a.routing; b.smoothness = a.smoothness; b.fromSpot = a.fromSpot; b.fromEndSegmentLength = a.fromEndSegmentLength; b.fromShortLength = a.fromShortLength; b.toSpot = a.toSpot; b.toEndSegmentLength = a.toEndSegmentLength; b.toShortLength = a.toShortLength } };
    ag.prototype.doDeactivate = function () { this.isActive = !1; var a = this.diagram; a.remove(this.temporaryLink); a.remove(this.temporaryFromNode); a.remove(this.temporaryToNode); a.isMouseCaptured = !1; a.currentCursor = ""; this.yg() }; ag.prototype.doStop = function () { Gg.prototype.doStop.call(this); this.handle = null };
    ag.prototype.doMouseUp = function () {
        if (this.isActive) {
            var a = this.diagram; this.transactionResult = null; var b = this.originalFromNode, c = this.originalFromPort, d = this.originalToNode, e = this.originalToPort, f = this.originalLink; this.targetPort = this.findTargetPort(this.isForwards); if (null !== this.targetPort) { var g = this.targetPort.part; g instanceof V && (this.isForwards ? (d = g, e = this.targetPort) : (b = g, c = this.targetPort)) } else this.isUnconnectedLinkValid ? this.isForwards ? e = d = null : c = b = null : f = null; null !== f ? (this.reconnectLink(f,
                this.isForwards ? d : b, this.isForwards ? e : c, this.isForwards), null === this.targetPort && (this.isForwards ? f.defaultToPoint = a.lastInput.documentPoint : f.defaultFromPoint = a.lastInput.documentPoint, f.Ta()), a.allowSelect && (f.isSelected = !0), this.transactionResult = this.name, a.ba("LinkRelinked", f, this.isForwards ? this.originalToPort : this.originalFromPort)) : this.doNoRelink(this.originalLink, this.isForwards); this.originalLink.jq(this.Mw)
        } this.stopTool()
    };
    ag.prototype.reconnectLink = function (a, b, c, d) { c = null !== c && null !== c.portId ? c.portId : ""; d ? (a.toNode = b, a.toPortId = c) : (a.fromNode = b, a.fromPortId = c); return !0 }; ag.prototype.doNoRelink = function () { };
    function zg(a, b, c, d, e) { null !== b ? (a.copyPortProperties(b, c, a.temporaryFromNode, a.temporaryFromPort, !1), a.diagram.add(a.temporaryFromNode)) : a.diagram.remove(a.temporaryFromNode); null !== d ? (a.copyPortProperties(d, e, a.temporaryToNode, a.temporaryToPort, !0), a.diagram.add(a.temporaryToNode)) : a.diagram.remove(a.temporaryToNode) }
    na.Object.defineProperties(ag.prototype, {
        fromHandleArchetype: { configurable: !0, get: function () { return this.w }, set: function (a) { null !== a && w(a, N, ag, "fromHandleArchetype"); this.w = a } }, toHandleArchetype: { configurable: !0, get: function () { return this.Eh }, set: function (a) { null !== a && w(a, N, ag, "toHandleArchetype"); this.Eh = a } }, handle: {
            configurable: !0, get: function () { return this.l }, set: function (a) {
                if (null !== a && (w(a, N, ag, "handle"), !(a.part instanceof Cf))) throw Error("new handle is not in an Adornment: " +
                    a); this.l = a
            }
        }
    }); ag.className = "RelinkingTool"; Za("linkingTool", function () { return this.findTool("Linking") }, function (a) { If(this, "Linking", a, this.mouseMoveTools) }); Za("relinkingTool", function () { return this.findTool("Relinking") }, function (a) { If(this, "Relinking", a, this.mouseDownTools) });
    function dh() { 0 < arguments.length && Da(dh); vf.call(this); this.name = "LinkReshaping"; var a = new Hg; a.figure = "Rectangle"; a.desiredSize = tc; a.fill = "lightblue"; a.stroke = "dodgerblue"; this.w = a; a = new Hg; a.figure = "Diamond"; a.desiredSize = uc; a.fill = "lightblue"; a.stroke = "dodgerblue"; a.cursor = "move"; this.L = a; this.ca = 3; this.Mt = this.l = null; this.yl = new J; this.ls = new F } ma(dh, vf); dh.prototype.lv = function (a) { return a && a.qs && 0 !== a.qs.value ? a.qs : eh };
    dh.prototype.Bm = function (a, b) { w(a, N, dh, "setReshapingBehavior:obj"); tb(b, dh, dh, "setReshapingBehavior:behavior"); a.qs = b };
    dh.prototype.updateAdornments = function (a) { if (null !== a && a instanceof Q) { var b = null; if (a.isSelected && !this.diagram.isReadOnly) { var c = a.path; null !== c && a.canReshape() && a.actualBounds.o() && a.isVisible() && c.actualBounds.o() && c.uf() && (b = a.dk(this.name), null === b || b.Jw !== a.pointsCount || b.Uw !== a.resegmentable) && (b = this.makeAdornment(c), null !== b && (b.Jw = a.pointsCount, b.Uw = a.resegmentable, a.qh(this.name, b))) } null === b && a.wf(this.name) } };
    dh.prototype.makeAdornment = function (a) {
        var b = a.part, c = b.pointsCount, d = b.isOrthogonal, e = null; if (null !== b.points && 1 < c) {
            e = new Cf; e.type = W.Link; c = b.firstPickIndex; var f = b.lastPickIndex, g = d ? 1 : 0; if (b.resegmentable && b.computeCurve() !== fh) for (var h = c + g; h < f - g; h++) { var k = this.makeResegmentHandle(a, h); null !== k && (k.segmentIndex = h, k.segmentFraction = .5, k.fromMaxLinks = 999, e.add(k)) } for (g = c + 1; g < f; g++)if (h = this.makeHandle(a, g), null !== h) {
            h.segmentIndex = g; if (g !== c) if (g === c + 1 && d) {
                k = b.i(c); var l = b.i(c + 1); K.B(k.x, l.x) &&
                    K.B(k.y, l.y) && (l = b.i(c - 1)); K.B(k.x, l.x) ? (this.Bm(h, gh), h.cursor = "n-resize") : K.B(k.y, l.y) && (this.Bm(h, hh), h.cursor = "w-resize")
            } else g === f - 1 && d ? (k = b.i(f - 1), l = b.i(f), K.B(k.x, l.x) && K.B(k.y, l.y) && (k = b.i(f + 1)), K.B(k.x, l.x) ? (this.Bm(h, gh), h.cursor = "n-resize") : K.B(k.y, l.y) && (this.Bm(h, hh), h.cursor = "w-resize")) : g !== f && (this.Bm(h, ih), h.cursor = "move"); e.add(h)
            } e.adornedObject = a
        } return e
    }; dh.prototype.makeHandle = function () { var a = this.handleArchetype; return null === a ? null : a.copy() };
    dh.prototype.makeResegmentHandle = function () { var a = this.midHandleArchetype; return null === a ? null : a.copy() }; dh.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; return !a.isReadOnly && a.allowReshape && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1 };
    dh.prototype.doActivate = function () {
        var a = this.diagram; null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name)); if (null !== this.handle) {
            var b = this.handle.part.adornedPart; if (b instanceof Q) {
            this.Mt = b; a.isMouseCaptured = !0; this.Ca(this.name); if (b.resegmentable && 999 === this.handle.fromMaxLinks) {
                var c = b.points.copy(), d = this.getResegmentingPoint(); c.Lb(this.handle.segmentIndex + 1, d); b.isOrthogonal && c.Lb(this.handle.segmentIndex + 1, d); b.points = c; b.Mb(); b.updateAdornments();
                this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name); if (null === this.handle) { this.doDeactivate(); return }
            } this.yl = b.i(this.handle.segmentIndex); this.ls = b.points.copy(); this.isActive = !0
            }
        }
    }; dh.prototype.doDeactivate = function () { this.yg(); this.Mt = this.handle = null; this.isActive = this.diagram.isMouseCaptured = !1 }; dh.prototype.doCancel = function () { var a = this.adornedLink; null !== a && (a.points = this.ls); this.stopTool() }; dh.prototype.getResegmentingPoint = function () { return this.handle.oa(qd) };
    dh.prototype.doMouseMove = function () { var a = this.diagram; this.isActive && (a = this.computeReshape(a.lastInput.documentPoint), this.reshape(a)) };
    dh.prototype.doMouseUp = function () {
        var a = this.diagram; if (this.isActive) {
            var b = this.computeReshape(a.lastInput.documentPoint); this.reshape(b); b = this.adornedLink; if (null !== b && b.resegmentable) {
                var c = this.handle.segmentIndex, d = b.i(c - 1), e = b.i(c), f = b.i(c + 1); if (b.isOrthogonal) {
                    if (c > b.firstPickIndex + 1 && c < b.lastPickIndex - 1) {
                        var g = b.i(c - 2); if (Math.abs(d.x - e.x) < this.resegmentingDistance && Math.abs(d.y - e.y) < this.resegmentingDistance && (jh(this, g, d, e, f, !0) || jh(this, g, d, e, f, !1))) {
                            var h = b.points.copy(); jh(this, g, d,
                                e, f, !0) ? (h.jd(c - 2, new J(g.x, (f.y + g.y) / 2)), h.jd(c + 1, new J(f.x, (f.y + g.y) / 2))) : (h.jd(c - 2, new J((f.x + g.x) / 2, g.y)), h.jd(c + 1, new J((f.x + g.x) / 2, f.y))); h.nb(c); h.nb(c - 1); b.points = h; b.Mb()
                        } else g = b.i(c + 2), Math.abs(e.x - f.x) < this.resegmentingDistance && Math.abs(e.y - f.y) < this.resegmentingDistance && (jh(this, d, e, f, g, !0) || jh(this, d, e, f, g, !1)) && (h = b.points.copy(), jh(this, d, e, f, g, !0) ? (h.jd(c - 1, new J(d.x, (d.y + g.y) / 2)), h.jd(c + 2, new J(g.x, (d.y + g.y) / 2))) : (h.jd(c - 1, new J((d.x + g.x) / 2, d.y)), h.jd(c + 2, new J((d.x + g.x) / 2, g.y))),
                            h.nb(c + 1), h.nb(c), b.points = h, b.Mb())
                    }
                } else g = J.alloc(), K.Vi(d.x, d.y, f.x, f.y, e.x, e.y, g) && g.Ee(e) < this.resegmentingDistance * this.resegmentingDistance && (d = b.points.copy(), d.nb(c), b.points = d, b.Mb()), J.free(g)
            } a.Ya(); this.transactionResult = this.name; a.ba("LinkReshaped", this.adornedLink, this.ls)
        } this.stopTool()
    };
    function jh(a, b, c, d, e, f) { return f ? Math.abs(b.y - c.y) < a.resegmentingDistance && Math.abs(c.y - d.y) < a.resegmentingDistance && Math.abs(d.y - e.y) < a.resegmentingDistance : Math.abs(b.x - c.x) < a.resegmentingDistance && Math.abs(c.x - d.x) < a.resegmentingDistance && Math.abs(d.x - e.x) < a.resegmentingDistance }
    dh.prototype.reshape = function (a) {
        var b = this.adornedLink; b.Dh(); var c = this.handle.segmentIndex, d = this.lv(this.handle); if (b.isOrthogonal) if (c === b.firstPickIndex + 1) c = b.firstPickIndex + 1, d === gh ? (b.N(c, b.i(c - 1).x, a.y), b.N(c + 1, b.i(c + 2).x, a.y)) : d === hh && (b.N(c, a.x, b.i(c - 1).y), b.N(c + 1, a.x, b.i(c + 2).y)); else if (c === b.lastPickIndex - 1) c = b.lastPickIndex - 1, d === gh ? (b.N(c - 1, b.i(c - 2).x, a.y), b.N(c, b.i(c + 1).x, a.y)) : d === hh && (b.N(c - 1, a.x, b.i(c - 2).y), b.N(c, a.x, b.i(c + 1).y)); else {
            d = c; var e = b.i(d), f = b.i(d - 1), g = b.i(d + 1); K.B(f.x,
                e.x) && K.B(e.y, g.y) ? (K.B(f.x, b.i(d - 2).x) && !K.B(f.y, b.i(d - 2).y) ? (b.m(d, a.x, f.y), c++ , d++) : b.N(d - 1, a.x, f.y), K.B(g.y, b.i(d + 2).y) && !K.B(g.x, b.i(d + 2).x) ? b.m(d + 1, g.x, a.y) : b.N(d + 1, g.x, a.y)) : K.B(f.y, e.y) && K.B(e.x, g.x) ? (K.B(f.y, b.i(d - 2).y) && !K.B(f.x, b.i(d - 2).x) ? (b.m(d, f.x, a.y), c++ , d++) : b.N(d - 1, f.x, a.y), K.B(g.x, b.i(d + 2).x) && !K.B(g.y, b.i(d + 2).y) ? b.m(d + 1, a.x, g.y) : b.N(d + 1, a.x, g.y)) : K.B(f.x, e.x) && K.B(e.x, g.x) ? (K.B(f.x, b.i(d - 2).x) && !K.B(f.y, b.i(d - 2).y) ? (b.m(d, a.x, f.y), c++ , d++) : b.N(d - 1, a.x, f.y), K.B(g.x, b.i(d + 2).x) &&
                    !K.B(g.y, b.i(d + 2).y) ? b.m(d + 1, a.x, g.y) : b.N(d + 1, a.x, g.y)) : K.B(f.y, e.y) && K.B(e.y, g.y) && (K.B(f.y, b.i(d - 2).y) && !K.B(f.x, b.i(d - 2).x) ? (b.m(d, f.x, a.y), c++ , d++) : b.N(d - 1, f.x, a.y), K.B(g.y, b.i(d + 2).y) && !K.B(g.x, b.i(d + 2).x) ? b.m(d + 1, g.x, a.y) : b.N(d + 1, g.x, a.y)); b.N(c, a.x, a.y)
        } else b.N(c, a.x, a.y), d = b.fromNode, e = b.fromPort, null !== d && (f = d.findVisibleNode(), null !== f && f !== d && (d = f, e = d.port)), 1 === c && b.computeSpot(!0, e).Nb() && (f = e.oa(qd, J.alloc()), d = b.getLinkPointFromPoint(d, e, f, a, !0, J.alloc()), b.N(0, d.x, d.y), J.free(f),
            J.free(d)), d = b.toNode, e = b.toPort, null !== d && (f = d.findVisibleNode(), null !== f && f !== d && (d = f, e = d.port)), c === b.pointsCount - 2 && b.computeSpot(!1, e).Nb() && (c = e.oa(qd, J.alloc()), a = b.getLinkPointFromPoint(d, e, c, a, !1, J.alloc()), b.N(b.pointsCount - 1, a.x, a.y), J.free(c), J.free(a)); b.nf()
    }; dh.prototype.computeReshape = function (a) { var b = this.adornedLink, c = this.handle.segmentIndex; switch (this.lv(this.handle)) { case ih: return a; case gh: return new J(b.i(c).x, a.y); case hh: return new J(a.x, b.i(c).y); default: case eh: return b.i(c) } };
    na.Object.defineProperties(dh.prototype, {
        handleArchetype: { configurable: !0, get: function () { return this.w }, set: function (a) { null !== a && w(a, N, dh, "handleArchetype"); this.w = a } }, midHandleArchetype: { configurable: !0, get: function () { return this.L }, set: function (a) { null !== a && w(a, N, dh, "midHandleArchetype"); this.L = a } }, handle: {
            configurable: !0, get: function () { return this.l }, set: function (a) {
                if (null !== a && (w(a, N, dh, "handle"), !(a.part instanceof Cf))) throw Error("new handle is not in an Adornment: " +
                    a); this.l = a
            }
        }, adornedLink: { configurable: !0, get: function () { return this.Mt } }, resegmentingDistance: { configurable: !0, get: function () { return this.ca }, set: function (a) { z(a, "number", dh, "resegmentingDistance"); this.ca = a } }, originalPoint: { configurable: !0, get: function () { return this.yl } }, originalPoints: { configurable: !0, get: function () { return this.ls } }
    }); dh.prototype.setReshapingBehavior = dh.prototype.Bm; dh.prototype.getReshapingBehavior = dh.prototype.lv;
    var eh = new D(dh, "None", 0), hh = new D(dh, "Horizontal", 1), gh = new D(dh, "Vertical", 2), ih = new D(dh, "All", 3); dh.className = "LinkReshapingTool"; dh.None = eh; dh.Horizontal = hh; dh.Vertical = gh; dh.All = ih; Za("linkReshapingTool", function () { return this.findTool("LinkReshaping") }, function (a) { If(this, "LinkReshaping", a, this.mouseDownTools) });
    function kh() { 0 < arguments.length && Da(kh); vf.call(this); this.name = "Resizing"; this.Sf = (new Zb(1, 1)).freeze(); this.Rf = (new Zb(9999, 9999)).freeze(); this.Eg = (new Zb(NaN, NaN)).freeze(); this.L = !1; this.ce = null; var a = new Hg; a.alignmentFocus = qd; a.figure = "Rectangle"; a.desiredSize = tc; a.fill = "lightblue"; a.stroke = "dodgerblue"; a.strokeWidth = 1; a.cursor = "pointer"; this.w = a; this.l = null; this.yl = new J; this.Lw = new Zb; this.Po = new J; this.cu = new Zb(0, 0); this.bu = new Zb(Infinity, Infinity); this.au = new Zb(1, 1); this.Iw = !0 }
    ma(kh, vf); kh.prototype.updateAdornments = function (a) { if (!(null === a || a instanceof Q)) { if (a.isSelected && !this.diagram.isReadOnly) { var b = a.resizeObject, c = a.dk(this.name); if (null !== b && a.canResize() && a.actualBounds.o() && a.isVisible() && b.actualBounds.o() && b.uf()) { if (null === c || c.adornedObject !== b) c = this.makeAdornment(b); if (null !== c) { b = b.Ni(); Dg(a) && this.updateResizeHandles(c, b); a.qh(this.name, c); return } } } a.wf(this.name) } };
    kh.prototype.makeAdornment = function (a) { var b = a.part.resizeAdornmentTemplate; if (null === b) { b = new Cf; b.type = W.Spot; b.locationSpot = qd; var c = new lh; c.isPanelMain = !0; b.add(c); b.add(this.makeHandle(a, fd)); b.add(this.makeHandle(a, hd)); b.add(this.makeHandle(a, ud)); b.add(this.makeHandle(a, sd)); b.add(this.makeHandle(a, Vd)); b.add(this.makeHandle(a, Xd)); b.add(this.makeHandle(a, de)); b.add(this.makeHandle(a, Wd)) } else if (mh(b), b = b.copy(), null === b) return null; b.adornedObject = a; return b };
    kh.prototype.makeHandle = function (a, b) { a = this.handleArchetype; if (null === a) return null; a = a.copy(); a.alignment = b; return a };
    kh.prototype.updateResizeHandles = function (a, b) {
        if (null !== a) if (!a.alignment.Cb() && ("pointer" === a.cursor || 0 < a.cursor.indexOf("resize"))) a: {
            var c = a.alignment; c.Nb() && (c = qd); if (0 >= c.x) b = 0 >= c.y ? b + 225 : 1 <= c.y ? b + 135 : b + 180; else if (1 <= c.x) 0 >= c.y ? b += 315 : 1 <= c.y && (b += 45); else if (0 >= c.y) b += 270; else if (1 <= c.y) b += 90; else break a; 0 > b ? b += 360 : 360 <= b && (b -= 360); a.cursor = 22.5 > b ? "e-resize" : 67.5 > b ? "se-resize" : 112.5 > b ? "s-resize" : 157.5 > b ? "sw-resize" : 202.5 > b ? "w-resize" : 247.5 > b ? "nw-resize" : 292.5 > b ? "n-resize" : 337.5 > b ? "ne-resize" :
                "e-resize"
        } else if (a instanceof W) for (a = a.elements; a.next();)this.updateResizeHandles(a.value, b)
    }; kh.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; return !a.isReadOnly && a.allowResize && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1 };
    kh.prototype.doActivate = function () {
        var a = this.diagram; null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name)); null !== this.handle && (this.adornedObject = this.handle.part.adornedObject, null !== this.adornedObject && (this.yl.set(this.adornedObject.oa(this.handle.alignment.yv())), this.Po.set(this.adornedObject.part.location), this.Lw.set(this.adornedObject.desiredSize), this.au = this.computeCellSize(), this.cu = this.computeMinSize(), this.bu = this.computeMaxSize(), a.isMouseCaptured =
            !0, this.Iw = a.animationManager.isEnabled, a.animationManager.isEnabled = !1, this.Ca(this.name), this.isActive = !0))
    }; kh.prototype.doDeactivate = function () { var a = this.diagram; this.yg(); this.ce = this.handle = null; this.isActive = a.isMouseCaptured = !1; a.animationManager.isEnabled = this.Iw }; kh.prototype.doCancel = function () { null !== this.adornedObject && (this.adornedObject.desiredSize = this.originalDesiredSize, this.adornedObject.part.location = this.originalLocation); this.stopTool() };
    kh.prototype.doMouseMove = function () { var a = this.diagram; if (this.isActive) { var b = this.cu, c = this.bu, d = this.au, e = this.adornedObject.at(a.lastInput.documentPoint, J.alloc()), f = this.computeReshape(); b = this.computeResize(e, this.handle.alignment, b, c, d, f); this.resize(b); a.hd(); J.free(e) } };
    kh.prototype.doMouseUp = function () { var a = this.diagram; if (this.isActive) { var b = this.cu, c = this.bu, d = this.au, e = this.adornedObject.at(a.lastInput.documentPoint, J.alloc()), f = this.computeReshape(); b = this.computeResize(e, this.handle.alignment, b, c, d, f); this.resize(b); J.free(e); a.Ya(); this.transactionResult = this.name; a.ba("PartResized", this.adornedObject, this.originalDesiredSize) } this.stopTool() };
    kh.prototype.resize = function (a) { var b = this.diagram, c = this.adornedObject, d = c.part; c.desiredSize = a.size; d.bc(); a = this.adornedObject.oa(this.handle.alignment.yv()); d instanceof xg ? (c = new F, c.add(d), b.moveParts(c, this.yl.copy().Zd(a), !0)) : d.location = d.location.copy().Zd(a).add(this.yl) };
    kh.prototype.computeResize = function (a, b, c, d, e, f) {
        b.Nb() && (b = qd); var g = this.adornedObject.naturalBounds, h = g.x, k = g.y, l = g.x + g.width, m = g.y + g.height, n = 1; if (!f) { n = g.width; var p = g.height; 0 >= n && (n = 1); 0 >= p && (p = 1); n = p / n } p = J.alloc(); K.bq(a.x, a.y, h, k, e.width, e.height, p); a = g.copy(); 0 >= b.x ? 0 >= b.y ? (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = Math.max(l - a.x, c.width), a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = Math.max(m - a.y, c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n *
            a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.x = l - a.width, a.y = m - a.height)) : 1 <= b.y ? (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = Math.max(l - a.x, c.width), a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.x = l - a.width)) : (a.x =
                Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = l - a.x, f || (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n, a.y = k + .5 * (m - k - a.height))) : 1 <= b.x ? 0 >= b.y ? (a.width = Math.max(Math.min(p.x - h, d.width), c.width), a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = Math.max(m - a.y, c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width),
                    a.y = m - a.height)) : 1 <= b.y ? (a.width = Math.max(Math.min(p.x - h, d.width), c.width), a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width))) : (a.width = Math.max(Math.min(p.x - h, d.width), c.width), f || (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n, a.y = k + .5 * (m - k - a.height))) : 0 >= b.y ? (a.y = Math.max(p.y, m - d.height),
                        a.y = Math.min(a.y, m - c.height), a.height = m - a.y, f || (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width, a.x = h + .5 * (l - h - a.width))) : 1 <= b.y && (a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width, a.x = h + .5 * (l - h - a.width))); J.free(p); return a
    }; kh.prototype.computeReshape = function () { var a = nh; this.adornedObject instanceof Hg && (a = oh(this.adornedObject)); return !(a === ph || this.diagram.lastInput.shift) };
    kh.prototype.computeMinSize = function () { var a = this.adornedObject.minSize.copy(), b = this.minSize; !isNaN(b.width) && b.width > a.width && (a.width = b.width); !isNaN(b.height) && b.height > a.height && (a.height = b.height); return a }; kh.prototype.computeMaxSize = function () { var a = this.adornedObject.maxSize.copy(), b = this.maxSize; !isNaN(b.width) && b.width < a.width && (a.width = b.width); !isNaN(b.height) && b.height < a.height && (a.height = b.height); return a };
    kh.prototype.computeCellSize = function () {
        var a = new Zb(NaN, NaN), b = this.adornedObject.part; null !== b && (b = b.resizeCellSize, !isNaN(b.width) && 0 < b.width && (a.width = b.width), !isNaN(b.height) && 0 < b.height && (a.height = b.height)); b = this.cellSize; isNaN(a.width) && !isNaN(b.width) && 0 < b.width && (a.width = b.width); isNaN(a.height) && !isNaN(b.height) && 0 < b.height && (a.height = b.height); b = this.diagram; (isNaN(a.width) || isNaN(a.height)) && b && (b = b.grid, null !== b && b.visible && this.isGridSnapEnabled && (b = b.gridCellSize, isNaN(a.width) &&
            !isNaN(b.width) && 0 < b.width && (a.width = b.width), isNaN(a.height) && !isNaN(b.height) && 0 < b.height && (a.height = b.height))); if (isNaN(a.width) || 0 === a.width || Infinity === a.width) a.width = 1; if (isNaN(a.height) || 0 === a.height || Infinity === a.height) a.height = 1; return a
    };
    na.Object.defineProperties(kh.prototype, {
        handleArchetype: { configurable: !0, get: function () { return this.w }, set: function (a) { null !== a && w(a, N, kh, "handleArchetype"); this.w = a } }, handle: { configurable: !0, get: function () { return this.l }, set: function (a) { if (null !== a && (w(a, N, kh, "handle"), !(a.part instanceof Cf))) throw Error("new handle is not in an Adornment: " + a); this.l = a } }, adornedObject: {
            configurable: !0, get: function () { return this.ce }, set: function (a) {
                if (null !== a && (w(a, N,
                    kh, "handle"), a.part instanceof Cf)) throw Error("new handle must not be in an Adornment: " + a); this.ce = a
            }
        }, minSize: { configurable: !0, get: function () { return this.Sf }, set: function (a) { w(a, Zb, kh, "minSize"); if (!this.Sf.A(a)) { var b = a.width; isNaN(b) && (b = 0); a = a.height; isNaN(a) && (a = 0); this.Sf.h(b, a) } } }, maxSize: {
            configurable: !0, get: function () { return this.Rf }, set: function (a) {
                w(a, Zb, kh, "maxSize"); if (!this.Rf.A(a)) {
                    var b = a.width; isNaN(b) && (b = Infinity); a = a.height; isNaN(a) && (a = Infinity);
                    this.Rf.h(b, a)
                }
            }
        }, cellSize: { configurable: !0, get: function () { return this.Eg }, set: function (a) { w(a, Zb, kh, "cellSize"); this.Eg.A(a) || this.Eg.assign(a) } }, isGridSnapEnabled: { configurable: !0, get: function () { return this.L }, set: function (a) { z(a, "boolean", kh, "isGridSnapEnabled"); this.L = a } }, originalDesiredSize: { configurable: !0, get: function () { return this.Lw } }, originalLocation: { configurable: !0, get: function () { return this.Po } }
    }); kh.className = "ResizingTool";
    Za("resizingTool", function () { return this.findTool("Resizing") }, function (a) { If(this, "Resizing", a, this.mouseDownTools) }); function qh() { 0 < arguments.length && Da(qh); vf.call(this); this.name = "Rotating"; this.Na = 45; this.Ma = 2; this.Po = new J; this.ce = null; var a = new Hg; a.figure = "Ellipse"; a.desiredSize = uc; a.fill = "lightblue"; a.stroke = "dodgerblue"; a.strokeWidth = 1; a.cursor = "pointer"; this.w = a; this.l = null; this.Kw = 0; this.vu = new J(NaN, NaN); this.L = 0; this.ca = 50 } ma(qh, vf);
    qh.prototype.updateAdornments = function (a) { if (null !== a) { if (a.Ah()) { var b = a.rotateObject; if (b === a || b === a.path || b.isPanelMain) return } if (a.isSelected && !this.diagram.isReadOnly && (b = a.rotateObject, null !== b && a.canRotate() && a.actualBounds.o() && a.isVisible() && b.actualBounds.o() && b.uf())) { var c = a.dk(this.name); if (null === c || c.adornedObject !== b) c = this.makeAdornment(b); if (null !== c) { c.angle = b.Ni(); null === c.placeholder && (c.location = this.computeAdornmentLocation(b)); a.qh(this.name, c); return } } a.wf(this.name) } };
    qh.prototype.makeAdornment = function (a) { var b = a.part.rotateAdornmentTemplate; if (null === b) { b = new Cf; b.type = W.Position; b.locationSpot = qd; var c = this.handleArchetype; null !== c && b.add(c.copy()) } else if (mh(b), b = b.copy(), null === b) return null; b.adornedObject = a; return b }; qh.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; return !a.isReadOnly && a.allowRotate && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1 };
    qh.prototype.doActivate = function () { var a = this.diagram; if (null === this.adornedObject) { null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name)); if (null === this.handle) return; this.adornedObject = this.handle.part.adornedObject } null !== this.adornedObject && (this.Kw = this.adornedObject.angle, this.vu = this.computeRotationPoint(this.adornedObject), this.Po = this.adornedObject.part.location.copy(), a.isMouseCaptured = !0, a.delaysLayout = !0, this.Ca(this.name), this.isActive = !0) };
    qh.prototype.computeRotationPoint = function (a) { var b = a.part, c = b.locationObject; return b.rotationSpot.Za() ? a.oa(b.rotationSpot) : a === b || a === c ? c.oa(b.locationSpot) : a.oa(qd) };
    qh.prototype.computeAdornmentLocation = function (a) {
        var b = this.rotationPoint; b.o() || (b = this.computeRotationPoint(a)); b = a.at(b); var c = this.handleAngle; 0 > c ? c += 360 : 360 <= c && (c -= 360); c = Math.round(45 * Math.round(c / 45)); var d = this.handleDistance; 0 === c ? b.x = a.naturalBounds.width + d : 45 === c ? (b.x = a.naturalBounds.width + d, b.y = a.naturalBounds.height + d) : 90 === c ? b.y = a.naturalBounds.height + d : 135 === c ? (b.x = -d, b.y = a.naturalBounds.height + d) : 180 === c ? b.x = -d : 225 === c ? (b.x = -d, b.y = -d) : 270 === c ? b.y = -d : 315 === c && (b.x = a.naturalBounds.width +
            d, b.y = -d); return a.oa(b)
    }; qh.prototype.doDeactivate = function () { var a = this.diagram; this.yg(); this.ce = this.handle = null; this.vu = new J(NaN, NaN); this.isActive = a.isMouseCaptured = !1 }; qh.prototype.doCancel = function () { this.diagram.delaysLayout = !1; this.rotate(this.originalAngle); this.stopTool() }; qh.prototype.doMouseMove = function () { var a = this.diagram; this.isActive && (a = this.computeRotate(a.lastInput.documentPoint), this.rotate(a)) };
    qh.prototype.doMouseUp = function () { var a = this.diagram; if (this.isActive) { a.delaysLayout = !1; var b = this.computeRotate(a.lastInput.documentPoint); this.rotate(b); a.Ya(); this.transactionResult = this.name; a.ba("PartRotated", this.adornedObject, this.originalAngle) } this.stopTool() };
    qh.prototype.rotate = function (a) { E && B(a, qh, "rotate:newangle"); var b = this.adornedObject; if (null !== b) { b.angle = a; b = b.part; b.bc(); var c = b.locationObject, d = b.rotateObject; if (c === d || c.tg(d)) c = this.Po.copy(), b.location = c.Zd(this.rotationPoint).rotate(a - this.originalAngle).add(this.rotationPoint) } };
    qh.prototype.computeRotate = function (a) { a = this.rotationPoint.Xa(a) - this.handleAngle; var b = this.adornedObject.panel; null !== b && (a -= b.Ni()); 360 <= a ? a -= 360 : 0 > a && (a += 360); b = Math.min(Math.abs(this.snapAngleMultiple), 180); var c = Math.min(Math.abs(this.snapAngleEpsilon), b / 2); !this.diagram.lastInput.shift && 0 < b && 0 < c && (a % b < c ? a = Math.floor(a / b) * b : a % b > b - c && (a = (Math.floor(a / b) + 1) * b)); 360 <= a ? a -= 360 : 0 > a && (a += 360); return a };
    na.Object.defineProperties(qh.prototype, {
        handleArchetype: { configurable: !0, get: function () { return this.w }, set: function (a) { null !== a && w(a, N, qh, "handleArchetype"); this.w = a } }, handle: { configurable: !0, get: function () { return this.l }, set: function (a) { if (null !== a && (w(a, N, qh, "handle"), !(a.part instanceof Cf))) throw Error("new handle is not in an Adornment: " + a); this.l = a } }, adornedObject: {
            configurable: !0, get: function () { return this.ce }, set: function (a) {
                if (null !== a && (w(a, N,
                    qh, "handle"), a.part instanceof Cf)) throw Error("new handle must not be in an Adornment: " + a); this.ce = a
            }
        }, snapAngleMultiple: { configurable: !0, get: function () { return this.Na }, set: function (a) { z(a, "number", qh, "snapAngleMultiple"); this.Na = a } }, snapAngleEpsilon: { configurable: !0, get: function () { return this.Ma }, set: function (a) { z(a, "number", qh, "snapAngleEpsilon"); this.Ma = a } }, originalAngle: { configurable: !0, get: function () { return this.Kw } }, rotationPoint: {
            configurable: !0,
            enumerable: !0, get: function () { return this.vu }
        }, handleAngle: { configurable: !0, get: function () { return this.L }, set: function (a) { z(a, "number", qh, "handleAngle"); this.L = a } }, handleDistance: { configurable: !0, get: function () { return this.ca }, set: function (a) { z(a, "number", qh, "handleDistance"); this.ca = a } }
    }); qh.className = "RotatingTool"; Za("rotatingTool", function () { return this.findTool("Rotating") }, function (a) { If(this, "Rotating", a, this.mouseDownTools) });
    function rh() { vf.call(this); 0 < arguments.length && Da(rh); this.name = "ClickSelecting" } ma(rh, vf); rh.prototype.canStart = function () { return !this.isEnabled || this.isBeyondDragSize() ? !1 : !0 }; rh.prototype.doMouseUp = function () { this.isActive && (this.standardMouseSelect(), !this.standardMouseClick() && this.diagram.lastInput.isTouchEvent && this.diagram.toolManager.doToolTip()); this.stopTool() }; rh.className = "ClickSelectingTool"; function sh() { vf.call(this); 0 < arguments.length && Da(sh); this.name = "Action"; this.zk = null }
    ma(sh, vf); sh.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram, b = a.lastInput, c = a.Tb(b.documentPoint, function (a) { for (; null !== a.panel && !a.isActionable;)a = a.panel; return a }); if (null !== c) { if (!c.isActionable) return !1; this.zk = c; a.Nk = a.Tb(b.documentPoint, null, null); return !0 } return !1 }; sh.prototype.doMouseDown = function () { if (this.isActive) { var a = this.diagram.lastInput, b = this.zk; null !== b && (a.targetObject = b, null !== b.actionDown && b.actionDown(a, b)) } else this.canStart() && this.doActivate() };
    sh.prototype.doMouseMove = function () { if (this.isActive) { var a = this.diagram.lastInput, b = this.zk; null !== b && (a.targetObject = b, null !== b.actionMove && b.actionMove(a, b)) } }; sh.prototype.doMouseUp = function () { if (this.isActive) { var a = this.diagram.lastInput, b = this.zk; if (null === b) return; a.targetObject = b; null !== b.actionUp && b.actionUp(a, b); this.standardMouseClick(function (a) { for (; null !== a.panel && (!a.isActionable || a !== b);)a = a.panel; return a }, function (a) { return a === b }) } this.stopTool() };
    sh.prototype.doCancel = function () { var a = this.diagram.lastInput, b = this.zk; null !== b && (a.targetObject = b, null !== b.actionCancel && b.actionCancel(a, b), this.stopTool()) }; sh.prototype.doStop = function () { this.zk = null }; sh.className = "ActionTool"; function th() { vf.call(this); 0 < arguments.length && Da(th); this.name = "ClickCreating"; this.dj = null; this.w = !0; this.l = !1; this.Cw = new J(0, 0) } ma(th, vf);
    th.prototype.canStart = function () { if (!this.isEnabled || null === this.archetypeNodeData) return !1; var a = this.diagram; if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.lastInput.left || this.isBeyondDragSize()) return !1; if (this.isDoubleClick) { if (1 === a.lastInput.clickCount && (this.Cw = a.lastInput.viewPoint.copy()), 2 !== a.lastInput.clickCount || this.isBeyondDragSize(this.Cw)) return !1 } else if (1 !== a.lastInput.clickCount) return !1; return a.currentTool !== this && null !== a.dm(a.lastInput.documentPoint, !0) ? !1 : !0 };
    th.prototype.doMouseUp = function () { var a = this.diagram; this.isActive && this.insertPart(a.lastInput.documentPoint); this.stopTool() };
    th.prototype.insertPart = function (a) { var b = this.diagram, c = this.archetypeNodeData; if (null === c) return null; this.Ca(this.name); var d = null; c instanceof R ? c.dc() && (mh(c), d = c.copy(), null !== d && b.add(d)) : null !== c && (c = b.model.copyNodeData(c), Ia(c) && (b.model.lf(c), d = b.xc(c))); null !== d && (c = J.allocAt(a.x, a.y), this.isGridSnapEnabled && uh(this.diagram, d, a, c), d.location = c, b.allowSelect && b.select(d), J.free(c)); b.Ya(); this.transactionResult = this.name; b.ba("PartCreated", d); this.yg(); return d };
    na.Object.defineProperties(th.prototype, { archetypeNodeData: { configurable: !0, get: function () { return this.dj }, set: function (a) { null !== a && z(a, "object", th, "archetypeNodeData"); this.dj = a } }, isDoubleClick: { configurable: !0, get: function () { return this.w }, set: function (a) { z(a, "boolean", th, "isDoubleClick"); this.w = a } }, isGridSnapEnabled: { configurable: !0, get: function () { return this.l }, set: function (a) { z(a, "boolean", th, "isGridSnapEnabled"); this.l = a } } }); th.className = "ClickCreatingTool";
    function vh() { vf.call(this); 0 < arguments.length && Da(vh); this.name = "DragSelecting"; this.Uk = 175; this.w = !1; var a = new R; a.layerName = "Tool"; a.selectable = !1; var b = new Hg; b.name = "SHAPE"; b.figure = "Rectangle"; b.fill = null; b.stroke = "magenta"; a.add(b); this.l = a } ma(vh, vf);
    vh.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; if (!a.allowSelect) return !1; var b = a.lastInput; return !b.left || a.currentTool !== this && (!this.isBeyondDragSize() || b.timestamp - a.firstInput.timestamp < this.delay || null !== a.dm(b.documentPoint, !0)) ? !1 : !0 }; vh.prototype.doActivate = function () { var a = this.diagram; this.isActive = !0; a.isMouseCaptured = !0; a.skipsUndoManager = !0; a.add(this.box); this.doMouseMove() };
    vh.prototype.doDeactivate = function () { var a = this.diagram; a.yf(); a.remove(this.box); a.skipsUndoManager = !1; this.isActive = a.isMouseCaptured = !1 }; vh.prototype.doMouseMove = function () { var a = this.diagram; if (this.isActive && null !== this.box) { var b = this.computeBoxBounds(), c = this.box.bb("SHAPE"); null === c && (c = this.box.Bb()); var d = Zb.alloc().h(b.width, b.height); b = J.alloc().h(b.x, b.y); c.desiredSize = d; this.box.position = b; Zb.free(d); J.free(b); (a.allowHorizontalScroll || a.allowVerticalScroll) && a.Ts(a.lastInput.viewPoint) } };
    vh.prototype.doMouseUp = function () { if (this.isActive) { var a = this.diagram; a.remove(this.box); try { a.currentCursor = "wait", a.ba("ChangingSelection", a.selection), this.selectInRect(this.computeBoxBounds()), a.ba("ChangedSelection", a.selection) } finally { a.currentCursor = "" } } this.stopTool() }; vh.prototype.computeBoxBounds = function () { var a = this.diagram; return new L(a.firstInput.documentPoint, a.lastInput.documentPoint) };
    vh.prototype.selectInRect = function (a) {
        var b = this.diagram, c = b.lastInput; a = b.ox(a, this.isPartialInclusion); if (kb ? c.meta : c.control) if (c.shift) for (a = a.iterator; a.next();)b = a.value, b.isSelected && (b.isSelected = !1); else for (a = a.iterator; a.next();)b = a.value, b.isSelected = !b.isSelected; else if (c.shift) for (a = a.iterator; a.next();)b = a.value, b.isSelected || (b.isSelected = !0); else {
            c = new F; for (b = b.selection.iterator; b.next();) { var d = b.value; a.contains(d) || c.add(d) } for (b = c.iterator; b.next();)b.value.isSelected = !1; for (a =
                a.iterator; a.next();)b = a.value, b.isSelected || (b.isSelected = !0)
        }
    }; na.Object.defineProperties(vh.prototype, { delay: { configurable: !0, get: function () { return this.Uk }, set: function (a) { z(a, "number", vh, "delay"); this.Uk = a } }, isPartialInclusion: { configurable: !0, get: function () { return this.w }, set: function (a) { z(a, "boolean", vh, "isPartialInclusion"); this.w = a } }, box: { configurable: !0, get: function () { return this.l }, set: function (a) { null !== a && w(a, R, vh, "box"); this.l = a } } });
    vh.className = "DragSelectingTool"; function wh() { vf.call(this); 0 < arguments.length && Da(wh); this.name = "Panning"; this.qu = new J; this.iy = new J; this.Dg = !1; var a = this; this.Ow = function () { qa.document.removeEventListener("scroll", a.Ow, !1); a.stopTool() } } ma(wh, vf); wh.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; return !a.allowHorizontalScroll && !a.allowVerticalScroll || !a.lastInput.left || a.currentTool !== this && !this.isBeyondDragSize() ? !1 : !0 };
    wh.prototype.doActivate = function () { var a = this.diagram; this.Dg ? (a.lastInput.bubbles = !0, qa.document.addEventListener("scroll", this.Ow, !1)) : (a.currentCursor = "move", a.isMouseCaptured = !0, this.qu.assign(a.position)); this.isActive = !0 }; wh.prototype.doDeactivate = function () { var a = this.diagram; a.currentCursor = ""; this.isActive = a.isMouseCaptured = !1 }; wh.prototype.doCancel = function () { var a = this.diagram; a.position = this.qu; a.isMouseCaptured = !1; this.stopTool() }; wh.prototype.doMouseMove = function () { this.move() };
    wh.prototype.doMouseUp = function () { this.move(); this.stopTool() }; wh.prototype.move = function () { var a = this.diagram; if (this.isActive && a) if (this.Dg) a.lastInput.bubbles = !0; else { var b = a.position, c = a.firstInput.documentPoint, d = a.lastInput.documentPoint, e = b.x + c.x - d.x; c = b.y + c.y - d.y; a.allowHorizontalScroll || (e = b.x); a.allowVerticalScroll || (c = b.y); a.position = this.iy.h(e, c) } };
    na.Object.defineProperties(wh.prototype, { bubbles: { configurable: !0, get: function () { return this.Dg }, set: function (a) { z(a, "boolean", wh, "bubbles"); this.Dg = a } }, originalPosition: { configurable: !0, get: function () { return this.qu } } }); wh.className = "PanningTool"; Za("clickCreatingTool", function () { return this.findTool("ClickCreating") }, function (a) { If(this, "ClickCreating", a, this.mouseUpTools) });
    Za("clickSelectingTool", function () { return this.findTool("ClickSelecting") }, function (a) { If(this, "ClickSelecting", a, this.mouseUpTools) }); Za("panningTool", function () { return this.findTool("Panning") }, function (a) { If(this, "Panning", a, this.mouseMoveTools) }); Za("dragSelectingTool", function () { return this.findTool("DragSelecting") }, function (a) { If(this, "DragSelecting", a, this.mouseMoveTools) }); Za("actionTool", function () { return this.findTool("Action") }, function (a) { If(this, "Action", a, this.mouseDownTools) });
    function Hf() { this.ca = this.L = this.l = this.w = null }
    na.Object.defineProperties(Hf.prototype, {
        mainElement: { configurable: !0, get: function () { return this.L }, set: function (a) { null !== a && w(a, HTMLElement, Hf, "mainElement"); this.L = a } }, show: { configurable: !0, get: function () { return this.w }, set: function (a) { this.w !== a && (null !== a && z(a, "function", Hf, "show"), this.w = a) } }, hide: { configurable: !0, get: function () { return this.l }, set: function (a) { this.l !== a && (null !== a && z(a, "function", Hf, "hide"), this.l = a) } }, valueFunction: {
            configurable: !0,
            enumerable: !0, get: function () { return this.ca }, set: function (a) { this.ca = a }
        }
    }); Hf.className = "HTMLInfo"; function xh(a, b, c) { this.text = a; this.ex = b; this.visible = c } xh.className = "ContextMenuButtonInfo"; function yh() { vf.call(this); 0 < arguments.length && Da(yh); this.name = "ContextMenu"; this.w = this.St = this.l = null; this.Hw = new J; this.Tt = null; var a = this; this.Fu = function () { a.stopTool() } } ma(yh, vf);
    function zh(a) {
        var b = new Hf; b.show = function (a, b, c) { c.showDefaultContextMenu() }; b.hide = function (a, b) { b.hideDefaultContextMenu() }; Ah = b; a.Fu = function () { a.stopTool() }; b = xa("div"); var c = xa("div"); b.style.cssText = "top: 0px;z-index:10002;position: fixed;display: none;text-align: center;left: 25%;width: 50%;background-color: #F5F5F5;padding: 16px;border: 16px solid #444;border-radius: 10px;margin-top: 10px"; c.style.cssText = "z-index:10001;position: fixed;display: none;top: 0;left: 0;width: 100%;height: 100%;background-color: black;opacity: 0.8;";
        var d = xa("style"); qa.document.getElementsByTagName("head")[0].appendChild(d); d.sheet.insertRule(".goCXul { list-style: none; }", 0); d.sheet.insertRule(".goCXli {font:700 1.5em Helvetica, Arial, sans-serif;position: relative;min-width: 60px; }", 0); d.sheet.insertRule(".goCXa {color: #444;display: inline-block;padding: 4px;text-decoration: none;margin: 2px;border: 1px solid gray;border-radius: 10px; }", 0); b.addEventListener("contextmenu", Bh, !1); b.addEventListener("selectstart", Bh, !1); c.addEventListener("contextmenu",
            Bh, !1); b.className = "goCXforeground"; c.className = "goCXbackground"; qa.document.body && (qa.document.body.appendChild(b), qa.document.body.appendChild(c)); Ch = b; Dh = c; Eh = !0
    } function Bh(a) { a.preventDefault(); return !1 } yh.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; return this.isBeyondDragSize() || !a.lastInput.right ? !1 : a.lastInput.isTouchEvent && null !== this.defaultTouchContextMenu || null !== this.findObjectWithContextMenu() ? !0 : !1 }; yh.prototype.doStart = function () { this.Hw.set(this.diagram.firstInput.documentPoint) };
    yh.prototype.doStop = function () { this.hideContextMenu(); this.currentObject = null }; yh.prototype.findObjectWithContextMenu = function (a) { void 0 === a && (a = null); var b = this.diagram, c = b.lastInput, d = null; a instanceof P || (a instanceof N ? d = a : d = b.Tb(c.documentPoint, null, function (a) { return !a.layer.isTemporary })); if (null !== d) { for (a = d; null !== a;) { if (null !== a.contextMenu) return a; a = a.panel } if (b.lastInput.isTouchEvent && this.defaultTouchContextMenu) return d.part } else if (null !== b.contextMenu) return b; return null };
    yh.prototype.doActivate = function () { }; yh.prototype.doMouseDown = function () { vf.prototype.doMouseDown.call(this); if (this.isActive && this.currentContextMenu instanceof Cf) { var a = this.diagram.toolManager.findTool("Action"); null !== a && a.canStart() && (a.doActivate(), a.doMouseDown(), a.doDeactivate()) } this.diagram.toolManager.mouseDownTools.contains(this) && Fh(this) };
    yh.prototype.doMouseUp = function () { if (this.isActive && this.currentContextMenu instanceof Cf) { var a = this.diagram.toolManager.findTool("Action"); null !== a && a.canStart() && (a.doActivate(), a.doCancel(), a.doDeactivate()) } Fh(this) };
    function Fh(a) { var b = a.diagram; if (a.isActive) { var c = a.currentContextMenu; if (null !== c) { if (!(c instanceof Hf)) { var d = b.Tb(b.lastInput.documentPoint, null, null); null !== d && d.tg(c) && a.standardMouseClick(null, null) } a.stopTool(); a.canStart() && (b.currentTool = a, a.doMouseUp()) } } else a.canStart() && (Gh(a, !0), a.isActive || a.stopTool()) }
    function Gh(a, b, c) { void 0 === c && (c = null); b && a.standardMouseSelect(); if (!a.standardMouseClick()) if (a.isActive = !0, b = Ah, null === c && (c = a.findObjectWithContextMenu()), null !== c) { var d = c.contextMenu; null !== d ? (a.currentObject = c instanceof N ? c : null, a.showContextMenu(d, a.currentObject)) : null !== b && a.showContextMenu(b, a.currentObject) } else null !== b && a.showContextMenu(b, null) } yh.prototype.doMouseMove = function () { var a = this.diagram.toolManager.findTool("Action"); null !== a && a.doMouseMove(); this.isActive && this.diagram.toolManager.doMouseMove() };
    yh.prototype.showContextMenu = function (a, b) {
    !E || a instanceof Cf || a instanceof Hf || v("showContextMenu:contextMenu must be an Adornment or HTMLInfo."); null !== b && w(b, N, yh, "showContextMenu:obj"); var c = this.diagram; a !== this.currentContextMenu && this.hideContextMenu(); if (a instanceof Cf) {
    a.layerName = "Tool"; a.selectable = !1; a.scale = 1 / c.scale; a.category = this.name; null !== a.placeholder && (a.placeholder.scale = c.scale); var d = a.diagram; null !== d && d !== c && d.remove(a); c.add(a); null !== b ? a.adornedObject = b : a.data = c.model;
        a.bc(); this.positionContextMenu(a, b)
    } else a instanceof Hf && a.show(b, c, this); this.currentContextMenu = a
    }; yh.prototype.positionContextMenu = function (a) { if (null === a.placeholder) { var b = this.diagram, c = b.lastInput.documentPoint.copy(), d = a.measuredBounds, e = b.viewportBounds; b.lastInput.isTouchEvent && (c.x -= d.width); c.x + d.width > e.right && (c.x -= d.width + 5 / b.scale); c.x < e.x && (c.x = e.x); c.y + d.height > e.bottom && (c.y -= d.height + 5 / b.scale); c.y < e.y && (c.y = e.y); a.position = c } };
    yh.prototype.hideContextMenu = function () { var a = this.diagram, b = this.currentContextMenu; null !== b && (b instanceof Cf ? (a.remove(b), null !== this.St && this.St.wf(b.category), b.data = null, b.adornedObject = null) : b instanceof Hf && (null !== b.hide ? b.hide(a, this) : null !== b.mainElement && (b.mainElement.style.display = "none")), this.currentContextMenu = null, this.standardMouseOver()) };
    function Hh() {
        var a = new F; a.add(new xh("Copy", function (a) { a.commandHandler.copySelection() }, function (a) { return a.commandHandler.canCopySelection() })); a.add(new xh("Cut", function (a) { a.commandHandler.cutSelection() }, function (a) { return a.commandHandler.canCutSelection() })); a.add(new xh("Delete", function (a) { a.commandHandler.deleteSelection() }, function (a) { return a.commandHandler.canDeleteSelection() })); a.add(new xh("Paste", function (a) { a.commandHandler.pasteSelection(a.lastInput.documentPoint) }, function (a) { return a.commandHandler.canPasteSelection() }));
        a.add(new xh("Select All", function (a) { a.commandHandler.selectAll() }, function (a) { return a.commandHandler.canSelectAll() })); a.add(new xh("Undo", function (a) { a.commandHandler.undo() }, function (a) { return a.commandHandler.canUndo() })); a.add(new xh("Redo", function (a) { a.commandHandler.redo() }, function (a) { return a.commandHandler.canRedo() })); a.add(new xh("Scroll To Part", function (a) { a.commandHandler.scrollToPart() }, function (a) { return a.commandHandler.canScrollToPart() })); a.add(new xh("Zoom To Fit", function (a) { a.commandHandler.zoomToFit() },
            function (a) { return a.commandHandler.canZoomToFit() })); a.add(new xh("Reset Zoom", function (a) { a.commandHandler.resetZoom() }, function (a) { return a.commandHandler.canResetZoom() })); a.add(new xh("Group Selection", function (a) { a.commandHandler.groupSelection() }, function (a) { return a.commandHandler.canGroupSelection() })); a.add(new xh("Ungroup Selection", function (a) { a.commandHandler.ungroupSelection() }, function (a) { return a.commandHandler.canUngroupSelection() })); a.add(new xh("Edit Text", function (a) { a.commandHandler.editTextBlock() },
                function (a) { return a.commandHandler.canEditTextBlock() })); return a
    }
    yh.prototype.showDefaultContextMenu = function () {
        var a = this.diagram; null === this.Tt && (this.Tt = Hh()); Ch.innerHTML = ""; Dh.addEventListener("click", this.Fu, !1); var b = this, c = xa("ul"); c.className = "goCXul"; Ch.appendChild(c); c.innerHTML = ""; for (var d = this.Tt.iterator; d.next();) {
            var e = d.value, f = e.visible; if ("function" === typeof e.ex && ("function" !== typeof f || f(a))) {
                f = xa("li"); f.className = "goCXli"; var g = xa("a"); g.className = "goCXa"; g.href = "#"; g.Yx = e.ex; g.addEventListener("click", function (c) {
                    this.Yx(a); b.stopTool();
                    c.preventDefault(); return !1
                }, !1); g.textContent = e.text; f.appendChild(g); c.appendChild(f)
            }
        } Ch.style.display = "block"; Dh.style.display = "block"
    }; yh.prototype.hideDefaultContextMenu = function () { null !== this.currentContextMenu && this.currentContextMenu === Ah && (Ch.style.display = "none", Dh.style.display = "none", Dh.removeEventListener("click", this.Fu, !1), this.currentContextMenu = null) };
    na.Object.defineProperties(yh.prototype, {
        currentContextMenu: { configurable: !0, get: function () { return this.l }, set: function (a) { !E || null === a || a instanceof Cf || a instanceof Hf || v("ContextMenuTool.currentContextMenu must be an Adornment or HTMLInfo."); this.l = a; this.St = a instanceof Cf ? a.adornedPart : null } }, defaultTouchContextMenu: {
            configurable: !0, get: function () { !1 === Eh && null === Ah && Ih && zh(this); return Ah }, set: function (a) {
            !E || null === a || a instanceof Cf || a instanceof Hf || v("ContextMenuTool.defaultTouchContextMenu must be an Adornment or HTMLInfo.");
                null === a && (Eh = !0); Ah = a
            }
        }, currentObject: { configurable: !0, get: function () { return this.w }, set: function (a) { null !== a && w(a, N, yh, "currentObject"); this.w = a } }, mouseDownPoint: { configurable: !0, get: function () { return this.Hw } }
    }); var Ah = null, Eh = !1, Dh = null, Ch = null; yh.className = "ContextMenuTool"; Za("contextMenuTool", function () { return this.findTool("ContextMenu") }, function (a) { If(this, "ContextMenu", a, this.mouseUpTools) });
    function Jh() { 0 < arguments.length && Da(Jh); vf.call(this); this.name = "TextEditing"; this.kh = new Kh; this.Na = null; this.Ma = Lh; this.yi = null; this.na = Mh; this.L = 1; this.ca = !0; this.w = null; this.l = new Hf; this.Ut = null; Nh(this, this.l) } ma(Jh, vf);
    function Nh(a, b) {
        if (Ih) {
            var c = xa("textarea"); a.Ut = c; c.addEventListener("input", function () { if (null !== a.textBlock) { var b = a.zx(this.value); this.style.width = 20 + b.measuredBounds.width * this.fA + "px"; this.rows = b.lineCount } }, !1); c.addEventListener("keydown", function (b) { if (null !== a.textBlock) { var c = b.which; 13 === c ? (!1 === a.textBlock.isMultiline && b.preventDefault(), a.acceptText(Oh)) : 9 === c ? (a.acceptText(Ph), b.preventDefault()) : 27 === c && (a.doCancel(), null !== a.diagram && a.diagram.doFocus()) } }, !1); c.addEventListener("focus",
                function () { if (null !== a.currentTextEditor && a.state !== Mh) { var b = a.Ut; a.na === Qh && (a.na = Rh); "function" === typeof b.select && a.selectsTextOnActivate && (b.select(), b.setSelectionRange(0, 9999)) } }, !1); c.addEventListener("blur", function () { if (null !== a.currentTextEditor && a.state !== Mh) { var b = a.Ut; "function" === typeof b.focus && b.focus(); "function" === typeof b.select && a.selectsTextOnActivate && (b.select(), b.setSelectionRange(0, 9999)) } }, !1); b.valueFunction = function () { return c.value }; b.mainElement = c; b.show = function (a,
                    b, f) {
                        if (a instanceof Kh && f instanceof Jh) if (f.state === Sh) c.style.border = "3px solid red", c.focus(); else {
                            var d = a.oa(qd), e = b.position, k = b.scale, l = a.Fe() * k; l < f.minimumEditorScale && (l = f.minimumEditorScale); var m = a.naturalBounds.width * l + 6, n = a.naturalBounds.height * l + 2, p = (d.x - e.x) * k; d = (d.y - e.y) * k; c.value = a.text; b.div.style.font = a.font; c.style.position = "absolute"; c.style.zIndex = "100"; c.style.font = "inherit"; c.style.fontSize = 100 * l + "%"; c.style.lineHeight = "normal"; c.style.width = m + "px"; c.style.left = (p - m / 2 | 0) - 1 +
                                "px"; c.style.top = (d - n / 2 | 0) - 1 + "px"; c.style.textAlign = a.textAlign; c.style.margin = "0"; c.style.padding = "1px"; c.style.border = "0"; c.style.outline = "none"; c.style.whiteSpace = "pre-wrap"; c.style.overflow = "hidden"; c.rows = a.lineCount; c.fA = l; c.className = "goTXarea"; b.div.appendChild(c); c.focus(); f.selectsTextOnActivate && (c.select(), c.setSelectionRange(0, 9999))
                        }
                }; b.hide = function (a) { a.div.removeChild(c) }
        }
    }
    Jh.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; if (null === a || a.isReadOnly || !a.lastInput.left || this.isBeyondDragSize()) return !1; var b = a.Tb(a.lastInput.documentPoint); if (!(null !== b && b instanceof Kh && b.editable && b.part.canEdit())) return !1; b = b.part; return null === b || this.starting === Lh && !b.isSelected || this.starting === Th && 2 > a.lastInput.clickCount ? !1 : !0 }; Jh.prototype.doStart = function () { this.isActive || null === this.textBlock || this.doActivate() };
    Jh.prototype.doActivate = function () { if (!this.isActive) { var a = this.diagram; if (null !== a) { var b = this.textBlock; null === b && (b = a.Tb(a.lastInput.documentPoint)); if (null !== b && b instanceof Kh && (this.textBlock = b, null !== b.part)) { this.isActive = !0; this.na = Qh; var c = this.defaultTextEditor; null !== b.textEditor && (c = b.textEditor); this.kh = this.textBlock.copy(); var d = new L(this.textBlock.oa(fd), this.textBlock.oa(ud)); a.Mv(d); c.show(b, a, this); this.currentTextEditor = c } } } }; Jh.prototype.doCancel = function () { this.stopTool() };
    Jh.prototype.doMouseUp = function () { !this.isActive && this.canStart() && this.doActivate() }; Jh.prototype.doMouseDown = function () { this.isActive && this.acceptText(Uh) };
    Jh.prototype.acceptText = function (a) { switch (a) { case Uh: if (this.na === Vh) this.currentTextEditor instanceof HTMLElement && this.currentTextEditor.focus(); else if (this.na === Qh || this.na === Sh || this.na === Rh) this.na = Wh, Xh(this); break; case Yh: case Oh: case Ph: if (Oh !== a || !0 !== this.textBlock.isMultiline) if (this.na === Qh || this.na === Sh || this.na === Rh) this.na = Wh, Xh(this) } };
    function Xh(a) { var b = a.textBlock, c = a.diagram, d = a.currentTextEditor; if (null !== b && null !== d) { var e = b.text, f = ""; null !== d.valueFunction && (f = d.valueFunction()); a.isValidText(b, e, f) ? (a.Ca(a.name), a.na = Vh, a.transactionResult = a.name, b.text = f, null !== b.textEdited && b.textEdited(b, e, f), null !== c && c.ba("TextEdited", b, e), a.yg(), a.stopTool(), null !== c && c.doFocus()) : (a.na = Sh, null !== b.errorFunction && b.errorFunction(a, e, f), d.show(b, c, a)) } }
    Jh.prototype.doDeactivate = function () { var a = this.diagram; null !== a && (this.na = Mh, this.textBlock = null, null !== this.currentTextEditor && this.currentTextEditor.hide(a, this), this.isActive = !1) }; Jh.prototype.isValidText = function (a, b, c) { w(a, Kh, Jh, "isValidText:textblock"); var d = this.textValidation; if (null !== d && !d(a, b, c)) return !1; d = a.textValidation; return null === d || d(a, b, c) ? !0 : !1 }; Jh.prototype.zx = function (a) { var b = this.kh; b.text = a; b.measure(this.textBlock.nl, Infinity); return b };
    na.Object.defineProperties(Jh.prototype, {
        textBlock: { configurable: !0, get: function () { return this.Na }, set: function (a) { null !== a && w(a, Kh, Jh, "textBlock"); this.Na = a } }, currentTextEditor: { configurable: !0, get: function () { return this.w }, set: function (a) { this.w = a } }, defaultTextEditor: { configurable: !0, get: function () { return this.l }, set: function (a) { !E || a instanceof Hf || v("TextEditingTool.defaultTextEditor must be an HTMLInfo."); this.l = a } }, starting: {
            configurable: !0,
            get: function () { return this.Ma }, set: function (a) { tb(a, Jh, Jh, "starting"); this.Ma = a }
        }, textValidation: { configurable: !0, get: function () { return this.yi }, set: function (a) { null !== a && z(a, "function", Jh, "textValidation"); this.yi = a } }, minimumEditorScale: { configurable: !0, get: function () { return this.L }, set: function (a) { null !== a && z(a, "number", Jh, "minimumEditorScale"); this.L = a } }, selectsTextOnActivate: {
            configurable: !0, get: function () { return this.ca }, set: function (a) {
            null !== a && z(a,
                "boolean", Jh, "selectsTextOnActivate"); this.ca = a
            }
        }, state: { configurable: !0, get: function () { return this.na }, set: function (a) { this.na !== a && (tb(a, Jh, Jh, "starting"), this.na = a) } }
    }); Jh.prototype.measureTemporaryTextBlock = Jh.prototype.zx;
    var Yh = new D(Jh, "LostFocus", 0), Uh = new D(Jh, "MouseDown", 1), Ph = new D(Jh, "Tab", 2), Oh = new D(Jh, "Enter", 3), ai = new D(Jh, "SingleClick", 0), Lh = new D(Jh, "SingleClickSelected", 1), Th = new D(Jh, "DoubleClick", 2), Mh = new D(Jh, "StateNone", 0), Qh = new D(Jh, "StateActive", 1), Rh = new D(Jh, "StateEditing", 2), Wh = new D(Jh, "StateValidating", 3), Sh = new D(Jh, "StateInvalid", 4), Vh = new D(Jh, "StateValidated", 5); Jh.className = "TextEditingTool"; Jh.LostFocus = Yh; Jh.MouseDown = Uh; Jh.Tab = Ph; Jh.Enter = Oh; Jh.SingleClick = ai;
    Jh.SingleClickSelected = Lh; Jh.DoubleClick = Th; Jh.StateNone = Mh; Jh.StateActive = Qh; Jh.StateEditing = Rh; Jh.StateValidating = Wh; Jh.StateInvalid = Sh; Jh.StateValidated = Vh; Za("textEditingTool", function () { return this.findTool("TextEditing") }, function (a) { If(this, "TextEditing", a, this.mouseUpTools) });
    function bi() { ci || (di(), ci = !0); this.uw = ei; this.D = yf; this.vn = this.wn = null; this.cj = this.xn = this.yn = 0; this.Ek = this.oi = this.sb = this.Nr = this.Nf = !1; this.Sg = this.Fc = !0; this.fr = this.er = this.tw = null; this.sw = 0; this.hr = new Ub; this.$t = 600; this.$x = new J(0, 0); this.qw = this.pw = this.Rw = !1; this.Tm = new I; this.Bj = new Ub; this.hs = new I; this.gr = null } bi.prototype.ib = function (a) { this.D = a }; function ei(a, b, c, d) { a /= d / 2; return 1 > a ? c / 2 * a * a + b : -c / 2 * (--a * (a - 2) - 1) + b }
    function fi(a, b, c, d) { return a === d ? b + c : c * (-Math.pow(2, -10 * a / d) + 1) + b } bi.prototype.canStart = function () { return !0 }; t = bi.prototype; t.Ch = function (a, b) { this.Fc && (void 0 !== b && (this.gr = b), this.Sg || this.D.Ti) && (this.Tm.add(a), this.canStart(a) && (this.Nf && this.xd(), this.oi = this.sb = !0)) }; t.Rz = function (a, b) { this.Fc && (void 0 !== b && (this.gr = b), this.Sg || this.D.Ti) && (this.Tm.add(a), this.canStart(a) && (this.Nf && this.xd(), this.sb = !0)) };
    function gi(a) { if (a.Fc && (a.Tm.clear(), a.sb)) if (!a.Ek) a.sb = !1, a.oi = !1; else if (0 === a.cj) { var b = +new Date; a.cj = b; qa.requestAnimationFrame(function () { if (!1 !== a.sb && !a.Nf && a.cj === b) { var c = a.D; c.Ge("temporaryPixelRatio") && Yf(c); hi(c); a.sb = !1; a.oi = !1; c.ba("AnimationStarting"); ii(a, b) } }) } }
    t.sh = function (a, b, c, d, e, f) {
        if (!(!this.sb || (E && w(a, N, bi, "addToAnimation:obj"), "position" === b && c.A(d)) || a instanceof R && !a.isAnimated)) {
            var g = this.Bj; if (g.contains(a)) { var h = g.K(a); g = h.start; var k = h.end; void 0 === g[b] && (g[b] = ji(c)); e || (h.bv[b] = ji(d)); k[b] = ji(d) } else h = {}, k = {}, h[b] = ji(c), k[b] = ji(d), c = h.position, c instanceof J && !c.o() && this.Tm.contains("Expand SubGraph") && c.assign(k.position), h = new ki(h, k, e), g.add(a, h); e && 0 === b.indexOf("position:") && a instanceof R && (h.bv.location = ji(a.location)); f && (h.ut =
                !0); this.Ek = !0
        }
    }; function ji(a) { return a instanceof J ? a.copy() : a instanceof Zb ? a.copy() : a } function li(a, b) { if (!a.Nf) return !1; a = a.Bj.K(b); return null !== a && a.ut }
    function ii(a, b) {
        function c() { if (!1 !== e.Nf && e.cj === b) { var a = +new Date, f = a > r ? l : a - q; mi(e); ni(e, d, p, g, f, l); e.er && e.er(); Eg(d); oi(e); a > r ? pi(e) : qa.requestAnimationFrame(c) } } var d = a.D; if (null !== d) {
            var e = a, f = a.gr || {}, g = f.Py || a.uw, h = f.sA || null, k = f.tA || null, l = f.duration || a.$t, m = a.$x; for (f = a.Bj.iterator; f.next();) { var n = f.value.start.position; n instanceof J && (n.o() || n.assign(m)) } a.tw = g; a.er = h; a.fr = k; a.sw = l; a.hr = a.Bj; var p = a.hr; for (f = p.iterator; f.next();)h = f.value.end, h["position:placeholder"] && (k = f.key.findVisibleNode(),
                k instanceof xg && null !== k.placeholder && (m = k.placeholder, k = m.oa(fd), m = m.padding, k.x += m.left, k.y += m.top, h["position:placeholder"] = k)); a.Nf = !0; mi(a); ni(a, d, p, g, 0, l); Eg(a.D, !0); oi(a); var q = +new Date, r = q + l; e.cj === b && qa.requestAnimationFrame(function () { c() })
        }
    } function mi(a) { if (!a.Nr) { var b = a.D; a.Rw = b.skipsUndoManager; a.pw = b.skipsModelSourceBindings; a.qw = b.Yi; b.skipsUndoManager = !0; b.skipsModelSourceBindings = !0; b.Yi = !0; a.Nr = !0 } }
    function oi(a) { var b = a.D; b.skipsUndoManager = a.Rw; b.skipsModelSourceBindings = a.pw; b.Yi = a.qw; a.Nr = !1 } function ni(a, b, c, d, e, f) { for (c = c.iterator; c.next();) { var g = c.key, h = c.value, k = h.start, l = h.end, m = qi; for (n in l) "position" === n && (l["position:placeholder"] || l["position:node"]) || null === m.get(n) || m.get(n)(g, k[n], l[n], d, e, f, h) } d = b.rv; b.rv = !0; var n = a.uw; 0 !== a.yn && 0 !== a.xn && (c = a.yn, b.Da = n(e, c, a.xn - c, f)); null !== a.wn && null !== a.vn && (c = a.wn, a = a.vn, b.ua = new J(n(e, c.x, a.x - c.x, f), n(e, c.y, a.y - c.y, f))); b.rv = d }
    t.xd = function () { !0 === this.sb && (this.oi = this.sb = !1, this.cj = 0, this.Ek && this.D.ec()); this.Nf && this.Fc && pi(this) };
    function pi(a) {
    a.Nf = !1; a.Ek = !1; mi(a); for (var b = a.D, c = a.tw, d = a.sw, e = a.hr, f = a.hs.iterator; f.next();)f.value.v(); e = e.iterator; for (f = qi; e.next();) { var g = e.key, h = e.value, k = h.start, l = h.end, m = h.bv, n; for (n in l) if (null !== f.get(n)) { var p = n; !h.Vu || "position:node" !== p && "position:placeholder" !== p || (p = "position"); f.get(p)(g, k[n], void 0 !== m[n] ? m[n] : h.Vu ? k[n] : l[n], c, d, d) } h.Vu && void 0 !== m.location && g instanceof R && (g.location = m.location); h.ut && g instanceof R && g.Ob(!1) } for (c = a.D.links; c.next();)d = c.value, null !== d.bh &&
        (d.points = d.bh, d.bh = null); b.lt.clear(); hg(b, !1); b.Ya(); b.S(); b.hd(); ri(b); oi(a); a.fr && a.fr(); a.cj = 0; a.hr.clear(); a.fr = null; a.er = null; a.wn = null; a.vn = null; a.yn = 0; a.xn = 0; a.Bj.clear(); 0 < a.hs.count && a.hs.clear(); a.gr = null; b.ba("AnimationFinished"); b.ec()
    }
    t.Rp = function (a, b) { if (this.oi) { var c = b.actualBounds, d = null; b instanceof xg && (d = b.placeholder); null !== d ? (c = d.oa(fd), d = d.padding, c.x += d.left, c.y += d.top, this.sh(a, "position", c, a.position, !1)) : this.sh(a, "position", new J(c.x + c.width / 2, c.y + c.height / 2), a.position, !1); this.sh(a, "scale", .01, a.scale, !1); if (a instanceof xg) for (a = a.memberParts; a.next();)d = a.value, d instanceof V && this.Rp(d, b) } };
    t.Qp = function (a, b) { if (a.isVisible() && this.oi) { var c = null; b instanceof xg && (c = b.placeholder); null !== c ? this.sh(a, "position:placeholder", a.position, c, !0) : this.sh(a, "position:node", a.position, b, !0); this.sh(a, "scale", a.scale, .01, !0); this.sb && (c = this.Bj, c.contains(a) && (c.K(a).ut = !0)); if (a instanceof xg) for (a = a.memberParts; a.next();)c = a.value, c instanceof V && this.Qp(c, b) } }; function si(a, b, c) { a.sb && !b.A(c) && (null === a.wn && b.o() && null === a.vn && (a.wn = b.copy()), a.vn = c.copy(), a.Ek = !0) }
    function ti(a, b, c) { a.sb && a.D.Ti && (0 === a.yn && 0 === a.xn && (a.yn = b), a.xn = c, a.Ek = !0) }
    function di() {
        var a = new Ub; a.add("position", function (a, c, d, e, f, g) { f !== g ? a.Bt(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g)) : a.position = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g)) }); a.add("position:placeholder", function (a, c, d, e, f, g) { f !== g ? a.Bt(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g)) : a.position = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g)) }); a.add("position:node", function (a, c, d, e, f, g) {
            var b = a.actualBounds, k = d.actualBounds; d = k.x + k.width / 2 - b.width / 2; b = k.y + k.height / 2 - b.height / 2; f !== g ? a.Bt(e(f, c.x, d - c.x, g), e(f,
                c.y, b - c.y, g)) : a.position = new J(e(f, c.x, d - c.x, g), e(f, c.y, b - c.y, g))
        }); a.add("opacity", function (a, c, d, e, f, g) { a.opacity = e(f, c, d - c, g) }); a.add("scale", function (a, c, d, e, f, g) { a.scale = e(f, c, d - c, g) }); a.add("angle", function (a, c, d, e, f, g) { a.angle = e(f, c, d - c, g) }); a.add("visible", function (a, c, d, e, f, g) { a.visible = f !== g ? c : d }); qi = a
    }
    na.Object.defineProperties(bi.prototype, {
        animationReasons: { configurable: !0, get: function () { return this.Tm } }, isEnabled: { configurable: !0, get: function () { return this.Fc }, set: function (a) { z(a, "boolean", bi, "isEnabled"); this.Fc = a } }, duration: { configurable: !0, get: function () { return this.$t }, set: function (a) { z(a, "number", bi, "duration"); 1 > a && Ca(a, ">= 1", bi, "duration"); this.$t = a } }, isAnimating: { configurable: !0, get: function () { return this.Nf } }, isTicking: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Nr }
        }, isInitial: { configurable: !0, get: function () { return this.Sg }, set: function (a) { z(a, "boolean", bi, "isInitial"); this.Sg = a } }
    }); bi.prototype.stopAnimation = bi.prototype.xd; bi.prototype.addToAnimation = bi.prototype.sh; bi.prototype.prepareAnimation = bi.prototype.Rz; bi.prototype.prepareAutomaticAnimation = bi.prototype.Ch; var qi = null, ci = !1; bi.className = "AnimationManager"; function ki(a, b, c) { this.start = a; this.end = b; this.bv = {}; this.Vu = c; this.ut = !1 }
    ki.className = "AnimationStates"; function ui() { 0 < arguments.length && Da(ui); qb(this); this.D = null; this.Ga = new F; this.Wa = ""; this.mb = 1; this.w = !1; this.Fj = this.L = this.Ph = this.Oh = this.Nh = this.Mh = this.Kh = this.Lh = this.Jh = this.Rh = this.Ih = this.Qh = this.Hh = this.Gh = !0; this.l = !1; this.Qo = [] } t = ui.prototype; t.ib = function (a) { this.D = a };
    t.toString = function (a) {
    void 0 === a && (a = 0); var b = 'Layer "' + this.name + '"'; if (0 >= a) return b; for (var c = 0, d = 0, e = 0, f = 0, g = 0, h = this.Ga.iterator; h.next();) { var k = h.value; k instanceof xg ? e++ : k instanceof V ? d++ : k instanceof Q ? f++ : k instanceof Cf ? g++ : c++ } h = ""; 0 < c && (h += c + " Parts "); 0 < d && (h += d + " Nodes "); 0 < e && (h += e + " Groups "); 0 < f && (h += f + " Links "); 0 < g && (h += g + " Adornments "); if (1 < a) for (a = this.Ga.iterator; a.next();)c = a.value, h += "\n    " + c.toString(), d = c.data, null !== d && Jb(d) && (h += " #" + Jb(d)), c instanceof V ? h += " " +
        Wa(d) : c instanceof Q && (h += " " + Wa(c.fromNode) + " " + Wa(c.toNode)); return b + " " + this.Ga.count + ": " + h
    };
    t.Tb = function (a, b, c) { void 0 === b && (b = null); void 0 === c && (c = null); if (!1 === this.Fj) return null; E && !a.o() && v("findObjectAt: Point must have a real value, not: " + a.toString()); var d = !1; null !== this.diagram && this.diagram.viewportBounds.ea(a) && (d = !0); for (var e = J.alloc(), f = this.Ga.j, g = f.length; g--;) { var h = f[g]; if ((!0 !== d || !1 !== Dg(h)) && h.isVisible() && (e.assign(a), ac(e, h.td), h = h.Tb(e, b, c), null !== h && (null !== b && (h = b(h)), null !== h && (null === c || c(h))))) return J.free(e), h } J.free(e); return null };
    t.Ji = function (a, b, c, d) { void 0 === b && (b = null); void 0 === c && (c = null); d instanceof F || d instanceof I || (d = new I); if (!1 === this.Fj) return d; E && !a.o() && v("findObjectsAt: Point must have a real value, not: " + a.toString()); var e = !1; null !== this.diagram && this.diagram.viewportBounds.ea(a) && (e = !0); for (var f = J.alloc(), g = this.Ga.j, h = g.length; h--;) { var k = g[h]; if ((!0 !== e || !1 !== Dg(k)) && k.isVisible()) { f.assign(a); ac(f, k.td); var l = k; k.Ji(f, b, c, d) && (null !== b && (l = b(l)), null === l || null !== c && !c(l) || d.add(l)) } } J.free(f); return d };
    t.pg = function (a, b, c, d, e) { void 0 === b && (b = null); void 0 === c && (c = null); void 0 === d && (d = !1); e instanceof F || e instanceof I || (e = new I); if (!1 === this.Fj) return e; E && !a.o() && v("findObjectsIn: Rect must have a real value, not: " + a.toString()); var f = !1; null !== this.diagram && this.diagram.viewportBounds.pf(a) && (f = !0); for (var g = this.Ga.j, h = g.length; h--;) { var k = g[h]; if ((!0 !== f || !1 !== Dg(k)) && k.isVisible()) { var l = k; k.pg(a, b, c, d, e) && (null !== b && (l = b(l)), null === l || null !== c && !c(l) || e.add(l)) } } return e };
    t.qg = function (a, b, c, d, e, f) {
    void 0 === c && (c = null); void 0 === d && (d = null); void 0 === e && (e = !0); if (!1 !== e && !0 !== e) { if (e instanceof F || e instanceof I) f = e; e = !0 } f instanceof F || f instanceof I || (f = new I); if (!1 === this.Fj) return f; E && !a.o() && v("findObjectsNear: Point must have a real value, not: " + a.toString()); var g = !1; null !== this.diagram && this.diagram.viewportBounds.ea(a) && (g = !0); for (var h = J.alloc(), k = J.alloc(), l = this.Ga.j, m = l.length; m--;) {
        var n = l[m]; if ((!0 !== g || !1 !== Dg(n)) && n.isVisible()) {
            h.assign(a); ac(h, n.td);
            k.h(a.x + b, a.y); ac(k, n.td); var p = n; n.qg(h, k, c, d, e, f) && (null !== c && (p = c(p)), null === p || null !== d && !d(p) || f.add(p))
        }
    } J.free(h); J.free(k); return f
    };
    t.kd = function (a, b) {
        if (this.visible) {
            var c = void 0 === b ? a.viewportBounds : b; var d = this.Ga.j, e = d.length; a = Qa(); b = Qa(); for (var f = 0; f < e; f++) { var g = d[f]; g.Gw = f; g instanceof Q && !1 === g.Mc || g instanceof Cf && null !== g.adornedPart || (Lc(g.actualBounds, c, 10) ? (g.kd(!0), a.push(g)) : (g.kd(!1), null !== g.adornments && 0 < g.adornments.count && b.push(g))) } for (c = 0; c < a.length; c++)for (d = a[c], vi(d), d = d.adornments; d.next();)e = d.value, e.measure(Infinity, Infinity), e.arrange(), e.kd(!0); for (c = 0; c < b.length; c++)d = b[c], d.updateAdornments(),
                wi(d, !0); Ta(a); Ta(b)
        }
    }; t.jc = function (a, b, c) { if (this.visible && 0 !== this.mb && (void 0 === c && (c = !0), c || !this.isTemporary)) { c = this.Ga.j; var d = c.length; if (0 !== d) { 1 !== this.mb && (a.globalAlpha = this.mb); var e = this.Qo; e.length = 0; for (var f = b.scale, g = 0; g < d; g++) { var h = c[g]; if (Dg(h)) { if (h instanceof Q && (h.isOrthogonal && e.push(h), !1 === h.Mc)) continue; var k = h.actualBounds; k.width * f > b.qe || k.height * f > b.qe ? h.jc(a, b) : xi(a, h) } } a.globalAlpha = 1 } } };
    function xi(a, b) {
        var c = b.actualBounds, d = b.naturalBounds; if (0 !== c.width && 0 !== c.height && !isNaN(c.x) && !isNaN(c.y) && b.isVisible()) {
            var e = b.transform; null !== b.areaBackground && (yi(b, a, b.areaBackground, !0, !0, d, c), a.fillRect(c.x, c.y, c.width, c.height)); null === b.areaBackground && null === b.background && (yi(b, a, "rgba(0,0,0,0.3)", !0, !1, d, c), a.fillRect(c.x, c.y, c.width, c.height)); null !== b.background && (a.transform(e.m11, e.m12, e.m21, e.m22, e.dx, e.dy), yi(b, a, b.background, !0, !1, d, c), a.fillRect(0, 0, d.width / 2, d.height / 2),
                e.it() || (b = 1 / (e.m11 * e.m22 - e.m12 * e.m21), a.transform(e.m22 * b, -e.m12 * b, -e.m21 * b, e.m11 * b, b * (e.m21 * e.dy - e.m22 * e.dx), b * (e.m12 * e.dx - e.m11 * e.dy))))
        }
    } t.g = function (a, b, c, d, e) { var f = this.diagram; null !== f && f.cb(of, a, this, b, c, d, e) }; t.Ri = function (a, b, c) { var d = this.Ga; b.hi = this; if (a >= d.count) a = d.count; else if (d.O(a) === b) return -1; d.Lb(a, b); b.hq(c); d = this.diagram; null !== d && (c ? d.S() : d.Ri(b)); zi(this, a, b); return a };
    t.zc = function (a, b, c) { if (!c && b.layer !== this && null !== b.layer) return b.layer.zc(a, b, c); var d = this.Ga; if (0 > a || a >= d.length) { if (a = d.indexOf(b), 0 > a) return -1 } else if (d.O(a) !== b && (a = d.indexOf(b), 0 > a)) return -1; b.iq(c); d.nb(a); d = this.diagram; null !== d && (c ? d.S() : d.zc(b)); b.hi = null; return a };
    function zi(a, b, c) { b = Ai(a, b, c); if (c instanceof xg && null !== c && isNaN(c.zOrder)) { if (0 !== c.memberParts.count) { for (var d = -1, e = a.Ga.j, f = e.length, g = 0; g < f; g++) { var h = e[g]; if (h === c && (b = g, 0 <= d)) break; if (0 > d && h.containingGroup === c && (d = g, 0 <= b)) break } !(0 > d) && d < b && (e = a.Ga, e.nb(b), e.Lb(d, c)) } c = c.containingGroup; null !== c && zi(a, -1, c) } }
    function Ai(a, b, c) {
        var d = c.zOrder; if (isNaN(d)) return b; a = a.Ga; var e = a.count; if (1 >= e) return b; 0 > b && (b = a.indexOf(c)); if (0 > b) return -1; for (var f = b - 1, g = NaN; 0 <= f;) { g = a.O(f).zOrder; if (!isNaN(g)) break; f-- } for (var h = b + 1, k = NaN; h < e;) { k = a.O(h).zOrder; if (!isNaN(k)) break; h++ } if (!isNaN(g) && g > d) for (; ;) { if (-1 === f || g <= d) { f++; if (f === b) break; a.nb(b); a.Lb(f, c); return f } for (g = NaN; 0 <= --f && (g = a.O(f).zOrder, isNaN(g));); } else if (!isNaN(k) && k < d) for (; ;) {
            if (h === e || k >= d) { h--; if (h === b) break; a.nb(b); a.Lb(h, c); return h } for (k = NaN; ++h <
                e && (k = a.O(h).zOrder, isNaN(k)););
        } return b
    } t.clear = function () { for (var a = this.Ga.Oa(), b = a.length, c = 0; c < b; c++)a[c].kd(!1), this.zc(-1, a[c], !1); this.Qo.length = 0 };
    na.Object.defineProperties(ui.prototype, {
        parts: { configurable: !0, get: function () { return this.Ga.iterator } }, partsBackwards: { configurable: !0, get: function () { return this.Ga.iteratorBackwards } }, diagram: { configurable: !0, get: function () { return this.D } }, name: {
            configurable: !0, get: function () { return this.Wa }, set: function (a) {
                z(a, "string", ui, "name"); var b = this.Wa; if (b !== a) {
                    var c = this.diagram; if (null !== c) for ("" === b && v("Cannot rename default Layer to: " + a), c =
                        c.layers; c.next();)c.value.name === a && v("Layer.name is already present in this diagram: " + a); this.Wa = a; this.g("name", b, a); for (a = this.Ga.iterator; a.next();)a.value.layerName = this.Wa
                }
            }
        }, opacity: { configurable: !0, get: function () { return this.mb }, set: function (a) { var b = this.mb; b !== a && (z(a, "number", ui, "opacity"), (0 > a || 1 < a) && Ca(a, "0 <= value <= 1", ui, "opacity"), this.mb = a, this.g("opacity", b, a), a = this.diagram, null !== a && a.S()) } }, isTemporary: {
            configurable: !0, get: function () { return this.w },
            set: function (a) { var b = this.w; b !== a && (z(a, "boolean", ui, "isTemporary"), this.w = a, this.g("isTemporary", b, a)) }
        }, visible: { configurable: !0, get: function () { return this.L }, set: function (a) { var b = this.L; if (b !== a) { z(a, "boolean", ui, "visible"); this.L = a; this.g("visible", b, a); for (b = this.Ga.iterator; b.next();)b.value.Ob(a); a = this.diagram; null !== a && a.S() } } }, pickable: {
            configurable: !0, get: function () { return this.Fj }, set: function (a) {
                var b = this.Fj; b !== a && (z(a, "boolean", ui, "pickable"), this.Fj =
                    a, this.g("pickable", b, a))
            }
        }, isBoundsIncluded: { configurable: !0, get: function () { return this.l }, set: function (a) { this.l !== a && (this.l = a, null !== this.diagram && this.diagram.Ya()) } }, allowCopy: { configurable: !0, get: function () { return this.Gh }, set: function (a) { var b = this.Gh; b !== a && (z(a, "boolean", ui, "allowCopy"), this.Gh = a, this.g("allowCopy", b, a)) } }, allowDelete: {
            configurable: !0, get: function () { return this.Hh }, set: function (a) {
                var b = this.Hh; b !== a && (z(a, "boolean", ui, "allowDelete"),
                    this.Hh = a, this.g("allowDelete", b, a))
            }
        }, allowTextEdit: { configurable: !0, get: function () { return this.Qh }, set: function (a) { var b = this.Qh; b !== a && (z(a, "boolean", ui, "allowTextEdit"), this.Qh = a, this.g("allowTextEdit", b, a)) } }, allowGroup: { configurable: !0, get: function () { return this.Ih }, set: function (a) { var b = this.Ih; b !== a && (z(a, "boolean", ui, "allowGroup"), this.Ih = a, this.g("allowGroup", b, a)) } }, allowUngroup: {
            configurable: !0, get: function () { return this.Rh }, set: function (a) {
                var b =
                    this.Rh; b !== a && (z(a, "boolean", ui, "allowUngroup"), this.Rh = a, this.g("allowUngroup", b, a))
            }
        }, allowLink: { configurable: !0, get: function () { return this.Jh }, set: function (a) { var b = this.Jh; b !== a && (z(a, "boolean", ui, "allowLink"), this.Jh = a, this.g("allowLink", b, a)) } }, allowRelink: { configurable: !0, get: function () { return this.Lh }, set: function (a) { var b = this.Lh; b !== a && (z(a, "boolean", ui, "allowRelink"), this.Lh = a, this.g("allowRelink", b, a)) } }, allowMove: {
            configurable: !0, get: function () { return this.Kh },
            set: function (a) { var b = this.Kh; b !== a && (z(a, "boolean", ui, "allowMove"), this.Kh = a, this.g("allowMove", b, a)) }
        }, allowReshape: { configurable: !0, get: function () { return this.Mh }, set: function (a) { var b = this.Mh; b !== a && (z(a, "boolean", ui, "allowReshape"), this.Mh = a, this.g("allowReshape", b, a)) } }, allowResize: { configurable: !0, get: function () { return this.Nh }, set: function (a) { var b = this.Nh; b !== a && (z(a, "boolean", ui, "allowResize"), this.Nh = a, this.g("allowResize", b, a)) } }, allowRotate: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Oh }, set: function (a) { var b = this.Oh; b !== a && (z(a, "boolean", ui, "allowRotate"), this.Oh = a, this.g("allowRotate", b, a)) }
        }, allowSelect: { configurable: !0, get: function () { return this.Ph }, set: function (a) { var b = this.Ph; b !== a && (z(a, "boolean", ui, "allowSelect"), this.Ph = a, this.g("allowSelect", b, a)) } }
    }); ui.prototype.findObjectsNear = ui.prototype.qg; ui.prototype.findObjectsIn = ui.prototype.pg; ui.prototype.findObjectsAt = ui.prototype.Ji; ui.prototype.findObjectAt = ui.prototype.Tb;
    ui.className = "Layer";
    function P(a) {
        function b() { c.removeEventListener(qa.document, "DOMContentLoaded", b, !1); c.setRTL() } 1 < arguments.length && v("Diagram constructor can only take one optional argument, the DIV HTML element or its id."); Bi || (Ci(), Bi = !0); qb(this); yf = this; bb = []; this.pb = !0; this.Dk = new bi; this.Dk.ib(this); this.Jb = 17; this.Xn = !1; this.wu = "default"; this.Ja = null; var c = this; Ih && (null !== qa.document.body ? this.setRTL() : c.addEventListener(qa.document, "DOMContentLoaded", b, !1)); this.Ra = new F; this.ya = this.Aa = 0; this.Ea = null;
        this.uu = new Ub; this.eg = this.$c = null; this.Kv(); this.hl = null; this.Jv(); this.ua = (new J(NaN, NaN)).freeze(); this.kr = this.Da = 1; this.Er = (new J(NaN, NaN)).freeze(); this.Fr = NaN; this.Zr = 1E-4; this.Xr = 100; this.ub = new $b; this.Os = (new J(NaN, NaN)).freeze(); this.vr = (new L(NaN, NaN, NaN, NaN)).freeze(); this.ui = (new Hc(0, 0, 0, 0)).freeze(); this.Kj = Di; this.ys = !1; this.ts = this.ps = null; this.ej = Ei; this.gj = Qd; this.ci = Ei; this.Sn = Qd; this.Gr = this.Dr = fd; this.oc = !0; this.Tn = !1; this.Fd = new I; this.Yh = new Ub; this.Bn = !0; this.Xm = 250; this.Fk =
            -1; this.Ym = (new Hc(16, 16, 16, 16)).freeze(); this.Vk = this.sd = !1; this.al = !0; this.Zh = new kf; this.Zh.diagram = this; this.$e = new kf; this.$e.diagram = this; this.uj = new kf; this.uj.diagram = this; this.re = this.Cf = null; this.Ql = !1; this.Wt = this.Xt = null; this.Sq = qa.PointerEvent && (gb || ib || jb) && qa.navigator && !1 !== qa.navigator.msPointerEnabled; Fi(this); this.Ai = new I; this.Or = !0; this.Js = Gi; this.Xb = !1; this.Ls = Jg; this.Na = null; Hi.add("Model", Ii); this.ca = this.Ma = this.Wb = null; this.dr = ""; this.un = "auto"; this.Tf = this.cs = this.Vf = this.Wf =
                this.Yf = this.Ef = this.If = this.Df = null; this.Ar = !1; this.Ff = this.jg = this.Xf = this.Uf = null; this.pu = !1; this.su = {}; this.zl = [null, null]; this.L = null; this.Vt = this.Bu = this.Eh = this.eh = !1; this.Oc = !0; this.qj = this.$b = !1; this.ac = null; var d = this; this.zg = function (a) { var b = d.partManager; if (a.model === b.diagram.model && b.diagram.fa) { b.diagram.fa = !1; try { var c = a.change; "" === a.modelChange && c === of && b.updateDataBindings(a.object, a.propertyName) } finally { b.diagram.fa = !0 } } }; this.Gm = function (a) { d.partManager.doModelChanged(a) };
        this.Tw = !0; this.ie = -2; this.Gj = new Ub; this.ru = new F; this.Of = !1; this.Hh = this.Gh = this.Kq = this.Fc = !0; this.Lq = !1; this.Rq = this.Pq = this.Ph = this.Oh = this.Nh = this.Mh = this.Kh = this.Lh = this.Jh = this.Oq = this.Rh = this.Ih = this.Qh = this.Mq = !0; this.Se = this.Nc = !1; this.Qq = this.Nq = this.Cr = this.Br = !0; this.xs = this.vs = 16; this.yu = this.us = !1; this.mp = this.ws = null; this.zu = this.Au = 0; this.gb = (new Hc(5)).freeze(); this.Iq = (new I).freeze(); this.Yr = 999999999; this.Gq = (new I).freeze(); this.di = this.oj = this.Rg = !0; this.ai = this.Qg = !1; this.ic =
            null; this.Cg = !0; this.je = !1; this.Hq = new I; this.Ew = new I; this.Qb = null; this.Oo = 1; this.Nw = 0; this.Ae = { scale: 1, position: new J, bounds: new L, wx: !1 }; this.Sw = (new L(NaN, NaN, NaN, NaN)).freeze(); this.Lp = (new Zb(NaN, NaN)).freeze(); this.zn = (new L(NaN, NaN, NaN, NaN)).freeze(); this.Pr = !1; this.pr = null; Ji(this); this.Ur = this.yr = this.fs = this.ww = this.vw = this.xw = this.Vg = this.$h = this.Zf = null; Ki(this); this.Hb = null; this.xr = !1; this.Nk = null; this.partManager = new Ii; this.toolManager = new $a; this.toolManager.initializeStandardTools();
        this.currentTool = this.defaultTool = this.toolManager; this.nr = null; this.Pk = new Lf; this.ks = this.js = null; this.Cp = !1; this.commandHandler = Li(); this.model = Mi(); this.eh = !0; this.layout = new Ni; this.eh = !1; this.zw = this.Zt = null; this.Pb = 1; this.jh = null; this.qe = 1; this.Ao = 0; this.Bo = [0, 0, 0, 0, 0]; this.Co = 0; this.Hd = 1; this.ol = 0; this.Rr = new J; this.Gu = 500; this.Tq = new J; this.Te = !1; this.preventDefault = this.tt = this.om = this.pm = this.nm = this.mm = this.nk = this.qk = this.pk = this.lk = this.mk = this.fw = this.Yv = this.Zv = this.$v = this.ti = this.hp =
            this.si = this.gp = null; this.w = !1; this.bi = new Oi; this.Gs = !1; void 0 !== a && Pi(this, a); this.pb = !1
    } P.prototype.clear = function () { this.model.clear(); Qi = null; Ri = ""; Si(this, !1); this.zn = (new L(NaN, NaN, NaN, NaN)).freeze(); this.S() };
    function Si(a, b) { var c = null; null !== a.Hb && (c = a.Hb.part); a.animationManager.xd(); for (var d = [], e = a.Ra.length, f = 0; f < e; f++) { var g = a.Ra.j[f]; if (b) for (var h = g.parts; h.next();) { var k = h.value; k !== c && null === k.data && d.push(k) } g.clear() } a.partManager.clear(); a.Fd.clear(); a.Yh.clear(); a.Ai.clear(); a.Vp(); a.Qu(); a.Nk = null; Ra = []; null !== c && (a.add(c), a.partManager.parts.remove(c)); if (b) for (b = 0; b < d.length; b++)a.add(d[b]) } function Li() { return null }
    P.prototype.reset = function () {
    this.pb = !0; this.clear(); this.Dk = new bi; this.Dk.ib(this); this.Ra = new F; this.Kv(); this.Jv(); this.ua = (new J(NaN, NaN)).freeze(); this.Da = 1; this.Er = (new J(NaN, NaN)).freeze(); this.Fr = NaN; this.Zr = 1E-4; this.Xr = 100; this.Os = (new J(NaN, NaN)).freeze(); this.vr = (new L(NaN, NaN, NaN, NaN)).freeze(); this.ui = (new Hc(0, 0, 0, 0)).freeze(); this.Kj = Di; this.ys = !1; this.ts = this.ps = null; this.ej = Ei; this.gj = Qd; this.ci = Ei; this.Sn = Qd; this.Gr = this.Dr = fd; this.Xm = 250; this.Ym = (new Hc(16, 16, 16, 16)).freeze();
        this.Or = !0; this.Js = Gi; this.Ls = Jg; this.un = "auto"; this.Tf = this.cs = this.Vf = this.Wf = this.Yf = this.Ef = this.If = this.Df = null; this.Ar = !1; this.Ff = this.jg = this.Xf = this.Uf = null; this.Of = !1; this.Hh = this.Gh = this.Kq = this.Fc = !0; this.Lq = !1; this.Qq = this.Nq = this.Cr = this.Br = this.Rq = this.Pq = this.Ph = this.Oh = this.Nh = this.Mh = this.Kh = this.Lh = this.Jh = this.Oq = this.Rh = this.Ih = this.Qh = this.Mq = !0; this.xs = this.vs = 16; this.gb = (new Hc(5)).freeze(); this.Yr = 999999999; this.ic = null; this.Pr = !1; this.Pb = 1; this.jh = null; this.Ao = 0; this.Bo = [0,
            0, 0, 0, 0]; this.Co = 0; Ki(this); this.Hb = null; this.partManager = new Ii; this.toolManager = new $a; this.toolManager.initializeStandardTools(); this.ks = this.js = this.nr = null; this.Cp = !1; this.Pk.reset(); this.uu = new Ub; this.uu.clear(); this.currentTool = this.defaultTool = this.toolManager; this.commandHandler = Li(); this.eh = !0; Ji(this); this.layout = new Ni; this.eh = !1; this.model = Mi(); this.model.undoManager = new tf; this.je = !1; this.al = !0; this.pb = this.sd = !1; this.S(); this.re = this.Cf = null; Fi(this); this.dr = ""
    };
    function Ki(a) {
    a.Zf = new Ub; var b = new V, c = new Kh; c.bind(new Ti("text", "", Wa)); b.add(c); a.xw = b; a.Zf.add("", b); b = new V; c = new Kh; c.stroke = "brown"; c.bind(new Ti("text", "", Wa)); b.add(c); a.Zf.add("Comment", b); b = new V; b.selectable = !1; b.avoidable = !1; c = new Hg; c.figure = "Ellipse"; c.fill = "black"; c.stroke = null; c.desiredSize = (new Zb(3, 3)).ia(); b.add(c); a.Zf.add("LinkLabel", b); a.$h = new Ub; b = new xg; b.selectionObjectName = "GROUPPANEL"; b.type = W.Vertical; c = new Kh; c.font = "bold 12pt sans-serif"; c.bind(new Ti("text", "",
        Wa)); b.add(c); c = new W(W.Auto); c.name = "GROUPPANEL"; var d = new Hg; d.figure = "Rectangle"; d.fill = "rgba(128,128,128,0.2)"; d.stroke = "black"; c.add(d); d = new lh; d.padding = (new Hc(5, 5, 5, 5)).ia(); c.add(d); b.add(c); a.vw = b; a.$h.add("", b); a.Vg = new Ub; b = new Q; c = new Hg; c.isPanelMain = !0; b.add(c); c = new Hg; c.toArrow = "Standard"; c.fill = "black"; c.stroke = null; c.strokeWidth = 0; b.add(c); a.ww = b; a.Vg.add("", b); b = new Q; c = new Hg; c.isPanelMain = !0; c.stroke = "brown"; b.add(c); a.Vg.add("Comment", b); b = new Cf; b.type = W.Auto; c = new Hg; c.fill =
            null; c.stroke = "dodgerblue"; c.strokeWidth = 3; b.add(c); c = new lh; c.margin = (new Hc(1.5, 1.5, 1.5, 1.5)).ia(); b.add(c); a.fs = b; a.yr = b; b = new Cf; b.type = W.Link; c = new Hg; c.isPanelMain = !0; c.fill = null; c.stroke = "dodgerblue"; c.strokeWidth = 3; b.add(c); a.Ur = b
    }
    P.prototype.setRTL = function (a) { a = void 0 === a ? this.div : a; null === a && (a = qa.document.body); var b = xa("div"); b.dir = "rtl"; b.style.cssText = "font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll;"; b.textContent = "A"; a.appendChild(b); var c = "reverse"; 0 < b.scrollLeft ? c = "default" : (b.scrollLeft = 1, 0 === b.scrollLeft && (c = "negative")); a.removeChild(b); this.wu = c };
    P.prototype.setScrollWidth = function (a) {
        a = void 0 === a ? this.div : a; null === a && (a = qa.document.body); var b = 0; if (Ih) {
            var c = Ui; b = Vi; null === c && (c = Ui = xa("p"), c.style.width = "100%", c.style.height = "200px", c.style.boxSizing = "content-box", b = Vi = xa("div"), b.style.position = "absolute", b.style.visibility = "hidden", b.style.width = "200px", b.style.height = "150px", b.style.boxSizing = "content-box", b.appendChild(c)); b.style.overflow = "hidden"; a.appendChild(b); var d = c.offsetWidth; b.style.overflow = "scroll"; c = c.offsetWidth; d === c &&
                (c = b.clientWidth); a.removeChild(b); b = d - c; 0 !== b || lb || (b = 11)
        } this.Jb = b
    }; P.prototype.hb = function (a) { a.classType === P ? this.autoScale = a : Fa(this, a) }; P.prototype.toString = function (a) { void 0 === a && (a = 0); var b = ""; this.div && this.div.id && (b = this.div.id); b = 'Diagram "' + b + '"'; if (0 >= a) return b; for (var c = this.Ra.iterator; c.next();)b += "\n  " + c.value.toString(a - 1); return b }; P.prototype.addEventListener = function (a, b, c, d) { a.addEventListener(b, c, d) };
    P.prototype.removeEventListener = function (a, b, c, d) { a.removeEventListener(b, c, d) };
    function Wi(a) {
        var b = a.Ea.Ha; b instanceof HTMLCanvasElement && (a.Sq ? (a.addEventListener(b, "pointerdown", a.mm, !1), a.addEventListener(b, "pointermove", a.nm, !1), a.addEventListener(b, "pointerup", a.pm, !1), a.addEventListener(b, "pointerout", a.om, !1)) : (a.addEventListener(b, "touchstart", a.$v, !1), a.addEventListener(b, "touchmove", a.Zv, !1), a.addEventListener(b, "touchend", a.Yv, !1), a.addEventListener(b, "mousemove", a.mk, !1), a.addEventListener(b, "mousedown", a.lk, !1), a.addEventListener(b, "mouseup", a.pk, !1), a.addEventListener(b,
            "mouseout", a.nk, !1)), a.addEventListener(b, "mouseenter", a.Ky, !1), a.addEventListener(b, "mouseleave", a.Ly, !1), a.addEventListener(b, "wheel", a.qk, !1), a.addEventListener(b, "keydown", a.Ez, !1), a.addEventListener(b, "keyup", a.Fz, !1), a.addEventListener(b, "blur", a.xy, !1), a.addEventListener(b, "focus", a.yy, !1), a.addEventListener(b, "selectstart", function (a) { a.preventDefault(); return !1 }, !1), a.addEventListener(b, "contextmenu", function (a) { a.preventDefault(); return !1 }, !1), a.addEventListener(b, "gesturestart", function (b) {
                a.toolManager.gestureBehavior !==
                Ff && (a.toolManager.gestureBehavior === Ef ? b.preventDefault() : a.Te && a.lastInput.handled || (b.preventDefault(), a.Oo = a.scale, a.currentTool.doCancel()))
            }, !1), a.addEventListener(b, "gesturechange", function (b) {
                if (a.toolManager.gestureBehavior !== Ff) if (a.toolManager.gestureBehavior === Ef) b.preventDefault(); else if (!a.Te || !a.lastInput.handled) {
                    b.preventDefault(); var c = b.scale; if (null !== a.Oo) {
                        var e = a.Ea.getBoundingClientRect(); b = new J(b.pageX - window.scrollX - a.Aa / e.width * e.left, b.pageY - window.scrollY - a.ya / e.height *
                            e.top); c = a.Oo * c; e = a.commandHandler; if (c !== a.scale && e.canResetZoom(c)) { var f = a.zoomPoint; a.zoomPoint = b; e.resetZoom(c); a.zoomPoint = f }
                    }
                }
            }, !1), a.addEventListener(qa, "resize", a.fw, !1))
    } function Yf(a) { 30 < a.Ao && (a.jh = 1) } function hg(a, b) { null !== a.jh && (a.jh = null, b && a.tt(), a.Ao = 0, a.Bo = [0, 0, 0, 0, 0], a.Co = 0) } P.prototype.computePixelRatio = function () { return null !== this.jh ? this.jh : qa.devicePixelRatio || 1 }; P.prototype.doMouseMove = function () { this.currentTool.doMouseMove() }; P.prototype.doMouseDown = function () { this.currentTool.doMouseDown() };
    P.prototype.doMouseUp = function () { this.currentTool.doMouseUp() }; P.prototype.doMouseWheel = function () { this.currentTool.doMouseWheel() }; P.prototype.doKeyDown = function () { this.currentTool.doKeyDown() }; P.prototype.doKeyUp = function () { this.currentTool.doKeyUp() }; P.prototype.doFocus = function () { this.focus() }; P.prototype.focus = function () { if (this.Ea) if (this.scrollsPageOnFocus) this.Ea.focus(); else { var a = qa.scrollX || qa.pageXOffset, b = qa.scrollY || qa.pageYOffset; this.Ea.focus(); qa.scrollTo(a, b) } }; P.prototype.yy = function () { this.D.ba("GainedFocus") };
    P.prototype.xy = function () { this.D.ba("LostFocus") }; function hi(a) { if (null !== a.Ea) { var b = a.Ja; if (0 !== b.clientWidth && 0 !== b.clientHeight) { a.setScrollWidth(); var c = a.ai ? a.Jb : 0, d = a.Qg ? a.Jb : 0, e = a.Pb; a.Pb = a.computePixelRatio(); a.Pb !== e && (a.Tn = !0, a.ec()); if (b.clientWidth !== a.Aa + c || b.clientHeight !== a.ya + d) a.oj = !0, a.oc = !0, b = a.layout, null !== b && b.isViewportSized && a.autoScale === Ei && (a.Vk = !0, b.C()), a.$b || a.ec() } } }
    function Ji(a) { var b = new ui; b.name = "Background"; a.Ul(b); b = new ui; b.name = ""; a.Ul(b); b = new ui; b.name = "Foreground"; a.Ul(b); b = new ui; b.name = "Adornment"; b.isTemporary = !0; a.Ul(b); b = new ui; b.name = "Tool"; b.isTemporary = !0; b.isBoundsIncluded = !0; a.Ul(b); b = new ui; b.name = "Grid"; b.allowSelect = !1; b.pickable = !1; b.isTemporary = !0; a.Ww(b, a.cm("Background")) }
    function Xi(a) {
    a.Hb = new W(W.Grid); a.Hb.name = "GRID"; var b = new Hg; b.figure = "LineH"; b.stroke = "lightgray"; b.strokeWidth = .5; b.interval = 1; a.Hb.add(b); b = new Hg; b.figure = "LineH"; b.stroke = "gray"; b.strokeWidth = .5; b.interval = 5; a.Hb.add(b); b = new Hg; b.figure = "LineH"; b.stroke = "gray"; b.strokeWidth = 1; b.interval = 10; a.Hb.add(b); b = new Hg; b.figure = "LineV"; b.stroke = "lightgray"; b.strokeWidth = .5; b.interval = 1; a.Hb.add(b); b = new Hg; b.figure = "LineV"; b.stroke = "gray"; b.strokeWidth = .5; b.interval = 5; a.Hb.add(b); b = new Hg; b.figure =
        "LineV"; b.stroke = "gray"; b.strokeWidth = 1; b.interval = 10; a.Hb.add(b); b = new R; b.add(a.Hb); b.layerName = "Grid"; b.zOrder = 0; b.isInDocumentBounds = !1; b.isAnimated = !1; b.pickable = !1; b.locationObjectName = "GRID"; a.add(b); a.partManager.parts.remove(b); a.Hb.visible = !1
    } function Yi() { this.D.yu ? this.D.yu = !1 : this.D.isEnabled ? this.D.ix(this) : Zi(this.D) } function cj(a) { this.D.isEnabled ? (this.D.Au = a.target.scrollTop, this.D.zu = a.target.scrollLeft) : Zi(this.D) }
    P.prototype.ix = function (a) {
        if (null !== this.Ea) {
        this.us = !0; var b = this.documentBounds, c = this.viewportBounds, d = this.ui, e = b.x - d.left, f = b.y - d.top, g = b.width + d.left + d.right, h = b.height + d.top + d.bottom, k = b.right + d.right; d = b.bottom + d.bottom; var l = c.x; b = c.y; var m = c.width, n = c.height, p = c.right, q = c.bottom; c = this.scale; var r = a.scrollLeft; if (this.Xn) switch (this.wu) { case "negative": r = r + a.scrollWidth - a.clientWidth; break; case "reverse": r = a.scrollWidth - r - a.clientWidth }var u = r; m < g || n < h ? (r = J.allocAt(this.position.x, this.position.y),
            this.allowHorizontalScroll && this.zu !== u && (r.x = u / c + e, this.zu = u), this.allowVerticalScroll && this.Au !== a.scrollTop && (r.y = a.scrollTop / c + f, this.Au = a.scrollTop), this.position = r, J.free(r), this.oj = this.us = !1) : (r = J.alloc(), a.by && this.allowHorizontalScroll && (e < l && (this.position = r.h(u + e, this.position.y)), k > p && (this.position = r.h(-(this.ws.scrollWidth - this.Aa) + u - this.Aa / c + k, this.position.y))), a.ey && this.allowVerticalScroll && (f < b && (this.position = r.h(this.position.x, a.scrollTop + f)), d > q && (this.position = r.h(this.position.x,
                -(this.ws.scrollHeight - this.ya) + a.scrollTop - this.ya / c + d))), J.free(r), dj(this), this.oj = this.us = !1, b = this.documentBounds, c = this.viewportBounds, k = b.right, p = c.right, d = b.bottom, q = c.bottom, e = b.x, l = c.x, f = b.y, b = c.y, m >= g && e >= l && k <= p && (this.mp.style.width = "1px"), n >= h && f >= b && d <= q && (this.mp.style.height = "1px"))
        }
    }; P.prototype.computeBounds = function () { 0 < this.Fd.count && ej(this); return fj(this) };
    function fj(a) { if (a.fixedBounds.o()) { var b = a.fixedBounds.copy(); b.Sp(a.gb); return b } for (var c = !0, d = a.Ra.j, e = d.length, f = 0; f < e; f++) { var g = d[f]; if (g.visible && (!g.isTemporary || g.isBoundsIncluded)) { g = g.Ga.j; for (var h = g.length, k = 0; k < h; k++) { var l = g[k]; l.isInDocumentBounds && l.isVisible() && (l = l.actualBounds, l.o() && (c ? (c = !1, b = l.copy()) : b.Lc(l))) } } } c && (b = new L(0, 0, 0, 0)); b.Sp(a.gb); return b }
    P.prototype.computePartsBounds = function (a, b) { void 0 === b && (b = !1); var c = null; if (Ka(a)) for (var d = 0; d < a.length; d++) { var e = a[d]; !b && e instanceof Q || (e.bc(), null === c ? c = e.actualBounds.copy() : c.Lc(e.actualBounds)) } else for (a = a.iterator; a.next();)d = a.value, !b && d instanceof Q || (d.bc(), null === c ? c = d.actualBounds.copy() : c.Lc(d.actualBounds)); return null === c ? new L(NaN, NaN, 0, 0) : c };
    function gj(a, b) { if ((b || a.je) && !a.pb && null !== a.Ea && !a.animationManager.isAnimating && a.documentBounds.o()) { a.pb = !0; var c = a.ej; b && a.ci !== Ei && (c = a.ci); var d = c !== Ei ? hj(a, c) : a.scale; c = a.viewportBounds.copy(); var e = a.Aa / d, f = a.ya / d, g = null, h = a.animationManager; h.sb && (g = a.ua.copy()); var k = a.gj, l = a.Sn; b && !k.Za() && (l.Za() || l.Cb()) && (k = l.Cb() ? qd : l); ij(a, a.documentBounds, e, f, k, b); null !== g && si(h, g, a.ua); b = a.scale; a.scale = d; a.pb = !1; d = a.viewportBounds; d.Sa(c) || a.sq(c, d, b, !1) } }
    function hj(a, b) { var c = a.kr; if (null === a.Ea) return c; a.Rg && jj(a, a.computeBounds()); var d = a.documentBounds; if (!d.o()) return c; var e = d.width; d = d.height; var f = a.Aa, g = a.ya, h = f / e, k = g / d; return b === kj ? (b = Math.min(k, h), b > c && (b = c), b < a.minScale && (b = a.minScale), b > a.maxScale && (b = a.maxScale), b) : b === lj ? (b = k > h ? (g - a.Jb) / d : (f - a.Jb) / e, b > c && (b = c), b < a.minScale && (b = a.minScale), b > a.maxScale && (b = a.maxScale), b) : a.scale }
    P.prototype.zoomToFit = function () { var a = this.Kj; this.Kj = Di; this.scale = hj(this, kj); a !== Di && (gj(this, !1), ij(this, this.documentBounds, this.Aa / this.Da, this.ya / this.Da, this.gj, !1)); this.Kj = a }; t = P.prototype;
    t.kA = function (a, b) { void 0 === b && (b = kj); var c = a.width, d = a.height; if (!(0 === c || 0 === d || isNaN(c) && isNaN(d))) { var e = 1; if (b === kj || b === lj) if (isNaN(c)) e = this.viewportBounds.height * this.scale / d; else if (isNaN(d)) e = this.viewportBounds.width * this.scale / c; else { e = this.Aa; var f = this.ya; e = b === lj ? f / d > e / c ? (f - (this.Qg ? this.Jb : 0)) / d : (e - (this.ai ? this.Jb : 0)) / c : Math.min(f / d, e / c) } this.scale = e; this.position = new J(a.x, a.y) } };
    t.qy = function (a, b) { this.Rg && jj(this, this.computeBounds()); var c = this.documentBounds, d = this.viewportBounds; this.position = new J(c.x + (a.x * c.width + a.offsetX) - (b.x * d.width - b.offsetX), c.y + (a.y * c.height + a.offsetY) - (b.y * d.height - b.offsetY)) };
    function ij(a, b, c, d, e, f) {
        a.ua.ja(); var g = a.ua, h = g.x, k = g.y; if (f || a.scrollMode === Di) e.Za() && (c > b.width && (h = b.x + (e.x * b.width + e.offsetX) - (e.x * c - e.offsetX)), d > b.height && (k = b.y + (e.y * b.height + e.offsetY) - (e.y * d - e.offsetY))), e = a.ui, f = c - b.width, c < b.width + e.left + e.right ? (h = Math.min(h + c / 2, b.right + Math.max(f, e.right) - c / 2), h = Math.max(h, b.left - Math.max(f, e.left) + c / 2), h -= c / 2) : h > b.left ? h = b.left : h < b.right - c && (h = b.right - c), c = d - b.height, d < b.height + e.top + e.bottom ? (k = Math.min(k + d / 2, b.bottom + Math.max(c, e.bottom) - d / 2), k =
            Math.max(k, b.top - Math.max(c, e.top) + d / 2), k -= d / 2) : k > b.top ? k = b.top : k < b.bottom - d && (k = b.bottom - d); g.x = isFinite(h) ? h : -a.gb.left; g.y = isFinite(k) ? k : -a.gb.top; null !== a.positionComputation && (b = a.positionComputation(a, g), g.x = b.x, g.y = b.y); a.ua.freeze()
    } t.dm = function (a, b) { void 0 === b && (b = !0); if (b) { if (a = vg(this, a, function (a) { return a.part }, function (a) { return a.canSelect() }), a instanceof R) return a } else if (a = vg(this, a, function (a) { return a.part }), a instanceof R) return a; return null };
    t.Tb = function (a, b, c) { void 0 === b && (b = null); void 0 === c && (c = null); ej(this); for (var d = this.Ra.iteratorBackwards; d.next();) { var e = d.value; if (e.visible && (e = e.Tb(a, b, c), null !== e)) return e } return null }; function vg(a, b, c, d) { void 0 === c && (c = null); void 0 === d && (d = null); ej(a); for (a = a.Ra.iteratorBackwards; a.next();) { var e = a.value; if (e.visible && !e.isTemporary && (e = e.Tb(b, c, d), null !== e)) return e } return null }
    t.Yy = function (a, b, c) { void 0 === b && (b = !0); return mj(this, a, function (a) { return a.part }, b ? function (a) { return a instanceof R && a.canSelect() } : null, c) }; function mj(a, b, c, d, e) { void 0 === c && (c = null); void 0 === d && (d = null); e instanceof F || e instanceof I || (e = new I); ej(a); for (a = a.Ra.iteratorBackwards; a.next();) { var f = a.value; f.visible && !f.isTemporary && f.Ji(b, c, d, e) } return e }
    t.Ji = function (a, b, c, d) { void 0 === b && (b = null); void 0 === c && (c = null); d instanceof F || d instanceof I || (d = new I); ej(this); for (var e = this.Ra.iteratorBackwards; e.next();) { var f = e.value; f.visible && f.Ji(a, b, c, d) } return d }; t.ox = function (a, b, c, d) { void 0 === b && (b = !1); void 0 === c && (c = !0); return nj(this, a, function (a) { return a instanceof R && (!c || a.canSelect()) }, b, d) };
    t.pg = function (a, b, c, d, e) { void 0 === b && (b = null); void 0 === c && (c = null); void 0 === d && (d = !1); e instanceof F || e instanceof I || (e = new I); ej(this); for (var f = this.Ra.iteratorBackwards; f.next();) { var g = f.value; g.visible && g.pg(a, b, c, d, e) } return e }; function nj(a, b, c, d, e) { var f = null; void 0 === f && (f = null); void 0 === c && (c = null); void 0 === d && (d = !1); e instanceof F || e instanceof I || (e = new I); ej(a); for (a = a.Ra.iteratorBackwards; a.next();) { var g = a.value; g.visible && !g.isTemporary && g.pg(b, f, c, d, e) } return e }
    t.Zy = function (a, b, c, d, e) { void 0 === c && (c = !0); void 0 === d && (d = !0); return oj(this, a, b, function (a) { return a instanceof R && (!d || a.canSelect()) }, c, e) }; t.qg = function (a, b, c, d, e, f) { void 0 === c && (c = null); void 0 === d && (d = null); void 0 === e && (e = !0); if (!1 !== e && !0 !== e) { if (e instanceof F || e instanceof I) f = e; e = !0 } f instanceof F || f instanceof I || (f = new I); ej(this); for (var g = this.Ra.iteratorBackwards; g.next();) { var h = g.value; h.visible && h.qg(a, b, c, d, e, f) } return f };
    function oj(a, b, c, d, e, f) { var g = null; void 0 === g && (g = null); void 0 === d && (d = null); void 0 === e && (e = !0); if (!1 !== e && !0 !== e) { if (e instanceof F || e instanceof I) f = e; e = !0 } f instanceof F || f instanceof I || (f = new I); ej(a); for (a = a.Ra.iteratorBackwards; a.next();) { var h = a.value; h.visible && !h.isTemporary && h.qg(b, c, g, d, e, f) } return f } P.prototype.acceptEvent = function (a) { return pj(this, a, a instanceof MouseEvent) };
    function pj(a, b, c) { var d = a.$e; a.$e = a.uj; a.uj = d; d.diagram = a; d.event = b; c ? qj(a, b, d) : (d.viewPoint = a.$e.viewPoint, d.documentPoint = a.$e.documentPoint); a = 0; b.ctrlKey && (a += 1); b.altKey && (a += 2); b.shiftKey && (a += 4); b.metaKey && (a += 8); d.modifiers = a; d.button = b.button; void 0 === b.buttons || fb || (d.buttons = b.buttons); kb && 0 === b.button && b.ctrlKey && (d.button = 2); d.down = !1; d.up = !1; d.clickCount = 1; d.delta = 0; d.handled = !1; d.bubbles = !1; d.timestamp = b.timeStamp; d.isMultiTouch = !1; d.targetDiagram = rj(b); d.targetObject = null; return d }
    function rj(a) { var b = a.target.D; if (!b) { var c = a.path; c || "function" !== typeof a.composedPath || (c = a.composedPath()); c && c[0] && (b = c[0].D) } return b ? b : null } function sj(a, b, c, d) { var e = tj(a, b, !0, !1, !0, d); qj(a, c, e); e.targetDiagram = rj(b); e.targetObject = null; d || e.clone(a.Zh); return e }
    function uj(a, b, c, d) { var e; d = tj(a, b, !1, !1, !1, d); null !== c ? ((e = qa.document.elementFromPoint(c.clientX, c.clientY)) && e.D ? (b = c, c = e.D) : (b = void 0 !== b.targetTouches ? b.targetTouches[0] : b, c = a), d.targetDiagram = c, qj(a, b, d)) : null !== a.$e ? (d.documentPoint = a.$e.documentPoint, d.viewPoint = a.$e.viewPoint, d.targetDiagram = a.$e.targetDiagram) : null !== a.Zh && (d.documentPoint = a.Zh.documentPoint, d.viewPoint = a.Zh.viewPoint, d.targetDiagram = a.Zh.targetDiagram); d.targetObject = null; return d }
    function tj(a, b, c, d, e, f) { var g = a.$e; a.$e = a.uj; a.uj = g; g.diagram = a; g.clickCount = 1; var h = g.delta = 0; b.ctrlKey && (h += 1); b.altKey && (h += 2); b.shiftKey && (h += 4); b.metaKey && (h += 8); g.modifiers = h; g.button = 0; g.buttons = 1; g.event = b; g.timestamp = b.timeStamp; a.Sq && b instanceof qa.PointerEvent && "touch" !== b.pointerType && (g.button = b.button, void 0 === b.buttons || fb || (g.buttons = b.buttons), kb && 0 === b.button && b.ctrlKey && (g.button = 2)); g.down = c; g.up = d; g.handled = !1; g.bubbles = e; g.isMultiTouch = f; return g }
    function vj(a, b, c) { if (b.bubbles) return E && E.tx && Ga("NOT handled " + c.type + " " + b.toString()), !0; E && E.tx && Ga("handled " + c.type + " " + a.currentTool.name + " " + b.toString()); void 0 !== c.stopPropagation && c.stopPropagation(); !1 !== c.cancelable && c.preventDefault(); c.cancelBubble = !0; return !1 }
    P.prototype.Ez = function (a) {
        var b = this.D; if (!this.D.isEnabled) return !1; var c = pj(b, a, !1); c.key = String.fromCharCode(a.which); c.down = !0; switch (a.which) {
            case 8: c.key = "Backspace"; break; case 33: c.key = "PageUp"; break; case 34: c.key = "PageDown"; break; case 35: c.key = "End"; break; case 36: c.key = "Home"; break; case 37: c.key = "Left"; break; case 38: c.key = "Up"; break; case 39: c.key = "Right"; break; case 40: c.key = "Down"; break; case 45: c.key = "Insert"; break; case 46: c.key = "Del"; break; case 48: c.key = "0"; break; case 187: case 61: case 107: c.key =
                "Add"; break; case 189: case 173: case 109: c.key = "Subtract"; break; case 27: c.key = "Esc"
        }b.doKeyDown(); return vj(b, c, a)
    };
    P.prototype.Fz = function (a) { var b = this.D; if (!b.isEnabled) return !1; var c = pj(b, a, !1); c.key = String.fromCharCode(a.which); c.up = !0; switch (a.which) { case 8: c.key = "Backspace"; break; case 33: c.key = "PageUp"; break; case 34: c.key = "PageDown"; break; case 35: c.key = "End"; break; case 36: c.key = "Home"; break; case 37: c.key = "Left"; break; case 38: c.key = "Up"; break; case 39: c.key = "Right"; break; case 40: c.key = "Down"; break; case 45: c.key = "Insert"; break; case 46: c.key = "Del" }b.doKeyUp(); return vj(b, c, a) };
    P.prototype.Ky = function (a) { var b = this.D; if (!b.isEnabled) return !1; var c = pj(b, a, !0); null !== b.mouseEnter && b.mouseEnter(c); return vj(b, c, a) }; P.prototype.Ly = function (a) { var b = this.D; if (!b.isEnabled) return !1; var c = pj(b, a, !0); null !== b.mouseLeave && b.mouseLeave(c); return vj(b, c, a) };
    P.prototype.getMouse = function (a) { var b = this.Ea; if (null === b) return new J(0, 0); var c = b.getBoundingClientRect(); b = a.clientX - this.Aa / c.width * c.left; a = a.clientY - this.ya / c.height * c.top; return null !== this.ub ? ac(new J(b, a), this.ub) : new J(b, a) };
    function qj(a, b, c) { var d = a.Ea, e = a.Aa, f = a.ya, g = 0, h = 0; null !== d && (d = d.getBoundingClientRect(), g = b.clientX - e / d.width * d.left, h = b.clientY - f / d.height * d.top); c.viewPoint.h(g, h); null !== a.ub ? (b = J.allocAt(g, h), a.ub.Wd(b), c.documentPoint.assign(b), J.free(b)) : c.documentPoint.h(g, h) }
    function lf(a, b, c, d) { if (void 0 !== b.targetTouches) { if (2 > b.targetTouches.length) return; b = b.targetTouches[c] } else if (null !== a.zl[0]) b = a.zl[c]; else return; c = a.Ea; null !== c && (c = c.getBoundingClientRect(), d.h(b.clientX - a.Aa / c.width * c.left, b.clientY - a.ya / c.height * c.top)) } t = P.prototype; t.Ya = function () { this.Rg || (this.Rg = !0, this.ec(!0)) }; function ri(a) { a.$b || ej(a); a.Rg && jj(a, a.computeBounds()) } t.vf = function () { this.pb || this.$b || (this.S(), wj(this), dj(this), this.Ya(), this.hd()) }; t.Dz = function () { return this.sd };
    t.Fy = function (a) { void 0 === a && (a = null); var b = this.animationManager, c = b.isEnabled; b.xd(); b.isEnabled = !1; Eg(this); this.je = !1; b.isEnabled = c; null !== a && wa(a, 1) }; t.ec = function (a) { void 0 === a && (a = !1); if (!0 !== this.sd && !(this.pb || !1 === a && this.$b)) { this.sd = !0; var b = this; qa.requestAnimationFrame(function () { b.sd && b.hd() }) } }; t.hd = function () { if (!this.al || this.sd) this.al && (this.al = !1), Eg(this) }; function xj(a, b) { a.animationManager.isAnimating || a.pb || !a.oj || Zi(a) || (b && ej(a), gj(a, !1)) }
    function Eg(a, b) {
        if (!a.$b && (a.sd = !1, null !== a.Ja || a.Lp.o())) {
        a.$b = !0; var c = a.animationManager, d = a.ru; if (!c.isTicking && 0 !== d.length) { for (var e = d.j, f = e.length, g = 0; g < f; g++) { var h = e[g]; yj(h, !1); h.v() } d.clear() } d = a.Ew; 0 < d.count && (d.each(function (a) { a.ew() }), d.clear()); e = d = !1; c.isAnimating && (e = !0, d = a.skipsUndoManager, a.skipsUndoManager = !0); c.sb || hi(a); xj(a, !1); null !== a.Hb && (a.Hb.visible && !a.xr && (zj(a), a.xr = !0), !a.Hb.visible && a.xr && (a.xr = !1)); ej(a); f = !1; if (!a.je || a.Cg) a.je ? Aj(a, !a.Vk) : (a.Ca("Initial Layout"),
            !1 === c.isEnabled && c.xd(), Aj(a, !1)), f = !0; a.Vk = !1; ej(a); a.Bu || c.isAnimating || ri(a); xj(a, !0); f && (a.je || Bj(a), a.ba("LayoutCompleted")); ej(a); f && !a.je && (a.je = !0, a.ab("Initial Layout"), a.skipsUndoManager || a.undoManager.clear(), wa(function () { a.isModified = !1 }, 1)); a.Pu(); gi(c); b || a.jc(a.$c); e && (a.skipsUndoManager = d); a.$b = !1
        }
    }
    function Bj(a) { var b = a.Ra.j; a.kd(b, b.length, a); a.ci !== Ei ? a.scale = hj(a, a.ci) : a.ej !== Ei ? a.scale = hj(a, a.ej) : (b = a.initialScale, isFinite(b) && 0 < b && (a.scale = b)); b = a.initialPosition; if (b.o()) a.position = b; else { b = J.alloc(); b.Xi(a.documentBounds, a.initialDocumentSpot); var c = a.viewportBounds; c = L.allocAt(0, 0, c.width, c.height); var d = J.alloc(); d.Xi(c, a.initialViewportSpot); d.h(b.x - d.x, b.y - d.y); a.position = d; L.free(c); J.free(d); J.free(b); wj(a); xj(a, !0); gj(a, !0) } a.ba("InitialLayoutCompleted"); zj(a) }
    function ej(a) { if ((a.$b || !a.animationManager.isAnimating) && 0 !== a.Fd.count) { for (var b = 0; 23 > b; b++) { var c = a.Fd.iterator; if (null === c || 0 === a.Fd.count) break; a.Fd = new I; a.ew(c, a.Fd); E && 22 === b && Ga("failure to validate parts") } a.nodes.each(function (a) { a instanceof xg && 0 !== (a.T & 65536) !== !1 && (a.T = a.T ^ 65536) }) } }
    t.ew = function (a, b) { for (a.reset(); a.next();) { var c = a.value; !c.dc() || c instanceof xg || (c.Ui() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c)) } for (a.reset(); a.next();)c = a.value, c instanceof xg && c.isVisible() && Cj(this, c); for (a.reset(); a.next();)c = a.value, c instanceof Q && c.isVisible() && (c.Ui() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c)); for (a.reset(); a.next();)c = a.value, c instanceof Cf && c.isVisible() && (c.Ui() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c)) };
    function Cj(a, b) { for (var c = Qa(), d = Qa(), e = b.memberParts; e.next();) { var f = e.value; f.isVisible() && (f instanceof xg ? (Dj(f) || Ej(f) || Fj(f)) && Cj(a, f) : f instanceof Q ? f.fromNode === b || f.toNode === b ? d.push(f) : c.push(f) : (f.measure(Infinity, Infinity), f.arrange())) } a = c.length; for (e = 0; e < a; e++)f = c[e], f.measure(Infinity, Infinity), f.arrange(); Ta(c); b.measure(Infinity, Infinity); b.arrange(); a = d.length; for (b = 0; b < a; b++)c = d[b], c.measure(Infinity, Infinity), c.arrange(); Ta(d) }
    t.kd = function (a, b, c, d) { if (this.di || this.animationManager.isAnimating) for (var e = 0; e < b; e++)a[e].kd(c, d) };
    t.jc = function (a, b) {
    void 0 === b && (b = null); if (null !== this.Ja) {
    null === this.Ea && v("No canvas specified"); var c = this.animationManager; if (!c.sb) {
        var d = new Date; Gj(this); if ("0" !== this.Ja.style.opacity) {
            var e = a !== this.$c, f = this.Ra.j, g = f.length, h = this; this.kd(f, g, h); if (e) a.Uc(!0), dj(this); else if (!this.oc && null === b && !c.isAnimating) return; g = this.ua; var k = this.Da, l = Math.round(g.x * k) / k, m = Math.round(g.y * k) / k; c = this.ub; c.reset(); 1 !== k && c.scale(k); 0 === g.x && 0 === g.y || c.translate(-l, -m); k = this.Pb; a.setTransform(1, 0,
                0, 1, 0, 0); a.scale(k, k); a.clearRect(0, 0, this.Aa, this.ya); a.setTransform(1, 0, 0, 1, 0, 0); a.scale(k, k); a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy); E && E.Fi && E.Zu && E.Zu(this, a); l = null !== b ? function (c) {
                    var d = b; if (c.visible && 0 !== c.mb) {
                        var e = c.Ga.j, f = e.length; if (0 !== f) {
                        1 !== c.mb && (a.globalAlpha = c.mb); c = c.Qo; c.length = 0; for (var g = h.scale, k = 0; k < f; k++) {
                            var l = e[k]; if (Dg(l) && !d.contains(l)) {
                                if (l instanceof Q && (l.isOrthogonal && c.push(l), !1 === l.Mc)) continue; var m = l.actualBounds; m.width * g > h.qe || m.height * g > h.qe ? l.jc(a,
                                    h) : xi(a, l)
                            }
                        } a.globalAlpha = 1
                        }
                    }
                } : function (b) { b.jc(a, h) }; Hj(this, a); g = f.length; for (m = 0; m < g; m++)a.setTransform(1, 0, 0, 1, 0, 0), a.scale(k, k), a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy), l(f[m]); this.bi && Ij(this.bi, this) && this.pr(); E && (E.$u || E.Fi) && E.Yp && E.Yp(a, this, c); e ? (this.$c.Uc(!0), dj(this)) : this.oc = this.di = !1; e = +new Date - +d; if (null === this.jh) { d = this.Bo; d[this.Co] = e; this.Co = (this.Co + 1) % d.length; for (f = e = 0; f < this.Bo.length; f++)e += this.Bo[f]; this.Ao = e / d.length }
        }
    }
    }
    };
    function Jj(a, b, c, d, e, f, g, h, k, l) {
        if (null !== a.Ja) {
        null === a.Ea && v("No canvas specified"); void 0 === g && (g = null); void 0 === h && (h = null); void 0 === k && (k = !1); void 0 === l && (l = !1); Gj(a); a.$c.Uc(!0); dj(a); a.qj = !0; var m = a.Da; a.Da = e; var n = a.Ra.j, p = n.length; try {
            var q = new L(f.x, f.y, d.width / e, d.height / e), r = q.copy(); r.Sp(c); zj(a, r); ej(a); a.kd(n, p, a, q); var u = a.Pb; b.setTransform(1, 0, 0, 1, 0, 0); b.scale(u, u); b.clearRect(0, 0, d.width, d.height); null !== h && "" !== h && (b.fillStyle = h, b.fillRect(0, 0, d.width, d.height)); var x = $b.alloc();
            x.reset(); x.translate(c.left, c.top); x.scale(e); 0 === f.x && 0 === f.y || x.translate(-f.x, -f.y); b.setTransform(x.m11, x.m12, x.m21, x.m22, x.dx, x.dy); $b.free(x); Hj(a, b); if (null !== g) {
                var y = new I, A = g.iterator; for (A.reset(); A.next();) { var C = A.value; !1 === l && "Grid" === C.layer.name || null === C || y.add(C) } var G = function (c) {
                    var d = k; if (c.visible && 0 !== c.mb && (void 0 === d && (d = !0), d || !c.isTemporary)) {
                        d = c.Ga.j; var e = d.length; if (0 !== e) {
                        1 !== c.mb && (b.globalAlpha = c.mb); c = c.Qo; c.length = 0; for (var f = a.scale, g = 0; g < e; g++) {
                            var h = d[g]; if (Dg(h) &&
                                y.contains(h)) { if (h instanceof Q && (h.isOrthogonal && c.push(h), !1 === h.Mc)) continue; var l = h.actualBounds; l.width * f > a.qe || l.height * f > a.qe ? h.jc(b, a) : xi(b, h) }
                        } b.globalAlpha = 1
                        }
                    }
                }
            } else if (!k && l) { var H = a.grid.part, O = H.layer; G = function (c) { c === O ? H.jc(b, a) : c.jc(b, a, k) } } else G = function (c) { c.jc(b, a, k) }; for (c = 0; c < p; c++)G(n[c]); a.qj = !1; a.bi && Ij(a.bi, a) && a.pr()
        } finally { a.Da = m, a.$c.Uc(!0), dj(a), a.kd(n, p, a), zj(a) }
        }
    } t.Ge = function (a) { return this.eg[a] };
    t.Nx = function (a, b) { "minDrawingLength" === a && (this.qe = b); this.eg[a] = b; this.vf() }; t.Kv = function () { this.eg = new xb; this.eg.drawShadows = !0; this.eg.textGreeking = !0; this.eg.viewportOptimizations = lb || gb || ib ? !1 : !0; this.eg.temporaryPixelRatio = !0; this.eg.pictureRatioOptimization = !0; this.qe = this.eg.minDrawingLength = 1 }; function Hj(a, b) { a = a.eg; null !== a && (void 0 !== a.imageSmoothingEnabled && b.Mx(!!a.imageSmoothingEnabled), a = a.defaultFont, void 0 !== a && null !== a && (b.font = a)) } t.fm = function (a) { return this.hl[a] };
    t.aA = function (a, b) { this.hl[a] = b }; t.Jv = function () { this.hl = new xb; this.hl.extraTouchArea = 10; this.hl.extraTouchThreshold = 10; this.hl.hasGestureZoom = !0 }; t.Tv = function (a) { Kj(this, a) };
    function Kj(a, b) {
        var c = a instanceof W, d = a instanceof P, e; for (e in b) {
        "" === e && v("Setting properties requires non-empty property names"); var f = a, g = e; if (c || d) { var h = e.indexOf("."); if (0 < h) { var k = e.substring(0, h); if (c) f = a.bb(k); else if (f = a[k], void 0 === f || null === f) f = a.toolManager[k]; Ia(f) ? g = e.substr(h + 1) : v("Unable to find object named: " + k + " in " + a.toString() + " when trying to set property: " + e) } } if ("_" !== g[0] && !Ya(f, g)) if (d && "ModelChanged" === g) { a.Yw(b[g]); continue } else if (d && "Changed" === g) { a.rh(b[g]); continue } else if (d &&
            Ya(a.toolManager, g)) f = a.toolManager; else if (d && Lj(a, g)) { a.Rj(g, b[g]); continue } else if (a instanceof X && "Changed" === g) { a.rh(b[g]); continue } else v('Trying to set undefined property "' + g + '" on object: ' + f.toString()); f[g] = b[e]; "_" === g[0] && f instanceof N && f.Vw(g)
        }
    } t.Pu = function () { if (0 === this.undoManager.transactionLevel && 0 !== this.Yh.count) { for (; 0 < this.Yh.count;) { var a = this.Yh; this.Yh = new Ub; for (a = a.iterator; a.next();) { var b = a.key; b.jq(a.value); b.cc() } } this.S() } };
    t.S = function (a) { void 0 === a && (a = null); if (null === a) this.oc = !0, this.ec(); else { var b = this.viewportBounds; null !== a && a.o() && b.Kc(a) && (this.oc = !0, this.ec()) } this.ba("InvalidateDraw") };
    t.ux = function (a, b) {
        if (!0 !== this.oc) {
        this.oc = !0; var c = !0 === this.Ge("temporaryPixelRatio"); if (!0 === this.Ge("viewportOptimizations") && this.scrollMode !== Mj && this.ui.Hi(0, 0, 0, 0) && b.width === a.width && b.height === a.height) {
            var d = this.scale, e = Math.max(a.x, b.x), f = Math.max(a.y, b.y); d = L.allocAt(e, f, Math.max(0, Math.min(a.x + a.width, b.x + b.width) - e) * d, Math.max(0, Math.min(a.y + a.height, b.y + b.height) - f) * d); if (!this.Gs && 0 < d.width && 0 < d.height) {
                if (!(this.$b || (this.sd = !1, null === this.Ja || (this.$b = !0, this.Pu(), this.documentBounds.o() ||
                    jj(this, this.computeBounds()), e = this.Ea, null === e || e instanceof Nj)))) {
                        var g = this.Pb; f = this.Aa * g; var h = this.ya * g, k = this.scale * g, l = Math.round(Math.round(b.x * k) - Math.round(a.x * k)); b = Math.round(Math.round(b.y * k) - Math.round(a.y * k)); k = this.Zt; a = this.zw; k.width !== f && (k.width = f); k.height !== h && (k.height = h); a.clearRect(0, 0, f, h); k = 190 * g; var m = 70 * g, n = Math.max(l, 0), p = Math.max(b, 0), q = Math.floor(f - n), r = Math.floor(h - p); a.drawImage(e.Ha, n, p, q, r, 0, 0, q, r); Ij(this.bi, this) && a.clearRect(0, 0, k, m); e = Qa(); a = Qa(); r = Math.abs(l);
                    q = Math.abs(b); var u = 0 === n ? 0 : f - r; n = J.allocAt(u, 0); r = J.allocAt(r + u, h); a.push(new L(Math.min(n.x, r.x), Math.min(n.y, r.y), Math.abs(n.x - r.x), Math.abs(n.y - r.y))); var x = this.ub; x.reset(); x.scale(g, g); 1 !== this.Da && x.scale(this.Da); g = this.ua; (0 !== g.x || 0 !== g.y) && isFinite(g.x) && isFinite(g.y) && x.translate(-g.x, -g.y); ac(n, x); ac(r, x); e.push(new L(Math.min(n.x, r.x), Math.min(n.y, r.y), Math.abs(n.x - r.x), Math.abs(n.y - r.y))); u = 0 === p ? 0 : h - q; n.h(0, u); r.h(f, q + u); a.push(new L(Math.min(n.x, r.x), Math.min(n.y, r.y), Math.abs(n.x -
                        r.x), Math.abs(n.y - r.y))); ac(n, x); ac(r, x); e.push(new L(Math.min(n.x, r.x), Math.min(n.y, r.y), Math.abs(n.x - r.x), Math.abs(n.y - r.y))); Ij(this.bi, this) && (f = 0 < l ? 0 : -l, h = 0 < b ? 0 : -b, n.h(f, h), r.h(k + f, m + h), a.push(new L(Math.min(n.x, r.x), Math.min(n.y, r.y), Math.abs(n.x - r.x), Math.abs(n.y - r.y))), ac(n, x), ac(r, x), e.push(new L(Math.min(n.x, r.x), Math.min(n.y, r.y), Math.abs(n.x - r.x), Math.abs(n.y - r.y)))); J.free(n); J.free(r); xj(this, !1); null === this.Ja && v("No div specified"); null === this.Ea && v("No canvas specified"); if (!this.animationManager.sb &&
                            (f = this.$c, this.oc)) {
                                Gj(this); h = this.Pb; f.setTransform(1, 0, 0, 1, 0, 0); f.clearRect(0, 0, this.Aa * h, this.ya * h); f.drawImage(this.Zt.Ha, 0 < l ? 0 : Math.round(-l), 0 < b ? 0 : Math.round(-b)); b = this.ua; g = this.Da; k = Math.round(b.x * g) / g; m = Math.round(b.y * g) / g; l = this.ub; l.reset(); 1 !== g && l.scale(g); 0 === b.x && 0 === b.y || l.translate(-k, -m); f.save(); f.beginPath(); b = a.length; for (g = 0; g < b; g++)k = a[g], 0 !== k.width && 0 !== k.height && f.rect(Math.floor(k.x), Math.floor(k.y), Math.ceil(k.width), Math.ceil(k.height)); f.clip(); f.setTransform(1, 0,
                                    0, 1, 0, 0); f.scale(h, h); f.transform(l.m11, l.m12, l.m21, l.m22, l.dx, l.dy); E && E.Fi && E.Zu && E.Zu(this, f); h = this.Ra.j; b = h.length; this.kd(h, b, this); Hj(this, f); for (g = 0; g < b; g++)if (n = h[g], k = e, n.visible && 0 !== n.mb) {
                                    1 !== n.mb && (f.globalAlpha = n.mb); m = n.Qo; m.length = 0; p = this.scale; n = n.Ga.j; q = n.length; r = k.length; for (x = 0; x < q; x++)if (u = n[x], Dg(u)) {
                                        if (u instanceof Q && (u.isOrthogonal && m.push(u), !1 === u.Mc)) continue; var y = Oj(u, u.actualBounds); a: {
                                            var A = y; for (var C = k, G = r, H = 2 / p, O = 4 / p, S = 0; S < G; S++) {
                                                var T = C[S]; if (0 !== T.width && 0 !==
                                                    T.height && A.pv(T.x - H, T.y - H, T.width + O, T.height + O)) { A = !0; break a }
                                            } A = !1
                                        } A && (y.width * p > this.qe || y.height * p > this.qe ? u.jc(f, this) : xi(f, u))
                                    } f.globalAlpha = 1
                                    } f.restore(); f.Uc(!0); E && (E.$u || E.Fi) && E.Yp && E.Yp(f, this, l); this.bi && Ij(this.bi, this) && this.pr(); this.oc = this.di = !1; this.tt()
                    } Ta(e); Ta(a); this.$b = !1
                }
            } else this.hd(); L.free(d); c && (Yf(this), this.hd(), hg(this, !0))
        } else c ? (Yf(this), this.hd(), hg(this, !0)) : this.hd()
        }
    }; function wj(a) { !1 === a.oj && (a.oj = !0) } function dj(a) { !1 === a.di && (a.di = !0) }
    function Gj(a) { !1 !== a.Tn && (a.Tn = !1, Pj(a, a.Aa, a.ya)) } function Pj(a, b, c) { var d = a.Pb; a.Ea.resize(b * d, c * d, b, c) && (a.oc = !0, a.$c.Uc(!0)) }
    function Zi(a) {
        var b = a.Ea; if (null === b) return !0; var c = a.Ja, d = a.Aa, e = a.ya, f = a.Sw.copy(); if (!f.o()) return !0; var g = !1, h = a.ai ? a.Jb : 0, k = a.Qg ? a.Jb : 0, l = c.clientWidth || d + h; c = c.clientHeight || e + k; if (l !== d + h || c !== e + k) a.ai = !1, a.Qg = !1, k = h = 0, a.Aa = l, a.ya = c, g = a.Tn = !0; a.oj = !1; var m = a.documentBounds, n = 0, p = 0, q = 0, r = 0; l = f.width; c = f.height; var u = a.ui; a.contentAlignment.Za() ? (m.width > l && (n = u.left, p = u.right), m.height > c && (q = u.top, r = u.bottom)) : (n = u.left, p = u.right, q = u.top, r = u.bottom); u = m.width + n + p; var x = m.height + q + r; n = m.x - n;
        var y = f.x; p = m.right + p; var A = f.right + h; q = m.y - q; var C = f.y; r = m.bottom + r; var G = f.bottom + k, H = "1px", O = "1px"; m = a.scale; var S = !(u < l + h), T = !(x < c + k); a.scrollMode === Di && (S || T) && (S && a.hasHorizontalScrollbar && a.allowHorizontalScroll && (H = 1, n + 1 < y && (H = Math.max((y - n) * m + a.Aa, H)), p > A + 1 && (H = Math.max((p - A) * m + a.Aa, H)), l + h + 1 < u && (H = Math.max((u - l + h) * m + a.Aa, H)), H = H.toString() + "px"), T && a.hasVerticalScrollbar && a.allowVerticalScroll && (O = 1, q + 1 < C && (O = Math.max((C - q) * m + a.ya, O)), r > G + 1 && (O = Math.max((r - G) * m + a.ya, O)), c + k + 1 < x && (O = Math.max((x -
            c + k) * m + a.ya, O)), O = O.toString() + "px")); T = "1px" !== H; S = "1px" !== O; T && S || !T && !S || (S && (A -= a.Jb), T && (G -= a.Jb), u < l + h || !a.hasHorizontalScrollbar || !a.allowHorizontalScroll || (h = 1, n + 1 < y && (h = Math.max((y - n) * m + a.Aa, h)), p > A + 1 && (h = Math.max((p - A) * m + a.Aa, h)), l + 1 < u && (h = Math.max((u - l) * m + a.Aa, h)), H = h.toString() + "px"), T = "1px" !== H, h = a.ya, T !== a.Qg && (h = T ? a.ya - a.Jb : a.ya + a.Jb), x < c + k || !a.hasVerticalScrollbar || !a.allowVerticalScroll || (k = 1, q + 1 < C && (k = Math.max((C - q) * m + h, k)), r > G + 1 && (k = Math.max((r - G) * m + h, k)), c + 1 < x && (k = Math.max((x -
                c) * m + h, k)), O = k.toString() + "px"), S = "1px" !== O); if (a.us && T === a.Qg && S === a.ai) return d === a.Aa && e === a.ya || a.hd(), !1; T !== a.Qg && ("1px" === H ? a.ya = a.ya + a.Jb : a.ya = Math.max(a.ya - a.Jb, 1), g = !0); a.Qg = T; a.mp.style.width = H; S !== a.ai && ("1px" === O ? a.Aa = a.Aa + a.Jb : a.Aa = Math.max(a.Aa - a.Jb, 1), g = !0, a.Xn && (k = J.alloc(), S ? (b.style.left = a.Jb + "px", a.position = k.h(a.ua.x + a.Jb / a.scale, a.ua.y)) : (b.style.left = "0px", a.position = k.h(a.ua.x - a.Jb / a.scale, a.ua.y)), J.free(k))); a.ai = S; a.mp.style.height = O; a.yu = !0; g && (a.Tn = !0); b = a.ws; k = b.scrollLeft;
        a.hasHorizontalScrollbar && a.allowHorizontalScroll && (l + 1 < u ? k = (a.position.x - n) * m : n + 1 < y ? k = b.scrollWidth - b.clientWidth : p > A + 1 && (k = a.position.x * m)); if (a.Xn) switch (a.wu) { case "negative": k = -(b.scrollWidth - k - b.clientWidth); break; case "reverse": k = b.scrollWidth - k - b.clientWidth }b.scrollLeft = k; a.hasVerticalScrollbar && a.allowVerticalScroll && (c + 1 < x ? b.scrollTop = (a.position.y - q) * m : q + 1 < C ? b.scrollTop = b.scrollHeight - b.clientHeight : r > G + 1 && (b.scrollTop = a.position.y * m)); l = a.Aa; c = a.ya; b.style.width = l + (a.ai ? a.Jb : 0) + "px";
        b.style.height = c + (a.Qg ? a.Jb : 0) + "px"; return d !== l || e !== c || a.animationManager.sb ? (a.sq(f, a.viewportBounds, m, g), !1) : !0
    }
    t.add = function (a) {
        w(a, R, P, "add:part"); var b = a.diagram; if (b !== this && (null !== b && v("Cannot add part " + a.toString() + " to " + this.toString() + ". It is already a part of " + b.toString()), b = this.cm(a.layerName), null === b && (b = this.cm("")), null === b && v('Cannot add a Part when unable find a Layer named "' + a.layerName + '" and there is no default Layer'), a.layer !== b)) {
            var c = b.Ri(99999999, a, a.diagram === this); 0 <= c && this.cb(qf, "parts", b, null, a, null, c); b.isTemporary || this.Ya(); a.C(1); c = a.layerChanged; null !== c && c(a, null,
                b)
        }
    }; t.Ri = function (a) { this.partManager.Ri(a); var b = this; Qj(a, function (a) { Rj(b, a) }); (a instanceof Cf || a instanceof xg && null !== a.placeholder) && a.v(); null !== a.data && Qj(a, function (a) { Sj(b.partManager, a) }); !0 !== Ej(a) && !0 !== Fj(a) || this.Fd.add(a); Tj(a, !0, this); Uj(a) ? (a.actualBounds.o() && this.S(Oj(a, a.actualBounds)), this.Ya()) : a.isVisible() && a.actualBounds.o() && this.S(Oj(a, a.actualBounds)); this.ec() };
    t.zc = function (a) { a.Wj(); this.partManager.zc(a); var b = this; Qj(a, function (a) { Vj(b, a) }); null !== a.data && Qj(a, function (a) { Wj(b.partManager, a) }); this.Fd.remove(a); Uj(a) ? (a.actualBounds.o() && this.S(Oj(a, a.actualBounds)), this.Ya()) : a.isVisible() && a.actualBounds.o() && this.S(Oj(a, a.actualBounds)); this.ec() }; t.remove = function (a) { w(a, R, P, "remove:part"); Xj(this, a, !0) };
    function Xj(a, b, c) { var d = b.layer; null !== d && d.diagram === a && (b.isSelected = !1, b.isHighlighted = !1, b.C(2), c && b.bk(), c = d.zc(-1, b, !1), 0 <= c && a.cb(rf, "parts", d, b, null, c, null), a = b.layerChanged, null !== a && a(b, d, null)) } t.wt = function (a, b) { if (Ka(a)) for (var c = a.length, d = 0; d < c; d++) { var e = a[d]; b && !e.canDelete() || this.remove(e) } else for (c = new I, c.addAll(a), a = c.iterator; a.next();)c = a.value, b && !c.canDelete() || this.remove(c) }; t.ak = function (a, b, c) { return this.partManager.ak(a, b, c) };
    P.prototype.moveParts = function (a, b, c, d) { void 0 === d && (d = Yj(this)); w(b, J, P, "moveParts:offset"); if (null !== this.toolManager) { var e = new Ub; if (null !== a) if (Ka(a)) for (var f = 0; f < a.length; f++)Zj(this, e, a[f], c, d); else for (a = a.iterator; a.next();)Zj(this, e, a.value, c, d); else { for (a = this.parts; a.next();)Zj(this, e, a.value, c, d); for (a = this.nodes; a.next();)Zj(this, e, a.value, c, d); for (a = this.links; a.next();)Zj(this, e, a.value, c, d) } pg(this, e, b, d, c) } };
    function Zj(a, b, c, d, e) {
    void 0 === e && (e = Yj(a)); if (!b.contains(c) && (!d || c.canMove() || c.canCopy())) if (c instanceof V) { b.add(c, a.rd(e, c, c.location)); if (c instanceof xg) for (var f = c.memberParts; f.next();)Zj(a, b, f.value, d, e); for (f = c.linksConnected; f.next();) { var g = f.value; if (!b.contains(g)) { var h = g.fromNode, k = g.toNode; null !== h && b.contains(h) && null !== k && b.contains(k) && Zj(a, b, g, d, e) } } if (e.dragsTree) for (c = c.hv(); c.next();)Zj(a, b, c.value, d, e) } else if (c instanceof Q) for (b.add(c, a.rd(e, c)), c = c.labelNodes; c.next();)Zj(a,
        b, c.value, d, e); else c instanceof Cf || b.add(c, a.rd(e, c, c.location))
    }
    function pg(a, b, c, d, e) {
        if (null !== b && (w(b, Ub, P, "moveParts:parts"), 0 !== b.count)) {
            var f = J.alloc(), g = J.alloc(); g.assign(c); isNaN(g.x) && (g.x = 0); isNaN(g.y) && (g.y = 0); (c = a.Cp) || Zf(a, b); for (var h = Qa(), k = Qa(), l = b.iterator, m = J.alloc(); l.next();) { var n = l.key, p = l.value; if (n.dc()) { var q = ak(a, n, b); if (null !== q) h.push(new bk(n, p, q)); else if (!e || n.canMove()) q = p.point, f.assign(q), a.computeMove(n, f.add(g), d, m), n.location = m, void 0 === p.shifted && (p.shifted = new J), p.shifted.assign(m.Zd(q)) } else l.key instanceof Q && k.push(l.pa) } J.free(m);
            e = h.length; for (l = 0; l < e; l++)n = h[l], f.assign(n.info.point), void 0 === n.mv.shifted && (n.mv.shifted = new J), n.node.location = f.add(n.mv.shifted); e = J.alloc(); l = J.alloc(); n = k.length; for (p = 0; p < n; p++) {
                var r = k[p]; q = r.key; if (q instanceof Q) if (q.suspendsRouting) {
                q.bh = null; m = q.fromNode; var u = q.toNode; if (null !== a.draggedLink && d.dragsLink) if (u = r.value.point, null === q.dragComputation) b.add(q, a.rd(d, q, g)), ng(q, g.x - u.x, g.y - u.y); else {
                    r = J.allocAt(0, 0); (m = q.i(0)) && m.o() && r.assign(m); var x = m = J.alloc().assign(r).add(g); d.isGridSnapEnabled &&
                        (d.isGridSnapRealtime || a.lastInput.up) && (x = J.alloc(), uh(a, q, m, x, d)); m.assign(q.dragComputation(q, m, x)).Zd(r); b.add(q, a.rd(d, q, m)); ng(q, m.x - u.x, m.y - u.y); J.free(r); J.free(m); x !== m && J.free(x)
                } else null !== m && (e.assign(m.location), x = b.K(m), null !== x && e.Zd(x.point)), null !== u && (l.assign(u.location), x = b.K(u), null !== x && l.Zd(x.point)), null !== m && null !== u ? e.Sa(l) ? (m = r.value.point, u = f, u.assign(e), u.Zd(m), b.add(q, a.rd(d, q, e)), ng(q, u.x, u.y)) : (q.suspendsRouting = !1, q.Ta()) : (r = r.value.point, m = null !== m ? e : null !== u ? l :
                    g, b.add(q, a.rd(d, q, m)), ng(q, m.x - r.x, m.y - r.y))
                } else if (null === q.fromNode || null === q.toNode) m = r.value.point, b.add(q, a.rd(d, q, g)), ng(q, g.x - m.x, g.y - m.y)
            } J.free(f); J.free(g); J.free(e); J.free(l); Ta(h); Ta(k); c || (ej(a), dg(a, b))
        }
    }
    P.prototype.computeMove = function (a, b, c, d) {
    void 0 === d && (d = new J); d.assign(b); if (null === a) return d; var e = b, f = c.isGridSnapEnabled; f && (c.isGridSnapRealtime || this.lastInput.up) && (e = J.alloc(), uh(this, a, b, e, c)); c = null !== a.dragComputation ? a.dragComputation(a, b, e) : e; var g = a.minLocation, h = g.x; isNaN(h) && (h = f ? Math.round(a.location.x) : a.location.x); g = g.y; isNaN(g) && (g = f ? Math.round(a.location.y) : a.location.y); var k = a.maxLocation, l = k.x; isNaN(l) && (l = f ? Math.round(a.location.x) : a.location.x); k = k.y; isNaN(k) && (k = f ? Math.round(a.location.y) :
        a.location.y); d.h(Math.max(h, Math.min(c.x, l)), Math.max(g, Math.min(c.y, k))); e !== b && J.free(e); return d
    }; function Yj(a) { var b = a.toolManager.findTool("Dragging"); return null !== b ? b.dragOptions : a.Pk }
    function uh(a, b, c, d, e) { void 0 === e && (e = Yj(a)); d.assign(c); if (null !== b) { var f = a.grid; b = e.gridSnapCellSize; a = b.width; b = b.height; var g = e.gridSnapOrigin, h = g.x; g = g.y; e = e.gridSnapCellSpot; if (null !== f) { var k = f.gridCellSize; isNaN(a) && (a = k.width); isNaN(b) && (b = k.height); f = f.gridOrigin; isNaN(h) && (h = f.x); isNaN(g) && (g = f.y) } f = J.allocAt(0, 0); f.uk(0, 0, a, b, e); K.bq(c.x, c.y, h + f.x, g + f.y, a, b, d); J.free(f) } } function Zf(a, b) { if (null !== b) for (a.Cp = !0, a = b.iterator; a.next();)b = a.key, b instanceof Q && (b.suspendsRouting = !0) }
    function dg(a, b) { if (null !== b) { for (b = b.iterator; b.next();) { var c = b.key; c instanceof Q && (c.suspendsRouting = !1, ck(c) && c.Ta()) } a.Cp = !1 } } function ak(a, b, c) { b = b.containingGroup; if (null !== b) { a = ak(a, b, c); if (null !== a) return a; a = c.K(b); if (null !== a) return a } return null } t = P.prototype; t.rd = function (a, b, c) { if (void 0 === c) return new bg(gc); var d = a.isGridSnapEnabled; a.uz || null === b.containingGroup || (d = !1); return d ? new bg(new J(Math.round(c.x), Math.round(c.y))) : new bg(c.copy()) };
    function dk(a, b, c) {
        w(b, ui, P, "addLayer:layer"); null !== b.diagram && b.diagram !== a && v("Cannot share a Layer with another Diagram: " + b + " of " + b.diagram); null === c ? null !== b.diagram && v("Cannot add an existing Layer to this Diagram again: " + b) : (w(c, ui, P, "addLayer:existingLayer"), c.diagram !== a && v("Existing Layer must be in this Diagram: " + c + " not in " + c.diagram), b === c && v("Cannot move a Layer before or after itself: " + b)); if (b.diagram !== a) {
            b = b.name; a = a.Ra; c = a.count; for (var d = 0; d < c; d++)a.O(d).name === b && v("Cannot add Layer with the name '" +
                b + "'; a Layer with the same name is already present in this Diagram.")
        }
    } t.Ul = function (a) { dk(this, a, null); a.ib(this); var b = this.Ra, c = b.count - 1; if (!a.isTemporary) for (; 0 <= c && b.O(c).isTemporary;)c--; b.Lb(c + 1, a); null !== this.ac && this.cb(qf, "layers", this, null, a, null, c + 1); this.S(); this.Ya() };
    t.Ww = function (a, b) { dk(this, a, b); a.ib(this); var c = this.Ra, d = c.indexOf(a); 0 <= d && (c.remove(a), null !== this.ac && this.cb(rf, "layers", this, a, null, d, null)); var e = c.count, f; for (f = 0; f < e; f++)if (c.O(f) === b) { c.Lb(f, a); break } null !== this.ac && this.cb(qf, "layers", this, null, a, null, f); this.S(); 0 > d && this.Ya() };
    t.ly = function (a, b) { dk(this, a, b); a.ib(this); var c = this.Ra, d = c.indexOf(a); 0 <= d && (c.remove(a), null !== this.ac && this.cb(rf, "layers", this, a, null, d, null)); var e = c.count, f; for (f = 0; f < e; f++)if (c.O(f) === b) { c.Lb(f + 1, a); break } null !== this.ac && this.cb(qf, "layers", this, null, a, null, f + 1); this.S(); 0 > d && this.Ya() };
    t.Vz = function (a) { w(a, ui, P, "removeLayer:layer"); a.diagram !== this && v("Cannot remove a Layer from another Diagram: " + a + " of " + a.diagram); if ("" !== a.name) { var b = this.Ra, c = b.indexOf(a); if (b.remove(a)) { for (b = a.Ga.copy().iterator; b.next();) { var d = b.value, e = d.layerName; e !== a.name ? d.layerName = e : d.layerName = "" } null !== this.ac && this.cb(rf, "layers", this, a, null, c, null); this.S(); this.Ya() } } }; t.cm = function (a) { for (var b = this.layers; b.next();) { var c = b.value; if (c.name === a) return c } return null };
    t.Yw = function (a) { z(a, "function", P, "addModelChangedListener:listener"); null === this.re && (this.re = new F); this.re.add(a); this.model.rh(a) }; t.Xz = function (a) { z(a, "function", P, "removeModelChangedListener:listener"); null !== this.re && (this.re.remove(a), 0 === this.re.count && (this.re = null)); this.model.tk(a) }; t.rh = function (a) { z(a, "function", P, "addChangedListener:listener"); null === this.Cf && (this.Cf = new F); this.Cf.add(a) };
    t.tk = function (a) { z(a, "function", P, "removeChangedListener:listener"); null !== this.Cf && (this.Cf.remove(a), 0 === this.Cf.count && (this.Cf = null)) }; t.Qs = function (a) { this.skipsUndoManager || this.model.skipsUndoManager || this.model.undoManager.nv(a); a.change !== pf && (this.isModified = !0); if (null !== this.Cf) for (var b = this.Cf, c = b.length, d = 0; d < c; d++)b.O(d)(a) };
    t.cb = function (a, b, c, d, e, f, g) { void 0 === f && (f = null); void 0 === g && (g = null); var h = new nf; h.diagram = this; h.change = a; h.propertyName = b; h.object = c; h.oldValue = d; h.oldParam = f; h.newValue = e; h.newParam = g; this.Qs(h) }; t.g = function (a, b, c, d, e) { this.cb(of, a, this, b, c, d, e) };
    t.Vj = function (a, b) {
        if (null !== a && a.diagram === this) {
            var c = this.skipsModelSourceBindings; try {
            this.skipsModelSourceBindings = !0; var d = a.change; if (d === of) { var e = a.object; ek(e, a.propertyName, a.K(b)); if (e instanceof N) { var f = e.part; null !== f && f.Mb() } this.isModified = !0 } else if (d === qf) {
                var g = a.object, h = a.newParam, k = a.newValue; if (g instanceof W) if ("number" === typeof h && k instanceof N) { b ? g.zc(h) : g.Lb(h, k); var l = g.part; null !== l && l.Mb() } else {
                    if ("number" === typeof h && k instanceof fk) if (b) k.isRow ? g.Hv(h) : g.Fv(h); else {
                        var m =
                            k.isRow ? g.getRowDefinition(k.index) : g.getColumnDefinition(k.index); m.Zl(k)
                    }
                } else if (g instanceof ui) { var n = !0 === a.oldParam; "number" === typeof h && k instanceof R && (b ? (k.isSelected = !1, k.isHighlighted = !1, k.Mb(), g.zc(n ? h : -1, k, n)) : g.Ri(h, k, n)) } else g instanceof P ? "number" === typeof h && k instanceof ui && (b ? this.Ra.nb(h) : (k.ib(this), this.Ra.Lb(h, k))) : v("unknown ChangedEvent.Insert object: " + a.toString()); this.isModified = !0
            } else if (d === rf) {
                var p = a.object, q = a.oldParam, r = a.oldValue; if (p instanceof W) "number" ===
                    typeof q && r instanceof N ? b ? p.Lb(q, r) : p.zc(q) : "number" === typeof q && r instanceof fk && (b ? (m = r.isRow ? p.getRowDefinition(r.index) : p.getColumnDefinition(r.index), m.Zl(r)) : r.isRow ? p.Hv(q) : p.Fv(q)); else if (p instanceof ui) { var u = !0 === a.newParam; "number" === typeof q && r instanceof R && (b ? 0 > p.Ga.indexOf(r) && p.Ri(q, r, u) : (r.isSelected = !1, r.isHighlighted = !1, r.Mb(), p.zc(u ? q : -1, r, u))) } else p instanceof P ? "number" === typeof q && r instanceof ui && (b ? (r.ib(this), this.Ra.Lb(q, r)) : this.Ra.nb(q)) : v("unknown ChangedEvent.Remove object: " +
                        a.toString()); this.isModified = !0
            } else d !== pf && v("unknown ChangedEvent: " + a.toString())
            } finally { this.skipsModelSourceBindings = c }
        }
    }; t.Ca = function (a) { return this.undoManager.Ca(a) }; t.ab = function (a) { return this.undoManager.ab(a) }; t.xf = function () { return this.undoManager.xf() };
    P.prototype.commit = function (a, b) { void 0 === b && (b = ""); var c = this.skipsUndoManager; null === b && (this.skipsUndoManager = !0, b = ""); this.undoManager.Ca(b); var d = !1; try { a(this), d = !0 } finally { d ? this.undoManager.ab(b) : this.undoManager.xf(), this.skipsUndoManager = c } }; P.prototype.updateAllTargetBindings = function (a) { this.partManager.updateAllTargetBindings(a) }; t = P.prototype; t.Dq = function () { this.partManager.Dq() };
    function gk(a, b, c) {
        var d = a.animationManager; if (a.pb || a.$b) a.Da = c, ti(d, b, a.Da); else if (a.pb = !0, null === a.Ea) a.Da = c; else {
            var e = a.viewportBounds.copy(), f = a.Aa, g = a.ya; e.width = a.Aa / b; e.height = a.ya / b; var h = a.zoomPoint.x, k = a.zoomPoint.y, l = a.contentAlignment; isNaN(h) && (l.tf() ? l.sf(wd) ? h = 0 : l.sf(Ad) && (h = f - 1) : h = l.Za() ? l.x * (f - 1) : f / 2); isNaN(k) && (l.tf() ? l.sf(vd) ? k = 0 : l.sf(Bd) && (k = g - 1) : k = l.Za() ? l.y * (g - 1) : g / 2); null !== a.scaleComputation && (c = a.scaleComputation(a, c)); c < a.minScale && (c = a.minScale); c > a.maxScale && (c = a.maxScale);
            f = J.allocAt(a.ua.x + h / b - h / c, a.ua.y + k / b - k / c); a.position = f; J.free(f); a.Da = c; a.sq(e, a.viewportBounds, b, !1); a.pb = !1; gj(a, !1); ti(d, b, a.Da); a.S(); wj(a)
        }
    }
    t.sq = function (a, b, c, d) {
        if (!a.A(b)) {
        void 0 === d && (d = !1); d || wj(this); dj(this); var e = this.layout; null === e || !e.isViewportSized || this.autoScale !== Ei || d || a.width === b.width && a.height === b.height || e.C(); e = this.currentTool; !0 === this.Se && e instanceof $a && (this.lastInput.documentPoint = this.Dt(this.lastInput.viewPoint), Gf(e, this)); this.pb || this.ux(a, b); zj(this); this.Ae.scale = c; this.Ae.position.x = a.x; this.Ae.position.y = a.y; this.Ae.bounds.assign(a); this.Ae.wx = d; this.ba("ViewportBoundsChanged", this.Ae, a); this.isVirtualized &&
            this.links.each(function (a) { a.isAvoiding && a.actualBounds.Kc(b) && a.Ta() })
        }
    };
    function zj(a, b) {
    void 0 === b && (b = null); var c = a.Hb; if (null !== c && c.visible) {
        for (var d = Zb.alloc(), e = 1, f = 1, g = c.Z.j, h = g.length, k = 0; k < h; k++) { var l = g[k], m = l.interval; 2 > m || (hk(l.figure) ? f = f * m / K.px(f, m) : e = e * m / K.px(e, m)) } g = c.gridCellSize; d.h(f * g.width, e * g.height); if (null !== b) e = b.width, f = b.height, a = b.x, g = b.y; else { b = L.alloc(); a = a.viewportBounds; b.h(a.x, a.y, a.width, a.height); if (!b.o()) { L.free(b); return } e = b.width; f = b.height; a = b.x; g = b.y; L.free(b) } c.width = e + 2 * d.width; c.height = f + 2 * d.height; b = J.alloc(); K.bq(a, g, 0, 0,
            d.width, d.height, b); b.offset(-d.width, -d.height); Zb.free(d); c.part.location = b; J.free(b)
    }
    } t.Vp = function () { var a = 0 < this.selection.count; a && this.ba("ChangingSelection", this.selection); Mf(this); a && this.ba("ChangedSelection", this.selection) }; function Mf(a) { a = a.selection; if (0 < a.count) { for (var b = a.Oa(), c = b.length, d = 0; d < c; d++)b[d].isSelected = !1; a.ja(); a.clear(); a.freeze() } }
    t.select = function (a) { null !== a && (w(a, R, P, "select:part"), a.layer.diagram === this && (!a.isSelected || 1 < this.selection.count) && (this.ba("ChangingSelection", this.selection), Mf(this), a.isSelected = !0, this.ba("ChangedSelection", this.selection))) };
    t.Nv = function (a) { this.ba("ChangingSelection", this.selection); Mf(this); if (Ka(a)) for (var b = a.length, c = 0; c < b; c++) { var d = a[c]; d instanceof R || v("Diagram.selectCollection given something that is not a Part: " + d); d.isSelected = !0 } else for (a = a.iterator; a.next();)b = a.value, b instanceof R || v("Diagram.selectCollection given something that is not a Part: " + b), b.isSelected = !0; this.ba("ChangedSelection", this.selection) };
    t.Qu = function () { var a = this.highlighteds; if (0 < a.count) { for (var b = a.Oa(), c = b.length, d = 0; d < c; d++)b[d].isHighlighted = !1; a.ja(); a.clear(); a.freeze() } }; t.wz = function (a) { null !== a && a.layer.diagram === this && (w(a, R, P, "highlight:part"), !a.isHighlighted || 1 < this.highlighteds.count) && (this.Qu(), a.isHighlighted = !0) };
    t.xz = function (a) { a = (new I).addAll(a); for (var b = this.highlighteds.copy().vq(a).iterator; b.next();)b.value.isHighlighted = !1; for (a = a.iterator; a.next();)b = a.value, b instanceof R || v("Diagram.highlightCollection given something that is not a Part: " + b), b.isHighlighted = !0 };
    t.scroll = function (a, b, c) {
    void 0 === c && (c = 1); var d = "up" === b || "down" === b, e = 0; if ("pixel" === a) e = c; else if ("line" === a) e = c * (d ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange); else if ("page" === a) a = d ? this.viewportBounds.height : this.viewportBounds.width, a *= this.scale, 0 !== a && (e = c * Math.max(a - (d ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange), 0)); else {
        if ("document" === a) {
            e = this.documentBounds; c = this.viewportBounds; d = J.alloc(); "up" === b ? this.position = d.h(c.x, e.y) : "left" === b ? this.position =
                d.h(e.x, c.y) : "down" === b ? this.position = d.h(c.x, e.bottom - c.height) : "right" === b && (this.position = d.h(e.right - c.width, c.y)); J.free(d); return
        } v("scrolling unit must be 'pixel', 'line', 'page', or 'document', not: " + a)
    } e /= this.scale; c = this.position.copy(); "up" === b ? c.y = this.position.y - e : "down" === b ? c.y = this.position.y + e : "left" === b ? c.x = this.position.x - e : "right" === b ? c.x = this.position.x + e : v("scrolling direction must be 'up', 'down', 'left', or 'right', not: " + b); this.position = c
    };
    t.Mv = function (a) { var b = this.viewportBounds; b.pf(a) || (a = a.center, a.x -= b.width / 2, a.y -= b.height / 2, this.position = a) }; t.Ou = function (a) { var b = this.viewportBounds; a = a.center; a.x -= b.width / 2; a.y -= b.height / 2; this.position = a }; t.Ct = function (a) { var b = this.ub; b.reset(); 1 !== this.Da && b.scale(this.Da); var c = this.ua; (0 !== c.x || 0 !== c.y) && isFinite(c.x) && isFinite(c.y) && b.translate(-c.x, -c.y); return a.copy().transform(this.ub) };
    t.hA = function (a) { var b = this.ub, c = a.x, d = a.y, e = c + a.width, f = d + a.height, g = b.m11, h = b.m12, k = b.m21, l = b.m22, m = b.dx, n = b.dy, p = c * g + d * k + m; b = c * h + d * l + n; var q = e * g + d * k + m; a = e * h + d * l + n; d = c * g + f * k + m; c = c * h + f * l + n; g = e * g + f * k + m; e = e * h + f * l + n; f = Math.min(p, q); p = Math.max(p, q); q = Math.min(b, a); b = Math.max(b, a); f = Math.min(f, d); p = Math.max(p, d); q = Math.min(q, c); b = Math.max(b, c); f = Math.min(f, g); p = Math.max(p, g); q = Math.min(q, e); b = Math.max(b, e); return new L(f, q, p - f, b - q) };
    t.Dt = function (a) { var b = this.ub; b.reset(); 1 !== this.Da && b.scale(this.Da); var c = this.ua; (0 !== c.x || 0 !== c.y) && isFinite(c.x) && isFinite(c.y) && b.translate(-c.x, -c.y); return ac(a.copy(), this.ub) }; function ik(a) { var b = a.isModified; a.Tw !== b && (a.Tw = b, a.ba("Modified")) } function jk(a) { a = Hi.get(a); return null !== a ? new a : new Ii }
    P.prototype.doModelChanged = function (a) {
        if (a.model === this.model) {
            var b = a.change, c = a.propertyName; if (b === pf && "S" === c[0]) if ("StartingFirstTransaction" === c) { var d = this; a = this.toolManager; a.mouseDownTools.each(function (a) { a.ib(d) }); a.mouseMoveTools.each(function (a) { a.ib(d) }); a.mouseUpTools.each(function (a) { a.ib(d) }); this.$b || this.je || (this.Vk = !0, this.al && (this.sd = !0)) } else "StartingUndo" === c || "StartingRedo" === c ? (a = this.animationManager, a.isAnimating && !this.skipsUndoManager && a.xd(), this.ba("ChangingSelection",
                this.selection)) : "StartedTransaction" === c && (a = this.animationManager, a.isAnimating && !this.skipsUndoManager && a.xd()); else if (this.fa) {
                this.fa = !1; try {
                    if ("" === a.modelChange && b === pf) {
                        if ("FinishedUndo" === c || "FinishedRedo" === c) this.ba("ChangedSelection", this.selection), ej(this); var e = this.animationManager; "RolledBackTransaction" === c && e.xd(); this.Vk = !0; this.hd(); 0 === this.undoManager.transactionLevel && gi(e); "CommittedTransaction" === c && this.undoManager.iu && (this.ie = Math.min(this.ie, this.undoManager.historyIndex -
                            1)); var f = a.isTransactionFinished; f && (ik(this), this.lt.clear()); if (!this.pu && f) { this.pu = !0; var g = this; wa(function () { g.currentTool.standardMouseOver(); g.pu = !1 }, 10) }
                    }
                } finally { this.fa = !0 }
                }
        }
    }; function Rj(a, b) { b = b.Z.j; for (var c = b.length, d = 0; d < c; d++)kk(a, b[d]) }
    function kk(a, b) { if (b instanceof lk) { var c = b.element; if (null !== c && c instanceof HTMLImageElement) { var d = b.Lg; null !== d && (d.cl instanceof Event && null !== b.Ec && b.Ec(b, d.cl), !0 === d.Jr && (null !== b.gf && b.gf(b, d.xu), null !== b.diagram && b.diagram.ru.add(b))); c = c.src; d = a.Gj.K(c); if (null === d) d = [], d.push(b), a.Gj.add(c, d); else { for (a = 0; a < d.length; a++)if (d[a] === b) return; d.push(b) } } } } function Vj(a, b) { b = b.Z.j; for (var c = b.length, d = 0; d < c; d++)pk(a, b[d]) }
    function pk(a, b) { if (b instanceof lk) { var c = b.element; if (null !== c && c instanceof HTMLImageElement) { c = c.src; var d = a.Gj.K(c); if (null !== d) for (var e = 0; e < d.length; e++)if (d[e] === b) { d.splice(e, 1); 0 === d.length && (a.Gj.remove(c), tk(c)); break } } } } P.prototype.wd = function () { this.partManager.wd() }; P.prototype.Qp = function (a, b) { this.Dk.Qp(a, b) }; P.prototype.Rp = function (a, b) { this.Dk.Rp(a, b) }; P.prototype.findPartForKey = function (a) { return this.partManager.findPartForKey(a) }; t = P.prototype; t.Kb = function (a) { return this.partManager.Kb(a) };
    t.xc = function (a) { return this.partManager.xc(a) }; t.Ii = function (a) { return this.partManager.Ii(a) }; t.wc = function (a) { return this.partManager.wc(a) }; t.Xs = function (a) { for (var b = [], c = 0; c < arguments.length; ++c)b[c] = arguments[c]; return this.partManager.Xs.apply(this.partManager, b instanceof Array ? b : da(ca(b))) }; t.Ws = function (a) { for (var b = [], c = 0; c < arguments.length; ++c)b[c] = arguments[c]; return this.partManager.Ws.apply(this.partManager, b instanceof Array ? b : da(ca(b))) };
    function jj(a, b) { a.Rg = !1; var c = a.zn; c.A(b) || (b = b.J(), a.zn = b, gj(a, !1), a.ba("DocumentBoundsChanged", null, c.copy()), wj(a)) } t.cz = function () { for (var a = new I, b = this.nodes; b.next();) { var c = b.value; c.isTopLevel && a.add(c) } for (b = this.links; b.next();)c = b.value, c.isTopLevel && a.add(c); return a.iterator }; t.bz = function () { return this.Ai.iterator }; t.Hz = function (a) { ej(this); a && uk(this, !0); this.Vk = !0; Eg(this) };
    function uk(a, b) { for (var c = a.Ai.iterator; c.next();)vk(a, c.value, b); null !== a.layout && (b ? a.layout.isValidLayout = !1 : a.layout.C()) } function vk(a, b, c) { if (null !== b) { for (var d = b.vl.iterator; d.next();)vk(a, d.value, c); null !== b.layout && (c ? b.layout.isValidLayout = !1 : b.layout.C()) } }
    function Aj(a, b) { if (a.Cg && !a.Vt) { var c = a.fa; a.fa = !0; var d = a.undoManager.transactionLevel, e = a.layout; try { 0 === d && a.Ca("Layout"); var f = a.animationManager; 1 >= d && !f.isAnimating && !f.sb && (b || f.Ch("Layout")); a.Cg = !1; for (var g = a.Ai.iterator; g.next();)wk(a, g.value, b, d); e.isValidLayout || (!b || e.isRealtime || null === e.isRealtime || 0 === d ? (e.doLayout(a), ej(a), e.isValidLayout = !0) : a.Cg = !0) } finally { 0 === d && a.ab("Layout"), a.Cg = !e.isValidLayout, a.fa = c } } }
    function wk(a, b, c, d) { if (null !== b) { for (var e = b.vl.iterator; e.next();)wk(a, e.value, c, d); e = b.layout; null === e || e.isValidLayout || (!c || e.isRealtime || 0 === d ? (b.rk = !b.location.o(), e.doLayout(b), b.C(32), Cj(a, b), e.isValidLayout = !0) : a.Cg = !0) } } t.iz = function () { for (var a = new F, b = this.nodes; b.next();) { var c = b.value; c.isTopLevel && null === c.Li() && a.add(c) } return a.iterator };
    function Fi(a) {
        function b(a) { var b = a.toLowerCase(), e = new F; c.add(a, e); c.add(b, e); d.add(a, a); d.add(b, a) } var c = new Ub, d = new Ub; b("AnimationStarting"); b("AnimationFinished"); b("BackgroundSingleClicked"); b("BackgroundDoubleClicked"); b("BackgroundContextClicked"); b("ClipboardChanged"); b("ClipboardPasted"); b("DocumentBoundsChanged"); b("ExternalObjectsDropped"); b("GainedFocus"); b("InitialLayoutCompleted"); b("LayoutCompleted"); b("LinkDrawn"); b("LinkRelinked"); b("LinkReshaped"); b("LostFocus"); b("Modified");
        b("ObjectSingleClicked"); b("ObjectDoubleClicked"); b("ObjectContextClicked"); b("PartCreated"); b("PartResized"); b("PartRotated"); b("SelectionMoved"); b("SelectionCopied"); b("SelectionDeleting"); b("SelectionDeleted"); b("SelectionGrouped"); b("SelectionUngrouped"); b("ChangingSelection"); b("ChangedSelection"); b("SubGraphCollapsed"); b("SubGraphExpanded"); b("TextEdited"); b("TreeCollapsed"); b("TreeExpanded"); b("ViewportBoundsChanged"); b("InvalidateDraw"); a.Xt = c; a.Wt = d
    }
    function Lj(a, b) { var c = a.Wt.K(b); return null !== c ? c : a.Wt.K(b.toLowerCase()) } function xk(a, b) { var c = a.Xt.K(b); if (null !== c) return c; c = a.Xt.K(b.toLowerCase()); if (null !== c) return c; v("Unknown DiagramEvent name: " + b); return null } t.Rj = function (a, b) { z(a, "string", P, "addDiagramListener:name"); z(b, "function", P, "addDiagramListener:listener"); a = xk(this, a); null !== a && a.add(b) }; t.rm = function (a, b) { z(a, "string", P, "removeDiagramListener:name"); z(b, "function", P, "addDiagramListener:listener"); a = xk(this, a); null !== a && a.remove(b) };
    t.ba = function (a, b, c) { E && z(a, "string", P, "raiseDiagramEvent:name"); var d = xk(this, a), e = new mf; e.diagram = this; a = Lj(this, a); null !== a && (e.name = a); void 0 !== b && (e.subject = b); void 0 !== c && (e.parameter = c); b = d.length; if (1 === b) d.O(0)(e); else if (0 !== b) for (d = d.Oa(), c = 0; c < b; c++)(0, d[c])(e) }; function yk(a) { if (a.animationManager.isAnimating) return !1; var b = a.currentTool; return b === a.toolManager.findTool("Dragging") ? !a.Cp || b.isComplexRoutingRealtime : !0 }
    t.ik = function (a, b) { void 0 === b && (b = null); return zk(this, !1, null, b).ik(a.x, a.y, a.width, a.height) }; P.prototype.computeOccupiedArea = function () { return this.isVirtualized ? this.viewportBounds.copy() : this.Rg ? fj(this) : this.documentBounds.copy() };
    function zk(a, b, c, d) {
    null === a.Qb && (a.Qb = new Ak); if (a.Qb.ft || a.Qb.group !== c || a.Qb.Qx !== d) {
        if (null === c) { b = a.computeOccupiedArea(); b.Xc(100, 100); a.Qb.initialize(b); b = L.alloc(); for (var e = a.nodes; e.next();) { var f = e.value, g = f.layer; null !== g && g.visible && !g.isTemporary && Bk(a, f, d, b) } L.free(b) } else { 0 < c.memberParts.count && (b = a.computePartsBounds(c.memberParts, !1), b.Xc(20, 20), a.Qb.initialize(b)); b = L.alloc(); for (e = c.memberParts; e.next();)f = e.value, f instanceof V && Bk(a, f, d, b); L.free(b) } a.Qb.group = c; a.Qb.Qx = d; a.Qb.ft =
            !1
    } else b && Ck(a.Qb); return a.Qb
    } function Bk(a, b, c, d) { if (b !== c) if (b.isVisible() && b.avoidable && !b.isLinkLabel) { var e = b.getAvoidableRect(d), f = a.Qb.Yl; c = a.Qb.Xl; d = e.x + e.width; b = e.y + e.height; for (var g = e.x; g < d; g += f) { for (var h = e.y; h < b; h += c)Dk(a.Qb, g, h); Dk(a.Qb, g, b) } for (e = e.y; e < b; e += c)Dk(a.Qb, d, e); Dk(a.Qb, d, b) } else if (b instanceof xg) for (b = b.memberParts; b.next();)e = b.value, e instanceof V && Bk(a, e, c, d) }
    function Ek(a, b) { null !== a.Qb && !a.Qb.ft && (void 0 === b && (b = null), null === b || b.avoidable && !b.isLinkLabel) && (a.Qb.ft = !0) } t = P.prototype; t.Ts = function (a) { this.Tq.assign(a); Fk(this, this.Tq).Sa(this.position) ? this.yf() : Gk(this) };
    function Gk(a) { -1 === a.Fk && (a.Fk = wa(function () { if (-1 !== a.Fk && (a.yf(), null !== a.lastInput.event)) { var b = Fk(a, a.Tq); b.Sa(a.position) || (a.position = b, a.lastInput.documentPoint = a.Dt(a.Tq), a.doMouseMove(), a.Rg = !0, jj(a, a.documentBounds.copy().Lc(a.computeBounds())), a.oc = !0, a.hd(), Gk(a)) } }, a.Xm)) } t.yf = function () { -1 !== this.Fk && (qa.clearTimeout(this.Fk), this.Fk = -1) };
    function Fk(a, b) {
        var c = a.position, d = a.Ym; if (0 >= d.top && 0 >= d.left && 0 >= d.right && 0 >= d.bottom) return c; var e = a.viewportBounds, f = a.scale; e = L.allocAt(0, 0, e.width * f, e.height * f); var g = J.allocAt(0, 0); if (b.x >= e.x && b.x < e.x + d.left) { var h = Math.max(a.scrollHorizontalLineChange, 1); h |= 0; g.x -= h; b.x < e.x + d.left / 2 && (g.x -= h); b.x < e.x + d.left / 4 && (g.x -= 4 * h) } else b.x <= e.x + e.width && b.x > e.x + e.width - d.right && (h = Math.max(a.scrollHorizontalLineChange, 1), h |= 0, g.x += h, b.x > e.x + e.width - d.right / 2 && (g.x += h), b.x > e.x + e.width - d.right / 4 &&
            (g.x += 4 * h)); b.y >= e.y && b.y < e.y + d.top ? (a = Math.max(a.scrollVerticalLineChange, 1), a |= 0, g.y -= a, b.y < e.y + d.top / 2 && (g.y -= a), b.y < e.y + d.top / 4 && (g.y -= 4 * a)) : b.y <= e.y + e.height && b.y > e.y + e.height - d.bottom && (a = Math.max(a.scrollVerticalLineChange, 1), a |= 0, g.y += a, b.y > e.y + e.height - d.bottom / 2 && (g.y += a), b.y > e.y + e.height - d.bottom / 4 && (g.y += 4 * a)); g.Sa(gc) || (c = new J(c.x + g.x / f, c.y + g.y / f)); L.free(e); J.free(g); return c
    } t.nt = function () { return null }; t.tv = function () { return null }; t.py = function (a, b) { this.uu.add(a, b) };
    function Hk(a, b, c) { function d() { var a = +new Date; f = !0; for (g.reset(); g.next();)if (!g.value[0].rl) { f = !1; break } f || a - l > k ? b(c, e, h) : qa.requestAnimationFrame(d) } for (var e = c.callback, f = !0, g = a.Gj.iterator; g.next();)if (!g.value[0].rl) { f = !1; break } if ("function" !== typeof e || f) return b(c, e, a); var h = a, k = c.callbackTimeout || 300, l = +new Date; qa.requestAnimationFrame(function () { d() }); return null } t.Jz = function (a) { if (!Ih) return null; void 0 === a && (a = new xb); a.returnType = "Image"; return this.xx(a) };
    t.xx = function (a) { void 0 === a && (a = new xb); return Hk(this, this.Kz, a) };
    t.Kz = function (a, b, c) {
        var d = Ik(c, a, "canvas", null); if (null === d) return null; c = d.Y.canvas; var e = null; if (null !== c) switch (e = a.returnType, void 0 === e ? e = "string" : e = e.toLowerCase(), e) {
            case "imagedata": e = d.getImageData(0, 0, c.width, c.height); break; case "image": d = (a.document || document).createElement("img"); d.src = c.toDataURL(a.type, a.details); e = d; break; case "blob": "function" !== typeof b && v('Error: Diagram.makeImageData called with "returnType: toBlob", but no required "callback" function property defined.'); if ("function" ===
                typeof c.toBlob) return c.toBlob(b, a.type, a.details), "toBlob"; if ("function" === typeof c.msToBlob) return b(c.msToBlob()), "msToBlob"; b(null); return null; default: e = c.toDataURL(a.type, a.details)
        }return "function" === typeof b ? (b(e), null) : e
    };
    function Ik(a, b, c, d) {
        a.animationManager.xd(); a.hd(); if (null === a.Ea) return null; "object" !== typeof b && v("properties argument must be an Object."); var e = !1, f = b.size || null, g = b.scale || null; void 0 !== b.scale && isNaN(b.scale) && (g = "NaN"); var h = b.maxSize; void 0 === b.maxSize && (e = !0, h = "SVG" === c ? new Zb(Infinity, Infinity) : new Zb(2E3, 2E3)); var k = b.position || null, l = b.parts || null, m = void 0 === b.padding ? 1 : b.padding, n = b.background || null, p = b.omitTemporary; void 0 === p && (p = !0); var q = b.document || document, r = b.elementFinished ||
            null, u = b.showTemporary; void 0 === u && (u = !p); b = b.showGrid; void 0 === b && (b = u); null !== f && isNaN(f.width) && isNaN(f.height) && (f = null); "number" === typeof m ? m = new Hc(m) : m instanceof Hc || v("MakeImage padding must be a Margin or a number."); m.left = Math.max(m.left, 0); m.right = Math.max(m.right, 0); m.top = Math.max(m.top, 0); m.bottom = Math.max(m.bottom, 0); a.$c.Uc(!0); p = new Jk(null, q); var x = p.context; if (!(f || g || l || k)) {
            p.width = a.Aa + Math.ceil(m.left + m.right); p.height = a.ya + Math.ceil(m.top + m.bottom); if ("SVG" === c) {
                if (null ===
                    d) return null; d.resize(p.width, p.height, p.width, p.height); d.ownerDocument = q; d.Zp = r; Jj(a, d.context, m, new Zb(p.width, p.height), a.Da, a.ua, l, n, u, b); return d.context
            } a.Bn = !1; Jj(a, x, m, new Zb(p.width, p.height), a.Da, a.ua, l, n, u, b); a.Bn = !0; return p.context
            } var y = a.kr, A = a.documentBounds.copy(); A.Vv(a.gb); if (u) for (var C = a.Ra.j, G = C.length, H = 0; H < G; H++) {
                var O = C[H]; if (O.visible && O.isTemporary) {
                    O = O.Ga.j; for (var S = O.length, T = 0; T < S; T++) {
                        var ea = O[T]; ea.isInDocumentBounds && ea.isVisible() && (ea = ea.actualBounds, ea.o() &&
                            A.Lc(ea))
                    }
                }
            } C = new J(A.x, A.y); if (null !== l) { G = !0; H = l.iterator; for (H.reset(); H.next();)if (O = H.value, O instanceof R && (S = O.layer, (null === S || S.visible) && (null === S || u || !S.isTemporary) && O.isVisible() && (O = O.actualBounds, O.o()))) if (G) { G = !1; var Z = O.copy() } else Z.Lc(O); G && (Z = new L(0, 0, 0, 0)); A.width = Z.width; A.height = Z.height; C.x = Z.x; C.y = Z.y } null !== k && k.o() && (C = k, g || (g = y)); Z = k = 0; null !== m && (k = m.left + m.right, Z = m.top + m.bottom); G = H = 0; null !== f && (H = f.width, G = f.height, isFinite(H) && (H = Math.max(0, H - k)), isFinite(G) && (G =
                Math.max(0, G - Z))); null !== f && null !== g ? ("NaN" === g && (g = y), f.o() ? (f = H, A = G) : isNaN(G) ? (f = H, A = A.height * g) : (f = A.width * g, A = G)) : null !== f ? f.o() ? (g = Math.min(H / A.width, G / A.height), f = H, A = G) : isNaN(G) ? (g = H / A.width, f = H, A = A.height * g) : (g = G / A.height, f = A.width * g, A = G) : null !== g ? "NaN" === g && h.o() ? (g = Math.min((h.width - k) / A.width, (h.height - Z) / A.height), g > y ? (g = y, f = A.width, A = A.height) : (f = h.width, A = h.height)) : (f = A.width * g, A = A.height * g) : (g = y, f = A.width, A = A.height); null !== m ? (f += k, A += Z) : m = new Hc(0); null !== h && (y = h.width, h = h.height,
                    "SVG" !== c && e && !Kk && E && (f > y || A > h) && (Ga("Diagram.makeImage(data): Diagram width or height is larger than the default max size. (" + Math.ceil(f) + "x" + Math.ceil(A) + " vs 2000x2000) Consider increasing the max size."), Kk = !0), isNaN(y) && (y = 2E3), isNaN(h) && (h = 2E3), isFinite(y) && (f = Math.min(f, y)), isFinite(h) && (A = Math.min(A, h))); p.width = Math.ceil(f); p.height = Math.ceil(A); if ("SVG" === c) {
                        if (null === d) return null; d.resize(p.width, p.height, p.width, p.height); d.ownerDocument = q; d.Zp = r; Jj(a, d.context, m, new Zb(Math.ceil(f),
                            Math.ceil(A)), g, C, l, n, u, b); return d.context
                    } a.Bn = !1; Jj(a, x, m, new Zb(Math.ceil(f), Math.ceil(A)), g, C, l, n, u, b); a.Bn = !0; return p.context
    }
    na.Object.defineProperties(P.prototype, {
        div: {
            configurable: !0, get: function () { return this.Ja }, set: function (a) {
            null !== a && w(a, HTMLDivElement, P, "div"); if (this.Ja !== a) {
                bb = []; var b = this.Ja; null !== b ? (b.D = void 0, b.innerHTML = "", null !== this.Ea && (b = this.Ea.Ha, this.removeEventListener(b, "touchstart", this.$v, !1), this.removeEventListener(b, "touchmove", this.Zv, !1), this.removeEventListener(b, "touchend", this.Yv, !1), this.Ea.jx()), b = this.toolManager, null !== b && (b.mouseDownTools.each(function (a) { a.cancelWaitAfter() }),
                    b.mouseMoveTools.each(function (a) { a.cancelWaitAfter() }), b.mouseUpTools.each(function (a) { a.cancelWaitAfter() })), b.cancelWaitAfter(), this.currentTool.doCancel(), this.$c = this.Ea = null, this.removeEventListener(qa, "resize", this.fw, !1), this.removeEventListener(qa, "mousemove", this.mk, !0), this.removeEventListener(qa, "mousedown", this.lk, !0), this.removeEventListener(qa, "mouseup", this.pk, !0), this.removeEventListener(qa, "wheel", this.qk, !0), this.removeEventListener(qa, "mouseout", this.nk, !0), yf === this && (yf = null)) :
                    this.je = !1; this.Ja = null; if (null !== a) { if (b = a.D) b.div = null; Pi(this, a); this.vf() }
            }
            }
        }, $w: { configurable: !0, get: function () { return this.Ao } }, rv: { configurable: !0, get: function () { return this.pb }, set: function (a) { this.pb = a } }, Ti: { configurable: !0, get: function () { return this.je } }, draggedLink: { configurable: !0, get: function () { return this.nr }, set: function (a) { this.nr !== a && (this.nr = a, null !== a && (this.js = a.fromPort, this.ks = a.toPort)) } }, Ax: {
            configurable: !0,
            get: function () { return this.js }, set: function (a) { this.js = a }
        }, Bx: { configurable: !0, get: function () { return this.ks }, set: function (a) { this.ks = a } }, animationManager: { configurable: !0, get: function () { return this.Dk } }, undoManager: { configurable: !0, get: function () { return this.ac.undoManager } }, skipsUndoManager: { configurable: !0, get: function () { return this.eh }, set: function (a) { z(a, "boolean", P, "skipsUndoManager"); this.eh = a; this.ac.skipsUndoManager = a } }, delaysLayout: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Vt }, set: function (a) { this.Vt = a }
        }, validCycle: { configurable: !0, get: function () { return this.Ls }, set: function (a) { var b = this.Ls; b !== a && (tb(a, P, P, "validCycle"), this.Ls = a, this.g("validCycle", b, a)) } }, layers: { configurable: !0, get: function () { return this.Ra.iterator } }, isModelReadOnly: { configurable: !0, get: function () { var a = this.ac; return null === a ? !1 : a.isReadOnly }, set: function (a) { var b = this.ac; null !== b && (b.isReadOnly = a) } }, isReadOnly: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Of }, set: function (a) { var b = this.Of; b !== a && (z(a, "boolean", P, "isReadOnly"), this.Of = a, this.g("isReadOnly", b, a)) }
        }, isEnabled: { configurable: !0, get: function () { return this.Fc }, set: function (a) { var b = this.Fc; b !== a && (z(a, "boolean", P, "isEnabled"), this.Fc = a, this.g("isEnabled", b, a)) } }, allowClipboard: {
            configurable: !0, get: function () { return this.Kq }, set: function (a) {
                var b = this.Kq; b !== a && (z(a, "boolean", P, "allowClipboard"), this.Kq = a, this.g("allowClipboard",
                    b, a))
            }
        }, allowCopy: { configurable: !0, get: function () { return this.Gh }, set: function (a) { var b = this.Gh; b !== a && (z(a, "boolean", P, "allowCopy"), this.Gh = a, this.g("allowCopy", b, a)) } }, allowDelete: { configurable: !0, get: function () { return this.Hh }, set: function (a) { var b = this.Hh; b !== a && (z(a, "boolean", P, "allowDelete"), this.Hh = a, this.g("allowDelete", b, a)) } }, allowDragOut: {
            configurable: !0, get: function () { return this.Lq }, set: function (a) {
                var b = this.Lq; b !== a && (z(a, "boolean", P, "allowDragOut"),
                    this.Lq = a, this.g("allowDragOut", b, a))
            }
        }, allowDrop: { configurable: !0, get: function () { return this.Mq }, set: function (a) { var b = this.Mq; b !== a && (z(a, "boolean", P, "allowDrop"), this.Mq = a, this.g("allowDrop", b, a)) } }, allowTextEdit: { configurable: !0, get: function () { return this.Qh }, set: function (a) { var b = this.Qh; b !== a && (z(a, "boolean", P, "allowTextEdit"), this.Qh = a, this.g("allowTextEdit", b, a)) } }, allowGroup: {
            configurable: !0, get: function () { return this.Ih }, set: function (a) {
                var b = this.Ih;
                b !== a && (z(a, "boolean", P, "allowGroup"), this.Ih = a, this.g("allowGroup", b, a))
            }
        }, allowUngroup: { configurable: !0, get: function () { return this.Rh }, set: function (a) { var b = this.Rh; b !== a && (z(a, "boolean", P, "allowUngroup"), this.Rh = a, this.g("allowUngroup", b, a)) } }, allowInsert: { configurable: !0, get: function () { return this.Oq }, set: function (a) { var b = this.Oq; b !== a && (z(a, "boolean", P, "allowInsert"), this.Oq = a, this.g("allowInsert", b, a)) } }, allowLink: {
            configurable: !0, get: function () { return this.Jh },
            set: function (a) { var b = this.Jh; b !== a && (z(a, "boolean", P, "allowLink"), this.Jh = a, this.g("allowLink", b, a)) }
        }, allowRelink: { configurable: !0, get: function () { return this.Lh }, set: function (a) { var b = this.Lh; b !== a && (z(a, "boolean", P, "allowRelink"), this.Lh = a, this.g("allowRelink", b, a)) } }, allowMove: { configurable: !0, get: function () { return this.Kh }, set: function (a) { var b = this.Kh; b !== a && (z(a, "boolean", P, "allowMove"), this.Kh = a, this.g("allowMove", b, a)) } }, allowReshape: {
            configurable: !0,
            get: function () { return this.Mh }, set: function (a) { var b = this.Mh; b !== a && (z(a, "boolean", P, "allowReshape"), this.Mh = a, this.g("allowReshape", b, a)) }
        }, allowResize: { configurable: !0, get: function () { return this.Nh }, set: function (a) { var b = this.Nh; b !== a && (z(a, "boolean", P, "allowResize"), this.Nh = a, this.g("allowResize", b, a)) } }, allowRotate: { configurable: !0, get: function () { return this.Oh }, set: function (a) { var b = this.Oh; b !== a && (z(a, "boolean", P, "allowRotate"), this.Oh = a, this.g("allowRotate", b, a)) } },
        allowSelect: { configurable: !0, get: function () { return this.Ph }, set: function (a) { var b = this.Ph; b !== a && (z(a, "boolean", P, "allowSelect"), this.Ph = a, this.g("allowSelect", b, a)) } }, allowUndo: { configurable: !0, get: function () { return this.Pq }, set: function (a) { var b = this.Pq; b !== a && (z(a, "boolean", P, "allowUndo"), this.Pq = a, this.g("allowUndo", b, a)) } }, allowZoom: {
            configurable: !0, get: function () { return this.Rq }, set: function (a) {
                var b = this.Rq; b !== a && (z(a, "boolean", P, "allowZoom"), this.Rq =
                    a, this.g("allowZoom", b, a))
            }
        }, hasVerticalScrollbar: { configurable: !0, get: function () { return this.Cr }, set: function (a) { var b = this.Cr; b !== a && (z(a, "boolean", P, "hasVerticalScrollbar"), this.Cr = a, wj(this), this.S(), this.g("hasVerticalScrollbar", b, a), gj(this, !1)) } }, hasHorizontalScrollbar: {
            configurable: !0, get: function () { return this.Br }, set: function (a) {
                var b = this.Br; b !== a && (z(a, "boolean", P, "hasHorizontalScrollbar"), this.Br = a, wj(this), this.S(), this.g("hasHorizontalScrollbar", b, a), gj(this,
                    !1))
            }
        }, allowHorizontalScroll: { configurable: !0, get: function () { return this.Nq }, set: function (a) { var b = this.Nq; b !== a && (z(a, "boolean", P, "allowHorizontalScroll"), this.Nq = a, this.g("allowHorizontalScroll", b, a), gj(this, !1)) } }, allowVerticalScroll: { configurable: !0, get: function () { return this.Qq }, set: function (a) { var b = this.Qq; b !== a && (z(a, "boolean", P, "allowVerticalScroll"), this.Qq = a, this.g("allowVerticalScroll", b, a), gj(this, !1)) } }, scrollHorizontalLineChange: {
            configurable: !0,
            get: function () { return this.vs }, set: function (a) { var b = this.vs; b !== a && (z(a, "number", P, "scrollHorizontalLineChange"), 0 > a && Ca(a, ">= 0", P, "scrollHorizontalLineChange"), this.vs = a, this.g("scrollHorizontalLineChange", b, a)) }
        }, scrollVerticalLineChange: { configurable: !0, get: function () { return this.xs }, set: function (a) { var b = this.xs; b !== a && (z(a, "number", P, "scrollVerticalLineChange"), 0 > a && Ca(a, ">= 0", P, "scrollVerticalLineChange"), this.xs = a, this.g("scrollVerticalLineChange", b, a)) } }, lastInput: {
            configurable: !0,
            enumerable: !0, get: function () { return this.uj }, set: function (a) { E && w(a, kf, P, "lastInput"); this.uj = a }
        }, firstInput: { configurable: !0, get: function () { return this.Zh }, set: function (a) { E && w(a, kf, P, "firstInput"); this.Zh = a } }, currentCursor: {
            configurable: !0, get: function () { return this.dr }, set: function (a) {
            "" === a && (a = this.un); if (this.dr !== a) {
                z(a, "string", P, "currentCursor"); var b = this.Ea, c = this.Ja; if (null !== b) {
                this.dr = a; var d = b.style.cursor; b.style.cursor = a; c.style.cursor = a; b.style.cursor ===
                    d && (b.style.cursor = "-webkit-" + a, c.style.cursor = "-webkit-" + a, b.style.cursor === d && (b.style.cursor = "-moz-" + a, c.style.cursor = "-moz-" + a, b.style.cursor === d && (b.style.cursor = a, c.style.cursor = a)))
                }
            }
            }
        }, defaultCursor: { configurable: !0, get: function () { return this.un }, set: function (a) { "" === a && (a = "auto"); var b = this.un; b !== a && (z(a, "string", P, "defaultCursor"), this.un = a, this.g("defaultCursor", b, a)) } }, click: {
            configurable: !0, get: function () { return this.Df }, set: function (a) {
                var b = this.Df; b !==
                    a && (null !== a && z(a, "function", P, "click"), this.Df = a, this.g("click", b, a))
            }
        }, doubleClick: { configurable: !0, get: function () { return this.If }, set: function (a) { var b = this.If; b !== a && (null !== a && z(a, "function", P, "doubleClick"), this.If = a, this.g("doubleClick", b, a)) } }, contextClick: { configurable: !0, get: function () { return this.Ef }, set: function (a) { var b = this.Ef; b !== a && (null !== a && z(a, "function", P, "contextClick"), this.Ef = a, this.g("contextClick", b, a)) } }, mouseOver: {
            configurable: !0,
            get: function () { return this.Yf }, set: function (a) { var b = this.Yf; b !== a && (null !== a && z(a, "function", P, "mouseOver"), this.Yf = a, this.g("mouseOver", b, a)) }
        }, mouseHover: { configurable: !0, get: function () { return this.Wf }, set: function (a) { var b = this.Wf; b !== a && (null !== a && z(a, "function", P, "mouseHover"), this.Wf = a, this.g("mouseHover", b, a)) } }, mouseHold: {
            configurable: !0, get: function () { return this.Vf }, set: function (a) {
                var b = this.Vf; b !== a && (null !== a && z(a, "function", P, "mouseHold"), this.Vf = a, this.g("mouseHold",
                    b, a))
            }
        }, mouseDragOver: { configurable: !0, get: function () { return this.cs }, set: function (a) { var b = this.cs; b !== a && (null !== a && z(a, "function", P, "mouseDragOver"), this.cs = a, this.g("mouseDragOver", b, a)) } }, mouseDrop: { configurable: !0, get: function () { return this.Tf }, set: function (a) { var b = this.Tf; b !== a && (E && null !== a && z(a, "function", P, "mouseDrop"), this.Tf = a, this.g("mouseDrop", b, a)) } }, handlesDragDropForTopLevelParts: {
            configurable: !0, get: function () { return this.Ar }, set: function (a) {
                var b =
                    this.Ar; b !== a && (z(a, "boolean", P, "handlesDragDropForTopLevelParts"), this.Ar = a, this.g("handlesDragDropForTopLevelParts", b, a))
            }
        }, mouseEnter: { configurable: !0, get: function () { return this.Uf }, set: function (a) { var b = this.Uf; b !== a && (null !== a && z(a, "function", P, "mouseEnter"), this.Uf = a, this.g("mouseEnter", b, a)) } }, mouseLeave: { configurable: !0, get: function () { return this.Xf }, set: function (a) { var b = this.Xf; b !== a && (null !== a && z(a, "function", P, "mouseLeave"), this.Xf = a, this.g("mouseLeave", b, a)) } },
        toolTip: { configurable: !0, get: function () { return this.jg }, set: function (a) { var b = this.jg; b !== a && (!E || null === a || a instanceof Cf || a instanceof Hf || v("Diagram.toolTip must be an Adornment or HTMLInfo."), this.jg = a, this.g("toolTip", b, a)) } }, contextMenu: { configurable: !0, get: function () { return this.Ff }, set: function (a) { var b = this.Ff; b !== a && (!E || a instanceof Cf || a instanceof Hf || v("Diagram.contextMenu must be an Adornment or HTMLInfo."), this.Ff = a, this.g("contextMenu", b, a)) } }, commandHandler: {
            configurable: !0,
            enumerable: !0, get: function () { return this.L }, set: function (a) { this.L !== a && (this.L = a, a.ib(this)) }
        }, toolManager: { configurable: !0, get: function () { return this.Wb }, set: function (a) { this.Wb !== a && (w(a, $a, P, "toolManager"), this.Wb = a, a.ib(this)) } }, defaultTool: { configurable: !0, get: function () { return this.Ma }, set: function (a) { var b = this.Ma; b !== a && (w(a, vf, P, "defaultTool"), this.Ma = a, a.ib(this), this.currentTool === b && (this.currentTool = a)) } }, currentTool: {
            configurable: !0, get: function () { return this.ca },
            set: function (a) { var b = this.ca; null !== b && (b.isActive && b.doDeactivate(), b.cancelWaitAfter(), b.doStop()); null === a && (a = this.defaultTool); null !== a && (w(a, vf, P, "currentTool"), this.ca = a, a.ib(this), a.doStart()) }
        }, selection: { configurable: !0, get: function () { return this.Iq } }, maxSelectionCount: {
            configurable: !0, get: function () { return this.Yr }, set: function (a) {
                var b = this.Yr; if (b !== a) if (z(a, "number", P, "maxSelectionCount"), 0 <= a && !isNaN(a)) {
                    if (this.Yr = a, this.g("maxSelectionCount", b, a), !this.undoManager.isUndoingRedoing &&
                        (a = this.selection.count - a, 0 < a)) { this.ba("ChangingSelection", this.selection); b = this.selection.Oa(); for (var c = 0; c < a; c++)b[c].isSelected = !1; this.ba("ChangedSelection", this.selection) }
                } else Ca(a, ">= 0", P, "maxSelectionCount")
            }
        }, nodeSelectionAdornmentTemplate: { configurable: !0, get: function () { return this.fs }, set: function (a) { var b = this.fs; b !== a && (w(a, Cf, P, "nodeSelectionAdornmentTemplate"), this.fs = a, this.g("nodeSelectionAdornmentTemplate", b, a)) } }, groupSelectionAdornmentTemplate: {
            configurable: !0,
            enumerable: !0, get: function () { return this.yr }, set: function (a) { var b = this.yr; b !== a && (w(a, Cf, P, "groupSelectionAdornmentTemplate"), this.yr = a, this.g("groupSelectionAdornmentTemplate", b, a)) }
        }, linkSelectionAdornmentTemplate: { configurable: !0, get: function () { return this.Ur }, set: function (a) { var b = this.Ur; b !== a && (w(a, Cf, P, "linkSelectionAdornmentTemplate"), this.Ur = a, this.g("linkSelectionAdornmentTemplate", b, a)) } }, highlighteds: { configurable: !0, get: function () { return this.Gq } }, isModified: {
            configurable: !0,
            enumerable: !0, get: function () { var a = this.undoManager; return a.isEnabled ? null !== a.currentTransaction ? !0 : this.w && this.ie !== a.historyIndex : this.w }, set: function (a) { if (this.w !== a) { z(a, "boolean", P, "isModified"); this.w = a; var b = this.undoManager; !a && b.isEnabled && (this.ie = b.historyIndex); a || ik(this) } }
        }, model: {
            configurable: !0, get: function () { return this.ac }, set: function (a) {
                var b = this.ac; if (b !== a) {
                    w(a, X, P, "model"); this.currentTool.doCancel(); null !== b && b.undoManager !== a.undoManager && b.undoManager.isInTransaction &&
                        v("Do not replace a Diagram.model while a transaction is in progress."); Si(this, !0); this.je = !1; this.al = !0; this.ie = -2; this.sd = !1; var c = this.$b; this.$b = !0; this.animationManager.Ch("Model"); null !== b && (null !== this.re && this.re.each(function (a) { b.tk(a) }), b.tk(this.Gm)); this.ac = a; this.partManager = jk(this.ac.constructor.type); a.rh(this.zg); this.partManager.addAllModeledParts(); a.tk(this.zg); a.rh(this.Gm); null !== this.re && this.re.each(function (b) { a.rh(b) }); this.$b = c; this.pb || this.S(); null !== b && a.undoManager.copyProperties(b.undoManager)
                }
            }
        },
        fa: { configurable: !0, get: function () { return this.Oc }, set: function (a) { this.Oc = a } }, lt: { configurable: !0, get: function () { return this.Hq } }, skipsModelSourceBindings: { configurable: !0, get: function () { return this.Eh }, set: function (a) { this.Eh = a } }, Yi: { configurable: !0, get: function () { return this.Bu }, set: function (a) { this.Bu = a } }, nodeTemplate: {
            configurable: !0, get: function () { return this.Zf.K("") }, set: function (a) {
                var b = this.Zf.K(""); b !== a && (w(a, R, P, "nodeTemplate"),
                    this.Zf.add("", a), this.g("nodeTemplate", b, a), this.undoManager.isUndoingRedoing || this.wd())
            }
        }, nodeTemplateMap: { configurable: !0, get: function () { return this.Zf }, set: function (a) { var b = this.Zf; b !== a && (w(a, Ub, P, "nodeTemplateMap"), this.Zf = a, this.g("nodeTemplateMap", b, a), this.undoManager.isUndoingRedoing || this.wd()) } }, groupTemplate: {
            configurable: !0, get: function () { return this.$h.K("") }, set: function (a) {
                var b = this.$h.K(""); b !== a && (w(a, xg, P, "groupTemplate"), this.$h.add("", a), this.g("groupTemplate",
                    b, a), this.undoManager.isUndoingRedoing || this.wd())
            }
        }, groupTemplateMap: { configurable: !0, get: function () { return this.$h }, set: function (a) { var b = this.$h; b !== a && (w(a, Ub, P, "groupTemplateMap"), this.$h = a, this.g("groupTemplateMap", b, a), this.undoManager.isUndoingRedoing || this.wd()) } }, linkTemplate: {
            configurable: !0, get: function () { return this.Vg.K("") }, set: function (a) {
                var b = this.Vg.K(""); b !== a && (w(a, Q, P, "linkTemplate"), this.Vg.add("", a), this.g("linkTemplate", b, a), this.undoManager.isUndoingRedoing ||
                    this.wd())
            }
        }, linkTemplateMap: { configurable: !0, get: function () { return this.Vg }, set: function (a) { var b = this.Vg; b !== a && (w(a, Ub, P, "linkTemplateMap"), this.Vg = a, this.g("linkTemplateMap", b, a), this.undoManager.isUndoingRedoing || this.wd()) } }, isMouseOverDiagram: { configurable: !0, get: function () { return this.Se }, set: function (a) { this.Se = a } }, isMouseCaptured: {
            configurable: !0, get: function () { return this.Nc }, set: function (a) {
                var b = this.Ea; null !== b && (b = b.Ha, b instanceof SVGElement ||
                    (a ? (this.lastInput.bubbles = !1, this.Sq ? (this.removeEventListener(b, "pointermove", this.nm, !1), this.removeEventListener(b, "pointerdown", this.mm, !1), this.removeEventListener(b, "pointerup", this.pm, !1), this.removeEventListener(b, "pointerout", this.om, !1), this.addEventListener(qa, "pointermove", this.nm, !0), this.addEventListener(qa, "pointerdown", this.mm, !0), this.addEventListener(qa, "pointerup", this.pm, !0), this.addEventListener(qa, "pointerout", this.om, !0)) : (this.removeEventListener(b, "mousemove", this.mk, !1),
                        this.removeEventListener(b, "mousedown", this.lk, !1), this.removeEventListener(b, "mouseup", this.pk, !1), this.removeEventListener(b, "mouseout", this.nk, !1), this.addEventListener(qa, "mousemove", this.mk, !0), this.addEventListener(qa, "mousedown", this.lk, !0), this.addEventListener(qa, "mouseup", this.pk, !0), this.addEventListener(qa, "mouseout", this.nk, !0)), this.removeEventListener(b, "wheel", this.qk, !1), this.addEventListener(qa, "wheel", this.qk, !0), this.addEventListener(qa, "selectstart", this.preventDefault, !1)) : (this.Sq ?
                            (this.removeEventListener(qa, "pointermove", this.nm, !0), this.removeEventListener(qa, "pointerdown", this.mm, !0), this.removeEventListener(qa, "pointerup", this.pm, !0), this.removeEventListener(qa, "pointerout", this.om, !0), this.addEventListener(b, "pointermove", this.nm, !1), this.addEventListener(b, "pointerdown", this.mm, !1), this.addEventListener(b, "pointerup", this.pm, !1), this.addEventListener(b, "pointerout", this.om, !1)) : (this.removeEventListener(qa, "mousemove", this.mk, !0), this.removeEventListener(qa, "mousedown",
                                this.lk, !0), this.removeEventListener(qa, "mouseup", this.pk, !0), this.removeEventListener(qa, "mouseout", this.nk, !0), this.addEventListener(b, "mousemove", this.mk, !1), this.addEventListener(b, "mousedown", this.lk, !1), this.addEventListener(b, "mouseup", this.pk, !1), this.addEventListener(b, "mouseout", this.nk, !1)), this.removeEventListener(qa, "wheel", this.qk, !0), this.removeEventListener(qa, "selectstart", this.preventDefault, !1), this.addEventListener(b, "wheel", this.qk, !1)), this.Nc = a))
            }
        }, position: {
            configurable: !0,
            enumerable: !0, get: function () { return this.ua }, set: function (a) { var b = J.alloc().assign(this.ua); if (!b.A(a)) { w(a, J, P, "position"); var c = this.viewportBounds.copy(); this.ua.assign(a); this.pb || null === this.Ea && !this.Lp.o() || (this.pb = !0, a = this.scale, ij(this, this.zn, this.Aa / a, this.ya / a, this.gj, !1), this.pb = !1); si(this.animationManager, b, this.ua); this.pb || this.sq(c, this.viewportBounds, this.Da, !1) } J.free(b) }
        }, initialPosition: {
            configurable: !0, get: function () { return this.Er }, set: function (a) {
                this.Er.A(a) ||
                (w(a, J, P, "initialPosition"), this.Er = a.J())
            }
        }, initialScale: { configurable: !0, get: function () { return this.Fr }, set: function (a) { this.Fr !== a && (z(a, "number", P, "initialScale"), this.Fr = a) } }, grid: {
            configurable: !0, get: function () { null === this.Hb && Xi(this); return this.Hb }, set: function (a) {
                var b = this.Hb; if (b !== a) {
                null === b && (Xi(this), b = this.Hb); w(a, W, P, "grid"); a.type !== W.Grid && v("Diagram.grid must be a Panel of type Panel.Grid"); var c = b.panel; null !== c && c.remove(b); this.Hb = a; a.name = "GRID";
                    null !== c && c.add(a); zj(this); this.S(); this.g("grid", b, a)
                }
            }
        }, viewportBounds: { configurable: !0, get: function () { var a = this.Sw, b = this.ua, c = this.Da; if (null === this.Ea) return this.Lp.o() && a.h(b.x, b.y, this.Aa / c, this.ya / c), a; a.h(b.x, b.y, Math.max(this.Aa, 0) / c, Math.max(this.ya, 0) / c); return a } }, viewSize: {
            configurable: !0, get: function () { return this.Lp }, set: function (a) {
                var b = this.viewSize; b.A(a) || (w(a, Zb, P, "viewSize"), this.Lp = a = a.J(), this.Aa = a.width, this.ya = a.height, this.Ya(), this.g("viewSize",
                    b, a))
            }
        }, fixedBounds: { configurable: !0, get: function () { return this.vr }, set: function (a) { var b = this.vr; b.A(a) || (w(a, L, P, "fixedBounds"), (E && Infinity === a.width || -Infinity === a.width || Infinity === a.height || -Infinity === a.height) && v("fixedBounds width/height must not be Infinity"), this.vr = a = a.J(), this.Ya(), this.g("fixedBounds", b, a)) } }, scrollMargin: {
            configurable: !0, get: function () { return this.ui }, set: function (a) {
                "number" === typeof a ? a = new Hc(a) : w(a, Hc, P, "scrollMargin"); var b = this.ui;
                b.A(a) || (this.ui = a = a.J(), this.g("scrollMargin", b, a), this.vf())
            }
        }, scrollMode: { configurable: !0, get: function () { return this.Kj }, set: function (a) { var b = this.Kj; b !== a && (tb(a, P, P, "scrollMode"), this.Kj = a, a === Di && gj(this, !1), this.g("scrollMode", b, a), this.vf()) } }, scrollsPageOnFocus: { configurable: !0, get: function () { return this.ys }, set: function (a) { var b = this.ys; b !== a && (z(a, "boolean", P, "scrollsPageOnFocus"), this.ys = a, this.g("scrollsPageOnFocus", b, a)) } }, positionComputation: {
            configurable: !0,
            enumerable: !0, get: function () { return this.ps }, set: function (a) { var b = this.ps; b !== a && (null !== a && z(a, "function", P, "positionComputation"), this.ps = a, gj(this, !1), this.g("positionComputation", b, a)) }
        }, scaleComputation: { configurable: !0, get: function () { return this.ts }, set: function (a) { var b = this.ts; b !== a && (null !== a && z(a, "function", P, "scaleComputation"), this.ts = a, gk(this, this.scale, this.scale), this.g("scaleComputation", b, a)) } }, documentBounds: { configurable: !0, get: function () { return this.zn } },
        isVirtualized: { configurable: !0, get: function () { return this.Pr }, set: function (a) { var b = this.Pr; b !== a && (z(a, "boolean", P, "isVirtualized"), this.Pr = a, this.g("isVirtualized", b, a)) } }, scale: { configurable: !0, get: function () { return this.Da }, set: function (a) { var b = this.Da; B(a, P, "scale"); b !== a && gk(this, b, a) } }, defaultScale: {
            configurable: !0, get: function () { return this.kr }, set: function (a) {
                E && B(a, P, "defaultScale"); !E || 0 < a || v("defaultScale must be larger than zero, not: " + a); this.kr =
                    a
            }
        }, autoScale: { configurable: !0, get: function () { return this.ej }, set: function (a) { var b = this.ej; b !== a && (tb(a, P, P, "autoScale"), this.ej = a, this.g("autoScale", b, a), a !== Ei && gj(this, !1)) } }, initialAutoScale: { configurable: !0, get: function () { return this.ci }, set: function (a) { var b = this.ci; b !== a && (tb(a, P, P, "initialAutoScale"), this.ci = a, this.g("initialAutoScale", b, a)) } }, initialViewportSpot: {
            configurable: !0, get: function () { return this.Gr }, set: function (a) {
                var b = this.Gr; b !== a &&
                    (w(a, M, P, "initialViewportSpot"), a.Za() || v("initialViewportSpot must be a specific Spot: " + a), this.Gr = a, this.g("initialViewportSpot", b, a))
            }
        }, initialDocumentSpot: { configurable: !0, get: function () { return this.Dr }, set: function (a) { var b = this.Dr; b !== a && (w(a, M, P, "initialDocumentSpot"), a.Za() || v("initialViewportSpot must be a specific Spot: " + a), this.Dr = a, this.g("initialDocumentSpot", b, a)) } }, minScale: {
            configurable: !0, get: function () { return this.Zr }, set: function (a) {
                B(a, P, "minScale");
                var b = this.Zr; b !== a && (0 < a ? (this.Zr = a, this.g("minScale", b, a), a > this.scale && (this.scale = a)) : Ca(a, "> 0", P, "minScale"))
            }
        }, maxScale: { configurable: !0, get: function () { return this.Xr }, set: function (a) { B(a, P, "maxScale"); var b = this.Xr; b !== a && (0 < a ? (this.Xr = a, this.g("maxScale", b, a), a < this.scale && (this.scale = a)) : Ca(a, "> 0", P, "maxScale")) } }, zoomPoint: { configurable: !0, get: function () { return this.Os }, set: function (a) { this.Os.A(a) || (w(a, J, P, "zoomPoint"), this.Os = a = a.J()) } }, contentAlignment: {
            configurable: !0,
            enumerable: !0, get: function () { return this.gj }, set: function (a) { var b = this.gj; b.A(a) || (w(a, M, P, "contentAlignment"), this.gj = a = a.J(), this.g("contentAlignment", b, a), gj(this, !1)) }
        }, initialContentAlignment: { configurable: !0, get: function () { return this.Sn }, set: function (a) { var b = this.Sn; b.A(a) || (w(a, M, P, "initialContentAlignment"), this.Sn = a = a.J(), this.g("initialContentAlignment", b, a)) } }, padding: {
            configurable: !0, get: function () { return this.gb }, set: function (a) {
                "number" === typeof a ? a = new Hc(a) :
                w(a, Hc, P, "padding"); var b = this.gb; b.A(a) || (this.gb = a = a.J(), this.Ya(), this.g("padding", b, a))
            }
        }, partManager: { configurable: !0, get: function () { return this.Na }, set: function (a) { var b = this.Na; b !== a && (w(a, Ii, P, "partManager"), null !== a.diagram && v("Cannot share PartManagers between Diagrams: " + a.toString()), null !== b && b.ib(null), this.Na = a, a.ib(this)) } }, nodes: { configurable: !0, get: function () { return this.partManager.nodes.iterator } }, links: { configurable: !0, get: function () { return this.partManager.links.iterator } },
        parts: { configurable: !0, get: function () { return this.partManager.parts.iterator } }, layout: { configurable: !0, get: function () { return this.ic }, set: function (a) { var b = this.ic; b !== a && (w(a, Ni, P, "layout"), this.ic = a, a.diagram = this, a.group = null, this.Cg = !0, this.g("layout", b, a), this.ec()) } }, isTreePathToChildren: {
            configurable: !0, get: function () { return this.Or }, set: function (a) {
                var b = this.Or; if (b !== a && (z(a, "boolean", P, "isTreePathToChildren"), this.Or = a, this.g("isTreePathToChildren",
                    b, a), !this.undoManager.isUndoingRedoing)) for (a = this.nodes; a.next();)Lk(a.value)
            }
        }, treeCollapsePolicy: { configurable: !0, get: function () { return this.Js }, set: function (a) { var b = this.Js; b !== a && (a !== Gi && a !== Mk && a !== Nk && v("Unknown Diagram.treeCollapsePolicy: " + a), this.Js = a, this.g("treeCollapsePolicy", b, a)) } }, He: { configurable: !0, get: function () { return this.Xb }, set: function (a) { this.Xb = a } }, autoScrollInterval: {
            configurable: !0, get: function () { return this.Xm }, set: function (a) {
                var b =
                    this.Xm; B(a, P, "scale"); b !== a && (this.Xm = a, this.g("autoScrollInterval", b, a))
            }
        }, autoScrollRegion: { configurable: !0, get: function () { return this.Ym }, set: function (a) { "number" === typeof a ? a = new Hc(a) : w(a, Hc, P, "autoScrollRegion"); var b = this.Ym; b.A(a) || (this.Ym = a = a.J(), this.Ya(), this.g("autoScrollRegion", b, a)) } }
    }); na.Object.defineProperties(P, { licenseKey: { configurable: !0, get: function () { return Ok.Ub() }, set: function (a) { Ok.add(a) } }, version: { configurable: !0, get: function () { return Pk } } });
    P.prototype.makeImageData = P.prototype.xx; P.prototype.makeImage = P.prototype.Jz; P.prototype.addRenderer = P.prototype.py; P.prototype.makeSVG = P.prototype.tv; P.prototype.makeSvg = P.prototype.nt; P.prototype.stopAutoScroll = P.prototype.yf; P.prototype.doAutoScroll = P.prototype.Ts; P.prototype.isUnoccupied = P.prototype.ik; P.prototype.raiseDiagramEvent = P.prototype.ba; P.prototype.removeDiagramListener = P.prototype.rm; P.prototype.addDiagramListener = P.prototype.Rj; P.prototype.findTreeRoots = P.prototype.iz;
    P.prototype.layoutDiagram = P.prototype.Hz; P.prototype.findTopLevelGroups = P.prototype.bz; P.prototype.findTopLevelNodesAndLinks = P.prototype.cz; P.prototype.findLinksByExample = P.prototype.Ws; P.prototype.findNodesByExample = P.prototype.Xs; P.prototype.findLinkForData = P.prototype.wc; P.prototype.findNodeForData = P.prototype.Ii; P.prototype.findPartForData = P.prototype.xc; P.prototype.findNodeForKey = P.prototype.Kb; P.prototype.findPartForKey = P.prototype.findPartForKey; P.prototype.rebuildParts = P.prototype.wd;
    P.prototype.transformViewToDoc = P.prototype.Dt; P.prototype.transformRectDocToView = P.prototype.hA; P.prototype.transformDocToView = P.prototype.Ct; P.prototype.centerRect = P.prototype.Ou; P.prototype.scrollToRect = P.prototype.Mv; P.prototype.scroll = P.prototype.scroll; P.prototype.highlightCollection = P.prototype.xz; P.prototype.highlight = P.prototype.wz; P.prototype.clearHighlighteds = P.prototype.Qu; P.prototype.selectCollection = P.prototype.Nv; P.prototype.select = P.prototype.select; P.prototype.clearSelection = P.prototype.Vp;
    P.prototype.updateAllRelationshipsFromData = P.prototype.Dq; P.prototype.updateAllTargetBindings = P.prototype.updateAllTargetBindings; P.prototype.commit = P.prototype.commit; P.prototype.rollbackTransaction = P.prototype.xf; P.prototype.commitTransaction = P.prototype.ab; P.prototype.startTransaction = P.prototype.Ca; P.prototype.raiseChanged = P.prototype.g; P.prototype.raiseChangedEvent = P.prototype.cb; P.prototype.removeChangedListener = P.prototype.tk; P.prototype.addChangedListener = P.prototype.rh;
    P.prototype.removeModelChangedListener = P.prototype.Xz; P.prototype.addModelChangedListener = P.prototype.Yw; P.prototype.findLayer = P.prototype.cm; P.prototype.removeLayer = P.prototype.Vz; P.prototype.addLayerAfter = P.prototype.ly; P.prototype.addLayerBefore = P.prototype.Ww; P.prototype.addLayer = P.prototype.Ul; P.prototype.moveParts = P.prototype.moveParts; P.prototype.copyParts = P.prototype.ak; P.prototype.removeParts = P.prototype.wt; P.prototype.remove = P.prototype.remove; P.prototype.add = P.prototype.add;
    P.prototype.clearDelayedGeometries = P.prototype.Pu; P.prototype.setProperties = P.prototype.Tv; P.prototype.resetInputOptions = P.prototype.Jv; P.prototype.setInputOption = P.prototype.aA; P.prototype.getInputOption = P.prototype.fm; P.prototype.resetRenderingHints = P.prototype.Kv; P.prototype.setRenderingHint = P.prototype.Nx; P.prototype.getRenderingHint = P.prototype.Ge; P.prototype.maybeUpdate = P.prototype.hd; P.prototype.requestUpdate = P.prototype.ec; P.prototype.delayInitialization = P.prototype.Fy;
    P.prototype.isUpdateRequested = P.prototype.Dz; P.prototype.redraw = P.prototype.vf; P.prototype.invalidateDocumentBounds = P.prototype.Ya; P.prototype.findObjectsNear = P.prototype.qg; P.prototype.findPartsNear = P.prototype.Zy; P.prototype.findObjectsIn = P.prototype.pg; P.prototype.findPartsIn = P.prototype.ox; P.prototype.findObjectsAt = P.prototype.Ji; P.prototype.findPartsAt = P.prototype.Yy; P.prototype.findObjectAt = P.prototype.Tb; P.prototype.findPartAt = P.prototype.dm; P.prototype.alignDocument = P.prototype.qy;
    P.prototype.zoomToRect = P.prototype.kA; P.prototype.zoomToFit = P.prototype.zoomToFit; P.prototype.diagramScroll = P.prototype.ix; P.prototype.focus = P.prototype.focus; P.prototype.reset = P.prototype.reset; P.useDOM = function (a) { Ih = a ? void 0 !== qa.document : !1 }; P.isUsingDOM = function () { return Ih };
    var yf = null, Hi = new Ub, Vi = null, Ui = null, Ih = void 0 !== qa.document, Qi = null, Ri = "", Ei = new D(P, "None", 0), kj = new D(P, "Uniform", 1), lj = new D(P, "UniformToFill", 2), Jg = new D(P, "CycleAll", 10), Ng = new D(P, "CycleNotDirected", 11), Pg = new D(P, "CycleNotDirectedFast", 12), Qg = new D(P, "CycleNotUndirected", 13), Kg = new D(P, "CycleDestinationTree", 14), Mg = new D(P, "CycleSourceTree", 15), Di = new D(P, "DocumentScroll", 1), Mj = new D(P, "InfiniteScroll", 2), Gi = new D(P, "TreeParentCollapsed", 21), Mk = new D(P, "AllParentsCollapsed", 22), Nk = new D(P,
        "AnyParentsCollapsed", 23), Ok = new F, Pk = "2.0.11", Kk = !1, Qk = null, Bi = !1;
    function Ci() { if (Ih) { var a = qa.document.createElement("canvas"), b = a.getContext("2d"), c = eb("7ca11abfd022028846"); b[c] = eb("398c3597c01238"); for (var d = ["5da73c80a36455d4038e4972187c3cae51fd22", ra.Dx + "4ae6247590da4bb21c324ba3a84e385776", $b.xF + "fb236cdfda5de14c134ba1a95a2d4c7cc6f93c1387", K.za], e = 1; 5 > e; e++)b[eb("7ca11abfd7330390")](eb(d[e - 1]), 10, 15 * e); b[c] = eb("39f046ebb36e4b"); for (c = 1; 5 > c; c++)b[eb("7ca11abfd7330390")](eb(d[c - 1]), 10, 15 * c); Qk = a } } P.className = "Diagram";
    P.fromDiv = function (a) { var b = a; "string" === typeof a && (b = qa.document.getElementById(a)); return b instanceof HTMLDivElement && b.D instanceof P ? b.D : null }; P.inherit = function (a, b) { function c() { } if (Object.getPrototypeOf(a).prototype) throw Error("Used go.Diagram.inherit defining already defined class \n" + a); z(a, "function", P, "inherit"); z(b, "function", P, "inherit"); c.prototype = b.prototype; a.prototype = new c; a.prototype.constructor = a }; P.None = Ei; P.Uniform = kj; P.UniformToFill = lj; P.CycleAll = Jg; P.CycleNotDirected = Ng;
    P.CycleNotDirectedFast = Pg; P.CycleNotUndirected = Qg; P.CycleDestinationTree = Kg; P.CycleSourceTree = Mg; P.DocumentScroll = Di; P.InfiniteScroll = Mj; P.TreeParentCollapsed = Gi; P.AllParentsCollapsed = Mk; P.AnyParentsCollapsed = Nk; function Oi() { this.gy = null; this.l = "zz@orderNum"; "63ad05bbe23a1786468a4c741b6d2" === this._tk ? this.Pe = this.l = !0 : this.Pe = null }
    function Ij(a, b) {
        b.$c.setTransform(b.Pb, 0, 0, b.Pb, 0, 0); if (null === a.Pe) {
            b = "f"; var c = qa[eb("76a715b2f73f148a")][eb("72ba13b5")]; a.Pe = !0; if (Ih) {
                var d = P[eb("76a115b6ed251eaf4692")]; if (d) for (var e = Ok.iterator; e.next();) {
                    d = e.value; d = eb(d).split(eb("39e9")); if (6 > d.length) break; var f = eb(d[1]).split("."); if ("7da71ca0" !== d[4]) break; var g = eb(ra[eb("6cae19")]).split("."); if (f[0] > g[0] || f[0] === g[0] && f[1] >= g[1]) {
                        f = c[eb("76ad18b4f73e")]; for (g = c[eb("73a612b6fb191d")](eb("35e7")) + 2; g < f; g++)b += c[g]; f = b[eb("73a612b6fb191d")](eb(d[2]));
                        0 > f && eb(d[2]) !== eb("7da71ca0ad381e90") && (f = b[eb("73a612b6fb191d")](eb("76a715b2ef3e149757"))); 0 > f && (f = b[eb("73a612b6fb191d")](eb("76a715b2ef3e149757"))); a.Pe = !(0 <= f && f < b[eb("73a612b6fb191d")](eb("35"))); if (!a.Pe) break; f = eb(d[2]); if ("#" !== f[0]) break; g = qa.document.createElement("div"); for (var h = d[0].replace(/[A-Za-z]/g, ""); 4 > h.length;)h += "9"; h = h.substr(h.length - 4); d = ""; d += ["gsh", "gsf"][parseInt(h.substr(0, 1), 10) % 2]; d += ["Header", "Background", "Display", "Feedback"][parseInt(h.substr(0, 1), 10) % 4]; g[eb("79a417a0f0181a8946")] =
                            d; if (qa.document[eb("78a712aa")]) {
                            qa.document[eb("78a712aa")][eb("7bb806b6ed32388c4a875b")](g); h = qa.getComputedStyle(g).getPropertyValue(eb("78a704b7e62456904c9b12701b6532a8")); qa.document[eb("78a712aa")][eb("68ad1bbcf533388c4a875b")](g); if (!h) break; if (-1 !== h.indexOf(parseInt(f[1] + f[2], 16)) && -1 !== h.indexOf(parseInt(f[3] + f[4], 16))) { a.Pe = !1; break } else if (fb || gb || ib || jb) for (d = "." + d, f = 0; f < document.styleSheets.length; f++) {
                                g = document.styleSheets[f].rules || document.styleSheets[f].cssRules; for (var k in g) if (d ===
                                    g[k].selectorText) { a.Pe = !1; break }
                            }
                            } else a.Pe = null, a.Pe = !1
                    }
                } else { k = c[eb("76ad18b4f73e")]; for (e = c[eb("73a612b6fb191d")](eb("35e7")) + 2; e < k; e++)b += c[e]; c = b[eb("73a612b6fb191d")](eb("7da71ca0ad381e90")); a.Pe = !(0 <= c && c < b[eb("73a612b6fb191d")](eb("35"))) }
            }
        } return 0 < a.Pe && a !== a.gy ? !0 : !1
    }
    function Pi(a, b) {
        if (Ih) {
        void 0 !== b && null !== b || v("Diagram setup requires an argument DIV."); null !== a.Ja && v("Diagram has already completed setup."); "string" === typeof b ? a.Ja = qa.document.getElementById(b) : b instanceof HTMLDivElement ? a.Ja = b : v("No DIV or DIV id supplied: " + b); null === a.Ja && v("Invalid DIV id; could not get element with id: " + b); void 0 !== a.Ja.D && v("Invalid div id; div already has a Diagram associated with it."); "static" === qa.getComputedStyle(a.Ja, null).position && (a.Ja.style.position = "relative");
            a.Ja.style["-webkit-tap-highlight-color"] = "rgba(255, 255, 255, 0)"; a.Ja.style["-ms-touch-action"] = "none"; a.Ja.innerHTML = ""; a.Ja.D = a; var c = a.Gs ? new Nj(a) : new Jk(a); void 0 !== c.style && (c.style.position = "absolute", c.style.top = "0px", c.style.left = "0px", "rtl" === qa.getComputedStyle(a.Ja, null).getPropertyValue("direction") && (a.Xn = !0), c.style.zIndex = "2", c.style.userSelect = "none", c.style.webkitUserSelect = "none", c.style.MozUserSelect = "none"); a.Ea = c; a.$c = c.context; b = a.$c; a.Pb = a.computePixelRatio(); a.Aa = a.Ja.clientWidth ||
                1; a.ya = a.Ja.clientHeight || 1; Pj(a, a.Aa, a.ya); a.pr = b.Y[eb("7eba17a4ca3b1a8346")][eb("78a118b7")](b.Y, Qk, 4, 4); a.Ja.insertBefore(c.Ha, a.Ja.firstChild); c = new Jk(null); c.width = 1; c.height = 1; a.Zt = c; a.zw = c.context; if (Ih) {
                    c = xa("div"); var d = xa("div"); c.style.position = "absolute"; c.style.overflow = "auto"; c.style.width = a.Aa + "px"; c.style.height = a.ya + "px"; c.style.zIndex = "1"; d.style.position = "absolute"; d.style.width = "1px"; d.style.height = "1px"; a.Ja.appendChild(c); c.appendChild(d); c.onscroll = Yi; c.onmousedown = cj; c.ontouchstart =
                        cj; c.D = a; c.by = !0; c.ey = !0; a.ws = c; a.mp = d
                } a.tt = ua(function () { a.jh = null; a.S() }, 300); a.fw = ua(function () { hi(a) }, 250); a.preventDefault = function (a) { a.preventDefault(); return !1 }; a.mk = function (b) { if (a.isEnabled) { a.Se = !0; var c = pj(a, b, !0); a.doMouseMove(); a.currentTool.isBeyondDragSize() && (a.Hd = 0); vj(a, c, b) } }; a.lk = function (b) {
                    if (a.isEnabled) if (a.Se = !0, a.Te) b.preventDefault(); else {
                        var c = pj(a, b, !0); c.down = !0; c.clickCount = b.detail; if (gb || ib) b.timeStamp - a.ol < a.Gu && !a.currentTool.isBeyondDragSize() ? a.Hd++ : a.Hd = 1, a.ol =
                            b.timeStamp, c.clickCount = a.Hd; c.clone(a.firstInput); a.doMouseDown(); 1 === b.button ? b.preventDefault() : vj(a, c, b)
                    }
                }; a.pk = function (b) { if (a.isEnabled) if (a.Te && 2 === b.button) b.preventDefault(); else if (a.Te && 0 === b.button && (a.Te = !1), a.Ql) b.preventDefault(); else { a.Se = !0; var c = pj(a, b, !0); c.up = !0; c.clickCount = b.detail; if (gb || ib) c.clickCount = a.Hd; c.bubbles = b.bubbles; c.targetDiagram = rj(b); a.doMouseUp(); a.yf(); vj(a, c, b) } }; a.qk = function (b) {
                    if (a.isEnabled) {
                        var c = pj(a, b, !0); c.bubbles = !0; var d = 0, e = 0; c.delta = 0; void 0 !==
                            b.deltaX ? (0 !== b.deltaX && (d = 0 < b.deltaX ? 1 : -1), 0 !== b.deltaY && (e = 0 < b.deltaY ? 1 : -1), c.delta = Math.abs(b.deltaX) > Math.abs(b.deltaY) ? -d : -e) : void 0 !== b.wheelDeltaX ? (0 !== b.wheelDeltaX && (d = 0 < b.wheelDeltaX ? -1 : 1), 0 !== b.wheelDeltaY && (e = 0 < b.wheelDeltaY ? -1 : 1), c.delta = Math.abs(b.wheelDeltaX) > Math.abs(b.wheelDeltaY) ? -d : -e) : void 0 !== b.wheelDelta && 0 !== b.wheelDelta && (c.delta = 0 < b.wheelDelta ? 1 : -1); a.doMouseWheel(); vj(a, c, b)
                    }
                }; a.nk = function (b) { a.isEnabled && (a.Se = !1, pj(a, b, !0), b = a.currentTool, b.cancelWaitAfter(), b.standardMouseOver()) };
            a.$v = function (b) { if (a.isEnabled) { a.Ql = !1; a.Te = !0; var c = sj(a, b, b.targetTouches[0], 1 < b.touches.length), d = null; 0 < b.targetTouches.length ? d = b.targetTouches[0] : 0 < b.changedTouches.length && (d = b.changedTouches[0]); if (null !== d) { var e = d.screenX; d = d.screenY; var k = a.Rr; b.timeStamp - a.ol < a.Gu && !(25 < Math.abs(k.x - e) || 25 < Math.abs(k.y - d)) ? a.Hd++ : a.Hd = 1; c.clickCount = a.Hd; a.ol = b.timeStamp; a.Rr.h(e, d) } a.doMouseDown(); vj(a, c, b) } }; a.Zv = function (b) {
                if (a.isEnabled) {
                    var c = null; 0 < b.targetTouches.length ? c = b.targetTouches[0] :
                        0 < b.changedTouches.length && (c = b.changedTouches[0]); c = uj(a, b, c, 1 < b.touches.length); a.doMouseMove(); vj(a, c, b)
                }
            }; a.Yv = function (b) {
                if (a.isEnabled) if (a.Ql) b.preventDefault(); else if (!(1 < b.touches.length)) {
                    var c = null, d = null; 0 < b.targetTouches.length ? d = b.targetTouches[0] : 0 < b.changedTouches.length && (d = b.changedTouches[0]); var e = tj(a, b, !1, !0, !1, !1); null !== d && (c = qa.document.elementFromPoint(d.clientX, d.clientY), null !== c && c.D instanceof P && c.D !== a && qj(c.D, d, e), qj(a, d, e), e.clickCount = a.Hd); null === c ? e.targetDiagram =
                        rj(b) : c.D ? e.targetDiagram = c.D : e.targetDiagram = null; e.targetObject = null; a.doMouseUp(); vj(a, e, b); a.Te = !1
                }
            }; a.mm = function (b) {
                if (a.isEnabled) {
                a.Se = !0; var c = a.su; void 0 === c[b.pointerId] && (c[b.pointerId] = b); c = a.zl; var d = !1; if (null !== c[0] && c[0].pointerId === b.pointerId) c[0] = b; else if (null !== c[1] && c[1].pointerId === b.pointerId) c[1] = b, d = !0; else if (null === c[0]) c[0] = b; else if (null === c[1]) c[1] = b, d = !0; else { b.preventDefault(); return } if ("touch" === b.pointerType || "pen" === b.pointerType) a.Ql = !1, a.Te = !0; c = sj(a, b, b, d);
                    d = a.Rr; var e = "touch" === b.pointerType || "pen" === b.pointerType ? 25 : 10; b.timeStamp - a.ol < a.Gu && !(Math.abs(d.x - b.screenX) > e || Math.abs(d.y - b.screenY) > e) ? a.Hd++ : a.Hd = 1; c.clickCount = a.Hd; a.ol = b.timeStamp; a.Rr.wg(b.screenX, b.screenY); a.doMouseDown(); 1 === b.button ? b.preventDefault() : vj(a, c, b)
                }
            }; a.nm = function (b) {
                if (a.isEnabled) {
                a.Se = !0; var c = a.zl; if (null !== c[0] && c[0].pointerId === b.pointerId) c[0] = b; else { if (null !== c[1] && c[1].pointerId === b.pointerId) { c[1] = b; return } if (null === c[0]) c[0] = b; else return } c[0].pointerId ===
                    b.pointerId && (c = uj(a, b, b, null !== c[1]), a.doMouseMove(), vj(a, c, b))
                }
            }; a.pm = function (b) {
                if (a.isEnabled) {
                a.Se = !0; var c = "touch" === b.pointerType || "pen" === b.pointerType, d = a.su; if (c && a.Ql) delete d[b.pointerId], b.preventDefault(); else if (d = a.zl, null !== d[0] && d[0].pointerId === b.pointerId) {
                d[0] = null; d = tj(a, b, !1, !0, !0, !1); var e = qa.document.elementFromPoint(b.clientX, b.clientY); null !== e && e.D instanceof P && e.D !== a && qj(e.D, b, d); qj(a, b, d); d.clickCount = a.Hd; null === e ? d.targetDiagram = rj(b) : e.D ? d.targetDiagram = e.D : d.targetDiagram =
                    null; d.targetObject = null; a.doMouseUp(); vj(a, d, b); c && (a.Te = !1)
                } else null !== d[1] && d[1].pointerId === b.pointerId && (d[1] = null)
                }
            }; a.om = function (b) { if (a.isEnabled) { a.Se = !1; var c = a.su; c[b.pointerId] && delete c[b.pointerId]; c = a.zl; null !== c[0] && c[0].pointerId === b.pointerId && (c[0] = null); null !== c[1] && c[1].pointerId === b.pointerId && (c[1] = null); "touch" !== b.pointerType && "pen" !== b.pointerType && (b = a.currentTool, b.cancelWaitAfter(), b.standardMouseOver()) } }; b.Uc(!0); Wi(a)
        }
    } Oi.className = "DiagramHelper";
    function bg(a) { this.l = void 0 === a ? new J : a; this.w = new J } na.Object.defineProperties(bg.prototype, { point: { configurable: !0, get: function () { return this.l }, set: function (a) { this.l = a } }, shifted: { configurable: !0, get: function () { return this.w }, set: function (a) { this.w = a } } }); bg.className = "DraggingInfo"; function bk(a, b, c) { this.node = a; this.info = b; this.mv = c } bk.className = "DraggingNodeInfoPair"; function Lf() { this.reset() }
    Lf.prototype.reset = function () { this.isGridSnapEnabled = !1; this.isGridSnapRealtime = !0; this.gridSnapCellSize = (new Zb(NaN, NaN)).freeze(); this.gridSnapCellSpot = fd; this.gridSnapOrigin = (new J(NaN, NaN)).freeze(); this.uz = this.dragsTree = this.dragsLink = !1 }; function Rk(a) { 1 < arguments.length && v("Palette constructor can only take one optional argument, the DIV HTML element or its id."); P.call(this, a); this.allowDragOut = !0; this.allowMove = !1; this.isReadOnly = !0; this.contentAlignment = gd; this.layout = new Sk } ma(Rk, P);
    Rk.className = "Palette";
    function Tk(a) {
    1 < arguments.length && v("Overview constructor can only take one optional argument, the DIV HTML element or its id."); P.call(this, a); this.animationManager.isEnabled = !1; this.pb = !0; this.$f = null; this.qr = !0; this.Nx("drawShadows", !1); var b = new R, c = new Hg; c.stroke = "magenta"; c.strokeWidth = 2; c.fill = "transparent"; c.name = "BOXSHAPE"; b.selectable = !0; b.selectionAdorned = !1; b.selectionObjectName = "BOXSHAPE"; b.locationObjectName = "BOXSHAPE"; b.resizeObjectName = "BOXSHAPE"; b.cursor = "move"; b.add(c); this.l =
        b; this.allowDelete = this.allowCopy = !1; this.allowSelect = !0; this.autoScrollRegion = new Hc(0, 0, 0, 0); this.Du = new Jk(null); this.hy = this.Du.context; If(this.toolManager, "Dragging", new Uk, this.toolManager.mouseMoveTools); var d = this; this.click = function () { var a = d.$f; if (null !== a) { var b = a.viewportBounds, c = d.lastInput.documentPoint; a.position = new J(c.x - b.width / 2, c.y - b.height / 2) } }; this.Km = function () { d.Ya(); Vk(d) }; this.Im = function () { null !== d.$f && (d.Ya(), d.S()) }; this.Jm = function () { d.S() }; this.Hm = function () {
        null !==
            d.$f && Vk(d)
        }; this.autoScale = kj; this.pb = !1
    } ma(Tk, P);
    function Wk(a) {
    a.pb || a.$b || !1 !== a.sd || (a.sd = !0, qa.requestAnimationFrame(function () {
        if (a.sd && !a.$b && (a.sd = !1, null !== a.Ja)) {
        a.$b = !0; ej(a); a.documentBounds.o() || jj(a, a.computeBounds()); null === a.Ja && v("No div specified"); null === a.Ea && v("No canvas specified"); vi(a.box); if (a.oc) {
            var b = a.$f; if (null !== b && !b.animationManager.isAnimating && !b.animationManager.sb) {
                b = a.$c; var c = a.Du; b.setTransform(1, 0, 0, 1, 0, 0); b.clearRect(0, 0, a.Ea.width, a.Ea.height); b.drawImage(c.Ha, 0, 0); c = a.ub; c.reset(); 1 !== a.scale && c.scale(a.scale);
                0 === a.position.x && 0 === a.position.y || c.translate(-a.position.x, -a.position.y); b.scale(a.Pb, a.Pb); b.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy); c = a.Ra.j; for (var d = c.length, e = 0; e < d; e++)c[e].jc(b, a); a.di = !1; a.oc = !1
            }
        } a.$b = !1
        }
    }))
    } Tk.prototype.computePixelRatio = function () { return 1 };
    Tk.prototype.jc = function () {
    null === this.Ja && v("No div specified"); null === this.Ea && v("No canvas specified"); if (!(this.Ea instanceof Nj) && (vi(this.box), this.oc)) {
        var a = this.$f; if (null !== a && !a.animationManager.isAnimating) {
            Gj(this); var b = a.grid; null === b || !b.visible || isNaN(b.width) || isNaN(b.height) || (b = L.alloc().assign(this.viewportBounds).Lc(a.viewportBounds), zj(a, b), L.free(b), ej(a)); var c = this.Ea; b = this.$c; var d = this.Du, e = this.hy; d.width = c.width; d.height = c.height; b.Uc(!0); b.setTransform(1, 0, 0, 1, 0, 0);
            b.clearRect(0, 0, c.width, c.height); var f = this.ub; f.reset(); 1 !== this.scale && f.scale(this.scale); 0 === this.position.x && 0 === this.position.y || f.translate(-this.position.x, -this.position.y); b.scale(this.Pb, this.Pb); b.transform(f.m11, f.m12, f.m21, f.m22, f.dx, f.dy); var g = this.qr, h = this.viewportBounds; a = a.Ra.j; for (var k = a.length, l = 0; l < k; l++) {
                var m = a[l], n = g; if (m.visible && 0 !== m.mb && (void 0 === n && (n = !0), n || !m.isTemporary)) {
                1 !== m.mb && (b.globalAlpha = m.mb); n = this.scale; m = m.Ga.j; for (var p = m.length, q = 0; q < p; q++) {
                    var r =
                        m[q], u = r.actualBounds; u.Kc(h) && (u.width * n > this.qe || u.height * n > this.qe ? r.jc(b, this) : xi(b, r))
                } b.globalAlpha = 1
                }
            } e.drawImage(c.Ha, 0, 0); E && E.Fi && (e.fillStyle = "red", e.fillRect(0, d.height / 2, d.width, 4)); c = this.Ra.j; d = c.length; for (e = 0; e < d; e++)c[e].jc(b, this); E && (E.$u || E.Fi) && E.Yp && E.Yp(b, this, f); this.oc = this.di = !1
        }
    }
    };
    function Vk(a) { var b = a.box; if (null !== b) { var c = a.$f; if (null !== c) { a.oc = !0; c = c.viewportBounds; var d = b.selectionObject, e = Zb.alloc(); e.h(c.width, c.height); d.desiredSize = e; Zb.free(e); a = 2 / a.scale; d instanceof Hg && (d.strokeWidth = a); b.location = new J(c.x - a / 2, c.y - a / 2); b.isSelected = !0 } } } Tk.prototype.computeBounds = function () { var a = this.$f; if (null === a) return Tc; var b = a.documentBounds.copy(); b.Lc(a.viewportBounds); return b }; Tk.prototype.ux = function () { !0 !== this.oc && (this.oc = !0, Wk(this)) };
    Tk.prototype.sq = function (a, b, c, d) { this.pb || (dj(this), this.S(), wj(this), this.Ya(), Vk(this), this.Ae.scale = c, this.Ae.position.x = a.x, this.Ae.position.y = a.y, this.Ae.bounds.assign(a), this.Ae.wx = d, this.ba("ViewportBoundsChanged", this.Ae, a)) };
    na.Object.defineProperties(Tk.prototype, {
        observed: {
            configurable: !0, get: function () { return this.$f }, set: function (a) {
                var b = this.$f; null !== a && w(a, P, Tk, "observed"); a instanceof Tk && v("Overview.observed Diagram may not be an Overview itself: " + a); b !== a && (null !== b && (this.remove(this.box), b.rm("ViewportBoundsChanged", this.Km), b.rm("DocumentBoundsChanged", this.Im), b.rm("InvalidateDraw", this.Jm), b.rm("AnimationFinished", this.Hm)), this.$f = a, null !== a && (a.Rj("ViewportBoundsChanged", this.Km), a.Rj("DocumentBoundsChanged",
                    this.Im), a.Rj("InvalidateDraw", this.Jm), a.Rj("AnimationFinished", this.Hm), this.add(this.box), Vk(this)), this.Ya(), this.g("observed", b, a))
            }
        }, box: { configurable: !0, get: function () { return this.l }, set: function (a) { var b = this.l; b !== a && (this.l = a, this.remove(b), this.add(this.l), Vk(this), this.g("box", b, a)) } }, drawsTemporaryLayers: { configurable: !0, get: function () { return this.qr }, set: function (a) { this.qr !== a && (this.qr = a, this.vf()) } }
    }); Tk.className = "Overview";
    function Uk() { Kf.call(this); this.l = null } ma(Uk, Kf);
    Uk.prototype.canStart = function () { if (!this.isEnabled) return !1; var a = this.diagram; if (null === a || !a.allowMove || !a.allowSelect) return !1; var b = a.observed; if (null === b) return !1; var c = a.lastInput; if (!c.left || a.currentTool !== this && (!this.isBeyondDragSize() || c.isTouchEvent && c.timestamp - a.firstInput.timestamp < this.delay)) return !1; null === this.findDraggablePart() && (c = b.viewportBounds, this.l = new J(c.width / 2, c.height / 2), a = a.firstInput.documentPoint, b.position = new J(a.x - this.l.x, a.y - this.l.y)); return !0 };
    Uk.prototype.doActivate = function () { this.l = null; Kf.prototype.doActivate.call(this) }; Uk.prototype.moveParts = function () { var a = this.diagram, b = a.observed; if (null !== b) { var c = a.box; if (null !== c) { if (null === this.l) { var d = a.firstInput.documentPoint; c = c.location; this.l = new J(d.x - c.x, d.y - c.y) } a = a.lastInput.documentPoint; b.position = new J(a.x - this.l.x, a.y - this.l.y) } } }; Uk.className = "OverviewDraggingTool";
    function Xk() { 0 < arguments.length && Da(Xk); qb(this); this.D = yf; this.Wb = this.L = this.w = !0; this.ca = this.Ma = this.Xb = this.Na = !1; this.li = this.l = null; this.Oc = 1.05; this.ju = NaN; this.Fw = null; this.Ju = NaN; this.Iu = Tc; this.fg = null; this.Nc = 200 } Xk.prototype.toString = function () { return "CommandHandler" }; Xk.prototype.ib = function (a) { this.D = a };
    Xk.prototype.doKeyDown = function () {
        var a = this.diagram, b = a.lastInput, c = kb ? b.meta : b.control, d = b.shift, e = b.alt, f = b.key; !c || "C" !== f && "Insert" !== f ? c && "X" === f || d && "Del" === f ? this.canCutSelection() && this.cutSelection() : c && "V" === f || d && "Insert" === f ? this.canPasteSelection() && this.pasteSelection() : c && "Y" === f || e && d && "Backspace" === f ? this.canRedo() && this.redo() : c && "Z" === f || e && "Backspace" === f ? this.canUndo() && this.undo() : "Del" === f || "Backspace" === f ? this.canDeleteSelection() && this.deleteSelection() : c && "A" === f ? this.canSelectAll() &&
            this.selectAll() : "Esc" === f ? this.canStopCommand() && this.stopCommand() : "Up" === f ? a.allowVerticalScroll && (c ? a.scroll("pixel", "up") : a.scroll("line", "up")) : "Down" === f ? a.allowVerticalScroll && (c ? a.scroll("pixel", "down") : a.scroll("line", "down")) : "Left" === f ? a.allowHorizontalScroll && (c ? a.scroll("pixel", "left") : a.scroll("line", "left")) : "Right" === f ? a.allowHorizontalScroll && (c ? a.scroll("pixel", "right") : a.scroll("line", "right")) : "PageUp" === f ? d && a.allowHorizontalScroll ? a.scroll("page", "left") : a.allowVerticalScroll &&
                a.scroll("page", "up") : "PageDown" === f ? d && a.allowHorizontalScroll ? a.scroll("page", "right") : a.allowVerticalScroll && a.scroll("page", "down") : "Home" === f ? c && a.allowVerticalScroll ? a.scroll("document", "up") : !c && a.allowHorizontalScroll && a.scroll("document", "left") : "End" === f ? c && a.allowVerticalScroll ? a.scroll("document", "down") : !c && a.allowHorizontalScroll && a.scroll("document", "right") : " " === f ? this.canScrollToPart() && this.scrollToPart() : "Subtract" === f ? this.canDecreaseZoom() && this.decreaseZoom() : "Add" === f ? this.canIncreaseZoom() &&
                    this.increaseZoom() : c && "0" === f ? this.canResetZoom() && this.resetZoom() : d && "Z" === f ? this.canZoomToFit() && this.zoomToFit() : c && !d && "G" === f ? this.canGroupSelection() && this.groupSelection() : c && d && "G" === f ? this.canUngroupSelection() && this.ungroupSelection() : b.event && 113 === b.event.which ? this.canEditTextBlock() && this.editTextBlock() : b.event && 93 === b.event.which ? this.canShowContextMenu() && this.showContextMenu() : b.bubbles = !0 : this.canCopySelection() && this.copySelection()
    };
    Xk.prototype.doKeyUp = function () { this.diagram.lastInput.bubbles = !0 }; Xk.prototype.stopCommand = function () { var a = this.diagram, b = a.currentTool; b instanceof $a && a.allowSelect && a.Vp(); null !== b && b.doCancel() }; Xk.prototype.canStopCommand = function () { return !0 };
    Xk.prototype.selectAll = function () { var a = this.diagram; a.S(); try { a.currentCursor = "wait"; a.ba("ChangingSelection", a.selection); for (var b = a.parts; b.next();)b.value.isSelected = !0; for (var c = a.nodes; c.next();)c.value.isSelected = !0; for (var d = a.links; d.next();)d.value.isSelected = !0 } finally { a.ba("ChangedSelection", a.selection), a.currentCursor = "" } }; Xk.prototype.canSelectAll = function () { return this.diagram.allowSelect };
    Xk.prototype.deleteSelection = function () {
        var a = this.diagram; try { a.currentCursor = "wait"; a.Ca("Delete"); a.ba("ChangingSelection", a.selection); a.ba("SelectionDeleting", a.selection); for (var b = new I, c = a.selection.iterator; c.next();)Yk(b, c.value, !0, this.deletesTree ? Infinity : 0, this.deletesConnectedLinks ? null : !1, function (a) { return a.canDelete() }); E && !0 === E.animationExperiments && a.animationManager.Ch("Remove", { duration: 300, Py: fi }); a.wt(b, !0); a.ba("SelectionDeleted", b) } finally {
            a.ba("ChangedSelection", a.selection),
            a.ab("Delete"), a.currentCursor = ""
        }
    }; Xk.prototype.canDeleteSelection = function () { var a = this.diagram; return a.isReadOnly || a.isModelReadOnly || !a.allowDelete || 0 === a.selection.count ? !1 : !0 }; Xk.prototype.copySelection = function () { var a = this.diagram, b = new I; for (a = a.selection.iterator; a.next();)Yk(b, a.value, !0, this.copiesTree ? Infinity : 0, this.copiesConnectedLinks, function (a) { return a.canCopy() }); this.copyToClipboard(b) };
    Xk.prototype.canCopySelection = function () { var a = this.diagram; return a.allowCopy && a.allowClipboard && 0 !== a.selection.count ? !0 : !1 }; Xk.prototype.cutSelection = function () { this.copySelection(); this.deleteSelection() }; Xk.prototype.canCutSelection = function () { var a = this.diagram; return !a.isReadOnly && !a.isModelReadOnly && a.allowCopy && a.allowDelete && a.allowClipboard && 0 !== a.selection.count ? !0 : !1 };
    Xk.prototype.copyToClipboard = function (a) { var b = this.diagram, c = null; if (null === a) Qi = null, Ri = ""; else { c = b.model; var d = !1, e = !1, f = null; try { c.jm() && (d = c.$j, c.$j = this.copiesParentKey), c.hk() && (e = c.Zj, c.Zj = this.copiesGroupKey), f = b.ak(a, null, !0) } finally { c.jm() && (c.$j = d), c.hk() && (c.Zj = e), c = new F, c.addAll(f), Qi = c, Ri = b.model.dataFormat } } b.ba("ClipboardChanged", c) };
    Xk.prototype.pasteFromClipboard = function () { var a = new I, b = Qi; if (null === b) return a; var c = this.diagram; if (Ri !== c.model.dataFormat) return a; var d = c.model, e = !1, f = !1, g = null; try { d.jm() && (e = d.$j, d.$j = this.copiesParentKey), d.hk() && (f = d.Zj, d.Zj = this.copiesGroupKey), g = c.ak(b, c, !1) } finally { for (d.jm() && (d.$j = e), d.hk() && (d.Zj = f), b = g.iterator; b.next();)c = b.value, d = b.key, c.location.o() || (d.location.o() ? c.location = d.location : !c.position.o() && d.position.o() && (c.position = d.position)), a.add(c) } return a };
    Xk.prototype.pasteSelection = function (a) {
    void 0 === a && (a = null); var b = this.diagram; try { b.currentCursor = "wait"; b.Ca("Paste"); b.ba("ChangingSelection", b.selection); var c = this.pasteFromClipboard(); 0 < c.count && Mf(b); for (var d = c.iterator; d.next();)d.value.isSelected = !0; b.ba("ChangedSelection", b.selection); if (null !== a) { var e = b.computePartsBounds(b.selection); if (e.o()) { var f = this.computeEffectiveCollection(b.selection, b.Pk); pg(b, f, new J(a.x - e.centerX, a.y - e.centerY), b.Pk, !1) } } b.ba("ClipboardPasted", c) } finally {
        b.ab("Paste"),
        b.currentCursor = ""
    }
    }; Xk.prototype.canPasteSelection = function () { var a = this.diagram; return a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowClipboard || null === Qi || 0 === Qi.count || Ri !== a.model.dataFormat ? !1 : !0 }; Xk.prototype.undo = function () { this.diagram.undoManager.undo() }; Xk.prototype.canUndo = function () { var a = this.diagram; return a.isReadOnly || a.isModelReadOnly ? !1 : a.allowUndo && a.undoManager.canUndo() }; Xk.prototype.redo = function () { this.diagram.undoManager.redo() };
    Xk.prototype.canRedo = function () { var a = this.diagram; return a.isReadOnly || a.isModelReadOnly ? !1 : a.allowUndo && a.undoManager.canRedo() }; Xk.prototype.decreaseZoom = function (a) { void 0 === a && (a = 1 / this.zoomFactor); B(a, Xk, "decreaseZoom:factor"); var b = this.diagram; b.autoScale === Ei && (a = b.scale * a, a < b.minScale || a > b.maxScale || (b.scale = a)) };
    Xk.prototype.canDecreaseZoom = function (a) { void 0 === a && (a = 1 / this.zoomFactor); B(a, Xk, "canDecreaseZoom:factor"); var b = this.diagram; if (b.autoScale !== Ei) return !1; a = b.scale * a; return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom }; Xk.prototype.increaseZoom = function (a) { void 0 === a && (a = this.zoomFactor); B(a, Xk, "increaseZoom:factor"); var b = this.diagram; b.autoScale === Ei && (a = b.scale * a, a < b.minScale || a > b.maxScale || (b.scale = a)) };
    Xk.prototype.canIncreaseZoom = function (a) { void 0 === a && (a = this.zoomFactor); B(a, Xk, "canIncreaseZoom:factor"); var b = this.diagram; if (b.autoScale !== Ei) return !1; a = b.scale * a; return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom }; Xk.prototype.resetZoom = function (a) { void 0 === a && (a = this.defaultScale); B(a, Xk, "resetZoom:newscale"); var b = this.diagram; a < b.minScale || a > b.maxScale || (b.scale = a) };
    Xk.prototype.canResetZoom = function (a) { void 0 === a && (a = this.defaultScale); B(a, Xk, "canResetZoom:newscale"); var b = this.diagram; return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom }; Xk.prototype.zoomToFit = function () { var a = this.diagram, b = a.scale, c = a.position; b === this.Ju && !isNaN(this.ju) && a.documentBounds.A(this.Iu) ? (a.scale = this.ju, a.position = this.Fw, this.Ju = NaN, this.Iu = Tc) : (this.ju = b, this.Fw = c.copy(), a.zoomToFit(), this.Ju = a.scale, this.Iu = a.documentBounds.copy()) }; Xk.prototype.canZoomToFit = function () { return this.diagram.allowZoom };
    Xk.prototype.scrollToPart = function (a) {
    void 0 === a && (a = null); null !== a && w(a, R, Xk, "part"); var b = this.diagram; if (null === a) { try { null !== this.fg && (this.fg.next() ? a = this.fg.value : this.fg = null) } catch (k) { this.fg = null } null === a && (0 < b.highlighteds.count ? this.fg = b.highlighteds.iterator : 0 < b.selection.count && (this.fg = b.selection.iterator), null !== this.fg && this.fg.next() && (a = this.fg.value)) } if (null !== a) {
        var c = b.animationManager; c.Ch("Scroll To Part"); var d = this.scrollToPartPause; if (0 < d) {
            var e = Zk(this, a, [a]), f = function () {
                b.Ca();
                for (var a = e.pop(); 0 < e.length && a instanceof V && a.isTreeExpanded && (!(a instanceof xg) || a.isSubGraphExpanded);)a = e.pop(); 0 < e.length ? (a instanceof R && b.Mv(a.actualBounds), a instanceof V && !a.isTreeExpanded && (a.isTreeExpanded = !0), a instanceof xg && !a.isSubGraphExpanded && (a.isSubGraphExpanded = !0)) : (a instanceof R && b.Ou(a.actualBounds), b.rm("LayoutCompleted", g)); b.ab("Scroll To Part")
            }, g = function () { wa(f, (c.isEnabled ? c.duration : 0) + d) }; b.Rj("LayoutCompleted", g); f()
        } else {
            var h = b.position.copy(); b.Ou(a.actualBounds);
            h.Sa(b.position) && c.xd()
        }
    }
    }; function Zk(a, b, c) { if (b.isVisible()) return c; if (b instanceof Cf) Zk(a, b.adornedPart, c); else if (b instanceof Q) { var d = b.fromNode; null !== d && Zk(a, d, c); b = b.toNode; null !== b && Zk(a, b, c) } else b instanceof V && (d = b.labeledLink, null !== d && Zk(a, d, c), d = b.rg(), null !== d && (d.isTreeExpanded || d.wasTreeExpanded || c.push(d), Zk(a, d, c))), b = b.containingGroup, null !== b && (b.isSubGraphExpanded || b.wasSubGraphExpanded || c.push(b), Zk(a, b, c)); return c }
    Xk.prototype.canScrollToPart = function (a) { void 0 === a && (a = null); if (null !== a && !(a instanceof R)) return !1; a = this.diagram; return 0 === a.selection.count && 0 === a.highlighteds.count ? !1 : a.allowHorizontalScroll && a.allowVerticalScroll };
    Xk.prototype.collapseTree = function (a) { void 0 === a && (a = null); var b = this.diagram; try { b.Ca("Collapse Tree"); b.animationManager.Ch("Collapse Tree"); var c = new F; if (null !== a && a.isTreeExpanded) a.collapseTree(), c.add(a); else if (null === a) for (var d = b.selection.iterator; d.next();) { var e = d.value; e instanceof V && e.isTreeExpanded && (e.collapseTree(), c.add(e)) } b.ba("TreeCollapsed", c) } finally { b.ab("Collapse Tree") } };
    Xk.prototype.canCollapseTree = function (a) { void 0 === a && (a = null); var b = this.diagram; if (b.isReadOnly) return !1; if (null !== a) { if (!(a instanceof V && a.isTreeExpanded)) return !1; if (0 < a.cq().count) return !0 } else for (a = b.selection.iterator; a.next();)if (b = a.value, b instanceof V && b.isTreeExpanded && 0 < b.cq().count) return !0; return !1 };
    Xk.prototype.expandTree = function (a) { void 0 === a && (a = null); var b = this.diagram; try { b.Ca("Expand Tree"); b.animationManager.Ch("Expand Tree"); var c = new F; if (null !== a && !a.isTreeExpanded) a.expandTree(), c.add(a); else if (null === a) for (var d = b.selection.iterator; d.next();) { var e = d.value; e instanceof V && !e.isTreeExpanded && (e.expandTree(), c.add(e)) } b.ba("TreeExpanded", c) } finally { b.ab("Expand Tree") } };
    Xk.prototype.canExpandTree = function (a) { void 0 === a && (a = null); var b = this.diagram; if (b.isReadOnly) return !1; if (null !== a) { if (!(a instanceof V) || a.isTreeExpanded) return !1; if (0 < a.cq().count) return !0 } else for (a = b.selection.iterator; a.next();)if (b = a.value, b instanceof V && !b.isTreeExpanded && 0 < b.cq().count) return !0; return !1 };
    Xk.prototype.groupSelection = function () {
        var a = this.diagram, b = a.model; if (b.Si()) {
            var c = this.archetypeGroupData; if (null !== c) {
                var d = null; try {
                a.currentCursor = "wait"; a.Ca("Group"); a.ba("ChangingSelection", a.selection); for (var e = new F, f = a.selection.iterator; f.next();) { var g = f.value; g.dc() && g.canGroup() && e.add(g) } for (var h = new F, k = e.iterator; k.next();) { var l = k.value; f = !1; for (var m = e.iterator; m.next();)if (l.Xd(m.value)) { f = !0; break } f || h.add(l) } if (0 < h.count) {
                    var n = h.first().containingGroup; if (null !== n) for (; null !==
                        n;) { e = !1; for (var p = h.iterator; p.next();)if (!p.value.Xd(n)) { e = !0; break } if (e) n = n.containingGroup; else break } if (c instanceof xg) mh(c), d = c.copy(), null !== d && a.add(d); else if (b.ht(c)) { var q = b.copyNodeData(c); Ia(q) && (b.lf(q), d = a.Ii(q)) } if (null !== d) { null !== n && this.isValidMember(n, d) && (d.containingGroup = n); for (var r = h.iterator; r.next();) { var u = r.value; this.isValidMember(d, u) && (u.containingGroup = d) } a.select(d) }
                } a.ba("ChangedSelection", a.selection); a.ba("SelectionGrouped", d)
                } finally {
                    a.ab("Group"), a.currentCursor =
                        ""
                    }
            }
        }
    }; Xk.prototype.canGroupSelection = function () { var a = this.diagram; if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowGroup || !a.model.Si() || null === this.archetypeGroupData) return !1; for (a = a.selection.iterator; a.next();) { var b = a.value; if (b.dc() && b.canGroup()) return !0 } return !1 };
    function $k(a) { var b = Qa(); for (a = a.iterator; a.next();) { var c = a.value; c instanceof Q || b.push(c) } a = new I; c = b.length; for (var d = 0; d < c; d++) { for (var e = b[d], f = !0, g = 0; g < c; g++)if (e.Xd(b[g])) { f = !1; break } f && a.add(e) } Ta(b); return a }
    Xk.prototype.isValidMember = function (a, b) { if (null === b || a === b || b instanceof Q) return !1; if (null !== a) { if (a === b || a.Xd(b)) return !1; var c = a.memberValidation; if (null !== c && !c(a, b) || null === a.data && null !== b.data || null !== a.data && null === b.data) return !1 } c = this.memberValidation; return null !== c ? c(a, b) : !0 };
    Xk.prototype.ungroupSelection = function (a) {
    void 0 === a && (a = null); var b = this.diagram, c = b.model; if (c.Si()) try {
    b.currentCursor = "wait"; b.Ca("Ungroup"); b.ba("ChangingSelection", b.selection); var d = new F; if (null !== a) d.add(a); else for (var e = b.selection.iterator; e.next();) { var f = e.value; f instanceof xg && f.canUngroup() && d.add(f) } var g = new F; if (0 < d.count) {
        b.Vp(); for (var h = d.iterator; h.next();) {
            var k = h.value; k.expandSubGraph(); var l = k.containingGroup, m = null !== l && null !== l.data ? c.ra(l.data) : void 0; g.addAll(k.memberParts);
            for (var n = g.iterator; n.next();) { var p = n.value; p.isSelected = !0; if (!(p instanceof Q)) { var q = p.data; null !== q ? c.zt(q, m) : p.containingGroup = l } } b.remove(k)
        }
    } b.ba("ChangedSelection", b.selection); b.ba("SelectionUngrouped", d, g)
    } finally { b.ab("Ungroup"), b.currentCursor = "" }
    };
    Xk.prototype.canUngroupSelection = function (a) { void 0 === a && (a = null); var b = this.diagram; if (b.isReadOnly || b.isModelReadOnly || !b.allowDelete || !b.allowUngroup || !b.model.Si()) return !1; if (null !== a) { if (!(a instanceof xg)) return !1; if (a.canUngroup()) return !0 } else for (a = b.selection.iterator; a.next();)if (b = a.value, b instanceof xg && b.canUngroup()) return !0; return !1 };
    Xk.prototype.addTopLevelParts = function (a, b) { var c = !0; for (a = $k(a).iterator; a.next();) { var d = a.value; null !== d.containingGroup && (!b || this.isValidMember(null, d) ? d.containingGroup = null : c = !1) } return c };
    Xk.prototype.collapseSubGraph = function (a) { void 0 === a && (a = null); var b = this.diagram; try { b.Ca("Collapse SubGraph"); b.animationManager.Ch("Collapse SubGraph"); var c = new F; if (null !== a && a.isSubGraphExpanded) a.collapseSubGraph(), c.add(a); else if (null === a) for (var d = b.selection.iterator; d.next();) { var e = d.value; e instanceof xg && e.isSubGraphExpanded && (e.collapseSubGraph(), c.add(e)) } b.ba("SubGraphCollapsed", c) } finally { b.ab("Collapse SubGraph") } };
    Xk.prototype.canCollapseSubGraph = function (a) { void 0 === a && (a = null); var b = this.diagram; if (b.isReadOnly) return !1; if (null !== a) return a instanceof xg && a.isSubGraphExpanded ? !0 : !1; for (a = b.selection.iterator; a.next();)if (b = a.value, b instanceof xg && b.isSubGraphExpanded) return !0; return !1 };
    Xk.prototype.expandSubGraph = function (a) { void 0 === a && (a = null); var b = this.diagram; try { b.Ca("Expand SubGraph"); b.animationManager.Ch("Expand SubGraph"); var c = new F; if (null !== a && !a.isSubGraphExpanded) a.expandSubGraph(), c.add(a); else if (null === a) for (var d = b.selection.iterator; d.next();) { var e = d.value; e instanceof xg && !e.isSubGraphExpanded && (e.expandSubGraph(), c.add(e)) } b.ba("SubGraphExpanded", c) } finally { b.ab("Expand SubGraph") } };
    Xk.prototype.canExpandSubGraph = function (a) { void 0 === a && (a = null); var b = this.diagram; if (b.isReadOnly) return !1; if (null !== a) return a instanceof xg && !a.isSubGraphExpanded ? !0 : !1; for (a = b.selection.iterator; a.next();)if (b = a.value, b instanceof xg && !b.isSubGraphExpanded) return !0; return !1 };
    Xk.prototype.editTextBlock = function (a) { void 0 === a && (a = null); null !== a && w(a, Kh, Xk, "editTextBlock"); var b = this.diagram, c = b.toolManager.findTool("TextEditing"); if (null !== c) { if (null === a) { a = null; for (var d = b.selection.iterator; d.next();) { var e = d.value; if (e.canEdit()) { a = e; break } } if (null === a) return; a = a.bm(function (a) { return a instanceof Kh && a.editable }) } null !== a && (b.currentTool = null, c.textBlock = a, b.currentTool = c) } };
    Xk.prototype.canEditTextBlock = function (a) { void 0 === a && (a = null); var b = this.diagram; if (b.isReadOnly || b.isModelReadOnly || !b.allowTextEdit || null === b.toolManager.findTool("TextEditing")) return !1; if (null !== a) { if (!(a instanceof Kh)) return !1; a = a.part; if (null !== a && a.canEdit()) return !0 } else for (b = b.selection.iterator; b.next();)if (a = b.value, a.canEdit() && (a = a.bm(function (a) { return a instanceof Kh && a.editable }), null !== a)) return !0; return !1 };
    Xk.prototype.showContextMenu = function (a) { var b = this.diagram, c = b.toolManager.findTool("ContextMenu"); if (null !== c && (void 0 === a && (a = 0 < b.selection.count ? b.selection.first() : b), a = c.findObjectWithContextMenu(a), null !== a)) { var d = b.lastInput, e = null; a instanceof N ? e = a.oa(qd) : b.isMouseOverDiagram || (e = b.viewportBounds, e = new J(e.x + e.width / 2, e.y + e.height / 2)); null !== e && (d.viewPoint = b.Ct(e), d.documentPoint = e, d.left = !1, d.right = !0, d.up = !0); b.currentTool = c; Gh(c, !1, a) } };
    Xk.prototype.canShowContextMenu = function (a) { var b = this.diagram, c = b.toolManager.findTool("ContextMenu"); if (null === c) return !1; void 0 === a && (a = 0 < b.selection.count ? b.selection.first() : b); return null === c.findObjectWithContextMenu(a) ? !1 : !0 };
    Xk.prototype.computeEffectiveCollection = function (a, b) { var c = this.diagram, d = c.toolManager.findTool("Dragging"), e = c.currentTool === d; void 0 === b && (b = e ? d.dragOptions : c.Pk); d = new Ub; if (null === a) return d; for (var f = a.iterator; f.next();)Zj(c, d, f.value, e, b); if (null !== c.draggedLink && b.dragsLink) return d; for (f = a.iterator; f.next();)a = f.value, a instanceof Q && (b = a.fromNode, null === b || d.contains(b) ? (b = a.toNode, null === b || d.contains(b) || d.remove(a)) : d.remove(a)); return d };
    na.Object.defineProperties(Xk.prototype, {
        diagram: { configurable: !0, get: function () { return this.D } }, copiesClipboardData: { configurable: !0, get: function () { return this.w }, set: function (a) { z(a, "boolean", Xk, "copiesClipboardData"); this.w = a } }, copiesConnectedLinks: { configurable: !0, get: function () { return this.L }, set: function (a) { z(a, "boolean", Xk, "copiesConnectedLinks"); this.L = a } }, deletesConnectedLinks: {
            configurable: !0, get: function () { return this.Wb }, set: function (a) {
                z(a,
                    "boolean", Xk, "deletesConnectedLinks"); this.Wb = a
            }
        }, copiesTree: { configurable: !0, get: function () { return this.Na }, set: function (a) { z(a, "boolean", Xk, "copiesTree"); this.Na = a } }, deletesTree: { configurable: !0, get: function () { return this.Xb }, set: function (a) { z(a, "boolean", Xk, "deletesTree"); this.Xb = a } }, copiesParentKey: { configurable: !0, get: function () { return this.Ma }, set: function (a) { z(a, "boolean", Xk, "copiesParentKey"); this.Ma = a } }, copiesGroupKey: {
            configurable: !0,
            get: function () { return this.ca }, set: function (a) { z(a, "boolean", Xk, "copiesGroupKey"); this.ca = a }
        }, archetypeGroupData: { configurable: !0, get: function () { return this.l }, set: function (a) { null !== a && z(a, "object", Xk, "archetypeGroupData"); var b = this.diagram; E && (b = b.model, !b.Si() || a instanceof xg || b.ht(a) || v("CommandHandler.archetypeGroupData must be either a Group or a data object for which GraphLinksModel.isGroupForNodeData is true: " + a)); this.l = a } }, memberValidation: {
            configurable: !0,
            get: function () { return this.li }, set: function (a) { null !== a && z(a, "function", Xk, "memberValidation"); this.li = a }
        }, defaultScale: { configurable: !0, get: function () { return this.diagram.defaultScale }, set: function (a) { this.diagram.defaultScale = a } }, zoomFactor: { configurable: !0, get: function () { return this.Oc }, set: function (a) { B(a, Xk, "zoomFactor"); 1 < a || v("zoomFactor must be larger than 1.0, not: " + a); this.Oc = a } }, scrollToPartPause: {
            configurable: !0, get: function () { return this.Nc },
            set: function (a) { B(a, Xk, "scrollToPartPause"); this.Nc = a }
        }
    }); Xk.className = "CommandHandler"; Li = function () { return new Xk };
    function N() {
        qb(this); this.I = 4225027; this.mb = 1; this.cg = null; this.Wa = ""; this.fc = this.jb = null; this.ua = (new J(NaN, NaN)).freeze(); this.Qc = xc; this.Sf = rc; this.Rf = wc; this.ub = new $b; this.Fh = new $b; this.Qf = new $b; this.Da = this.Wk = 1; this.Bc = 0; this.ye = al; this.Wg = Zc; this.qc = (new L(NaN, NaN, NaN, NaN)).freeze(); this.wb = (new L(NaN, NaN, NaN, NaN)).freeze(); this.rc = (new L(0, 0, NaN, NaN)).freeze(); this.R = this.Vo = this.Wo = null; this.Bk = this.xb = Qd; this.ip = 0; this.jp = 1; this.Fg = 0; this.cn = 1; this.zp = null; this.np = -Infinity; this.Cl =
            0; this.Dl = gc; this.El = ch; this.nn = ""; this.eb = this.P = null; this.Hk = -1; this.Gl = this.md = this.Uh = this.Jl = null; this.qs = nh; this.Ej = null
    } var oe, nh, ph, al, bl, cl, dl, el, fl, gl;
    N.prototype.cloneProtected = function (a) {
    a.I = this.I | 6144; a.mb = this.mb; a.Wa = this.Wa; a.jb = this.jb; a.fc = this.fc; a.ua.assign(this.ua); a.Qc = this.Qc.J(); a.Sf = this.Sf.J(); a.Rf = this.Rf.J(); a.Qf = this.Qf.copy(); a.Da = this.Da; a.Bc = this.Bc; a.ye = this.ye; a.Wg = this.Wg.J(); a.qc.assign(this.qc); a.wb.assign(this.wb); a.rc.assign(this.rc); a.Vo = this.Vo; null !== this.R && (a.R = this.R.copy()); a.xb = this.xb.J(); a.Bk = this.Bk.J(); a.ip = this.ip; a.jp = this.jp; a.Fg = this.Fg; a.cn = this.cn; a.zp = this.zp; a.np = this.np; a.Cl = this.Cl; a.Dl = this.Dl.J();
        a.El = this.El; a.nn = this.nn; null !== this.P && (a.P = this.P.copy()); a.eb = this.eb; a.Hk = this.Hk; null !== this.Uh && (a.Uh = Ma(this.Uh)); null !== this.md && (a.md = this.md.copy()); a.Gl = this.Gl
    }; N.prototype.Vw = function (a) { var b = this.Uh; if (Ka(b)) for (var c = 0; c < b.length; c++) { if (b[c] === a) return } else this.Uh = b = []; b.push(a) }; N.prototype.qf = function (a) { a.Wo = null; a.Ej = null; a.v() };
    N.prototype.clone = function () { var a = new this.constructor; this.cloneProtected(a); if (null !== this.Uh) for (var b = 0; b < this.Uh.length; b++) { var c = this.Uh[b]; a[c] = this[c] } return a }; N.prototype.copy = function () { return this.clone() }; t = N.prototype; t.hb = function (a) { a.classType === Q ? 0 === a.name.indexOf("Orient") ? this.segmentOrientation = a : v("Unknown Link enum value for GraphObject.segmentOrientation property: " + a) : a.classType === N ? this.stretch = a : Fa(this, a) }; t.toString = function () { return Va(this.constructor) + "#" + Jb(this) };
    function hl(a) { null === a.P && (a.P = new il) } t.Jc = function () { if (null === this.R) { var a = new jl; a.Og = ed; a.nh = ed; a.Mg = 10; a.lh = 10; a.Ng = 0; a.mh = 0; this.R = a } }; t.cb = function (a, b, c, d, e, f, g) { var h = this.part; if (null !== h && (h.sk(a, b, c, d, e, f, g), c === this && a === of && kl(this) && ll(this, h, b), this instanceof W && c === h && 0 !== (h.I & 16777216) && null !== h.data)) for (a = this.Z.j, c = a.length, d = 0; d < c; d++)e = a[d], e instanceof W && Qj(e, function (a) { null !== a.data && 0 !== (a.I & 16777216) && a.Fa(b) }) };
    function ll(a, b, c) { var d = a.Ki(); if (null !== d) for (var e = a.eb.iterator; e.next();) { var f = e.value, g = null; if (null !== f.sourceName) { g = ml(f, d, a); if (null === g) continue; f.Eq(a, g, c, null) } else if (f.isToModel) { var h = b.diagram; null === h || h.skipsModelSourceBindings || f.Eq(a, h.model.modelData, c, d) } else { h = d.data; if (null === h) continue; var k = b.diagram; null === k || k.skipsModelSourceBindings || f.Eq(a, h, c, d) } g === a && (h = d.Vs(f.aj), null !== h && f.dw(h, g, c)) } } t.Vs = function (a) { return this.Hk === a ? this : null };
    t.g = function (a, b, c) { this.cb(of, a, this, b, c) }; function nl(a, b, c, d, e) { var f = a.qc, g = a.Qf; g.reset(); ol(a, g, b, c, d, e); a.Qf = g; f.h(b, c, d, e); g.it() || g.aw(f) } function pl(a, b, c, d) { if (!1 === a.pickable) return !1; d.multiply(a.transform); return c ? a.Kc(b, d) : a.vh(b, d) }
    t.nx = function (a, b, c) { if (!1 === this.pickable) return !1; var d = this.naturalBounds; b = a.Ee(b); return c ? cc(a.x, a.y, 0, 0, 0, d.height) <= b || cc(a.x, a.y, 0, d.height, d.width, d.height) <= b || cc(a.x, a.y, d.width, d.height, d.width, 0) <= b || cc(a.x, a.y, d.width, 0, 0, 0) <= b : a.ed(0, 0) <= b && a.ed(0, d.height) <= b && a.ed(d.width, 0) <= b && a.ed(d.width, d.height) <= b }; t.ae = function () { return !0 };
    t.ea = function (a) {
        E && w(a, J, N, "containsPoint:p"); var b = J.alloc(); b.assign(a); this.transform.va(b); var c = this.actualBounds; if (!c.o()) return J.free(b), !1; var d = this.diagram; if (null !== d && d.Te) { var e = d.fm("extraTouchThreshold"), f = d.fm("extraTouchArea"), g = f / 2, h = this.naturalBounds; d = this.Fe() * d.scale; var k = 1 / d; if (h.width * d < e && h.height * d < e) return a = Qc(c.x - g * k, c.y - g * k, c.width + f * k, c.height + f * k, b.x, b.y), J.free(b), a } e = !1; if (this instanceof Cf || this instanceof Hg ? Qc(c.x - 5, c.y - 5, c.width + 10, c.height + 10, b.x, b.y) :
            c.ea(b)) this.md && !this.md.ea(b) ? e = !1 : null !== this.fc && c.ea(b) ? e = !0 : null !== this.jb && this.rc.ea(a) ? e = !0 : e = this.wh(a); J.free(b); return e
    }; t.wh = function (a) { var b = this.naturalBounds; return Qc(0, 0, b.width, b.height, a.x, a.y) };
    t.pf = function (a) { E && w(a, L, N, "containsRect:r"); if (0 === this.angle) return this.actualBounds.pf(a); var b = this.naturalBounds; b = L.allocAt(0, 0, b.width, b.height); var c = this.transform, d = !1, e = J.allocAt(a.x, a.y); b.ea(c.Wd(e)) && (e.h(a.x, a.bottom), b.ea(c.Wd(e)) && (e.h(a.right, a.bottom), b.ea(c.Wd(e)) && (e.h(a.right, a.y), b.ea(c.Wd(e)) && (d = !0)))); J.free(e); L.free(b); return d };
    t.vh = function (a, b) { E && w(a, L, N, "containedInRect:r"); if (void 0 === b) return a.pf(this.actualBounds); var c = this.naturalBounds, d = !1, e = J.allocAt(0, 0); a.ea(b.va(e)) && (e.h(0, c.height), a.ea(b.va(e)) && (e.h(c.width, c.height), a.ea(b.va(e)) && (e.h(c.width, 0), a.ea(b.va(e)) && (d = !0)))); J.free(e); return d };
    t.Kc = function (a, b) {
        E && w(a, L, N, "intersectsRect:r"); if (void 0 === b && (b = this.transform, 0 === this.angle)) return a.Kc(this.actualBounds); var c = this.naturalBounds, d = J.allocAt(0, 0), e = J.allocAt(0, c.height), f = J.allocAt(c.width, c.height), g = J.allocAt(c.width, 0), h = !1; if (a.ea(b.va(d)) || a.ea(b.va(e)) || a.ea(b.va(f)) || a.ea(b.va(g))) h = !0; else {
            c = L.allocAt(0, 0, c.width, c.height); var k = J.allocAt(a.x, a.y); c.ea(b.Wd(k)) ? h = !0 : (k.h(a.x, a.bottom), c.ea(b.Wd(k)) ? h = !0 : (k.h(a.right, a.bottom), c.ea(b.Wd(k)) ? h = !0 : (k.h(a.right, a.y),
                c.ea(b.Wd(k)) && (h = !0)))); J.free(k); L.free(c); !h && (K.et(a, d, e) || K.et(a, e, f) || K.et(a, f, g) || K.et(a, g, d)) && (h = !0)
        } J.free(d); J.free(e); J.free(f); J.free(g); return h
    }; t.oa = function (a, b) { void 0 === b && (b = new J); if (a instanceof M) { E && a.Nb() && v("getDocumentPoint:s Spot must be specific: " + a.toString()); var c = this.naturalBounds; b.h(a.x * c.width + a.offsetX, a.y * c.height + a.offsetY) } else b.set(a); this.td.va(b); return b };
    t.eq = function (a) { void 0 === a && (a = new L); var b = this.naturalBounds, c = this.td, d = J.allocAt(0, 0).transform(c); a.h(d.x, d.y, 0, 0); d.h(b.width, 0).transform(c); Mc(a, d.x, d.y, 0, 0); d.h(b.width, b.height).transform(c); Mc(a, d.x, d.y, 0, 0); d.h(0, b.height).transform(c); Mc(a, d.x, d.y, 0, 0); J.free(d); return a }; t.Ni = function () { var a = this.td; 1 === a.m11 && 0 === a.m12 ? a = 0 : (a = 180 * Math.atan2(a.m12, a.m11) / Math.PI, 0 > a && (a += 360)); return a };
    t.Fe = function () { if (0 !== (this.I & 4096) === !1) return this.Wk; var a = this.Da; return null !== this.panel ? a * this.panel.Fe() : a }; t.at = function (a, b) { void 0 === b && (b = new J); b.assign(a); this.td.Wd(b); return b }; t.Wc = function (a, b, c) { return this.fk(a.x, a.y, b.x, b.y, c) };
    t.fk = function (a, b, c, d, e) { var f = this.transform, g = 1 / (f.m11 * f.m22 - f.m12 * f.m21), h = f.m22 * g, k = -f.m12 * g, l = -f.m21 * g, m = f.m11 * g, n = g * (f.m21 * f.dy - f.m22 * f.dx), p = g * (f.m12 * f.dx - f.m11 * f.dy); if (null !== this.areaBackground) return f = this.actualBounds, K.Wc(f.left, f.top, f.right, f.bottom, a, b, c, d, e); g = a * h + b * l + n; a = a * k + b * m + p; b = c * h + d * l + n; c = c * k + d * m + p; e.h(0, 0); d = this.naturalBounds; c = K.Wc(0, 0, d.width, d.height, g, a, b, c, e); e.transform(f); return c };
    N.prototype.measure = function (a, b, c, d) {
        if (!1 !== Dj(this)) {
            var e = this.Wg, f = e.right + e.left; e = e.top + e.bottom; a = Math.max(a - f, 0); b = Math.max(b - e, 0); c = Math.max((c || 0) - f, 0); d = Math.max((d || 0) - e, 0); f = this.angle; e = this.desiredSize; var g = 0; this instanceof Hg && (g = this.strokeWidth); 90 === f || 270 === f ? (a = isFinite(e.height) ? e.height + g : a, b = isFinite(e.width) ? e.width + g : b) : (a = isFinite(e.width) ? e.width + g : a, b = isFinite(e.height) ? e.height + g : b); e = c || 0; g = d || 0; var h = this instanceof W; switch (ql(this, !0)) {
                case nh: g = e = 0; h && (b = a = Infinity);
                    break; case oe: isFinite(a) && a > c && (e = a); isFinite(b) && b > d && (g = b); break; case bl: isFinite(a) && a > c && (e = a); g = 0; h && (b = Infinity); break; case cl: isFinite(b) && b > d && (g = b), e = 0, h && (a = Infinity)
            }h = this.maxSize; var k = this.minSize; e > h.width && k.width < h.width && (e = h.width); g > h.height && k.height < h.height && (g = h.height); c = Math.max(e / this.scale, k.width); d = Math.max(g / this.scale, k.height); h.width < c && (c = Math.min(k.width, c)); h.height < d && (d = Math.min(k.height, d)); a = Math.min(h.width, a); b = Math.min(h.height, b); a = Math.max(c, a); b = Math.max(d,
                b); if (90 === f || 270 === f) f = a, a = b, b = f, f = c, c = d, d = f; this.qc.ja(); this.lm(a, b, c, d); this.qc.freeze(); this.qc.o() || v("Non-real measuredBounds has been set. Object " + this + ", measuredBounds: " + this.qc.toString()); yj(this, !1)
        }
    }; N.prototype.lm = function () { }; N.prototype.vg = function () { return !1 };
    N.prototype.arrange = function (a, b, c, d, e) {
        this.jl(); var f = L.alloc(); f.assign(this.wb); this.wb.ja(); !1 === Ej(this) ? this.wb.h(a, b, c, d) : this.uh(a, b, c, d); this.wb.freeze(); void 0 === e ? this.md = null : this.md = e; c = !1; if (void 0 !== e) c = !0; else if (e = this.panel, null === e || e.type !== W.TableRow && e.type !== W.TableColumn || (e = e.panel), null !== e && (e = e.rc, d = this.measuredBounds, null !== this.areaBackground && (d = this.wb), c = b + d.height, d = a + d.width, c = !(0 <= a + .05 && d <= e.width + .05 && 0 <= b + .05 && c <= e.height + .05), this instanceof Kh && (a = this.naturalBounds,
            this.Wr > a.height || this.metrics.maxLineWidth > a.width))) c = !0; this.I = c ? this.I | 256 : this.I & -257; this.wb.o() || v("Non-real actualBounds has been set. Object " + this + ", actualBounds: " + this.wb.toString()); this.qt(f, this.wb); rl(this, !1); L.free(f)
    }; t = N.prototype; t.uh = function () { };
    function sl(a, b, c, d, e) { a.wb.h(b, c, d, e); if (!a.desiredSize.o()) { var f = a.qc; c = a.Wg; b = c.right + c.left; var g = c.top + c.bottom; c = f.width + b; f = f.height + g; d += b; e += g; b = ql(a, !0); c === d && f === e && (b = nh); switch (b) { case nh: if (c > d || f > e) yj(a, !0), a.measure(c > d ? d : c, f > e ? e : f, 0, 0); break; case oe: yj(a, !0); a.measure(d, e, 0, 0); break; case bl: yj(a, !0); a.measure(d, f, 0, 0); break; case cl: yj(a, !0), a.measure(c, e, 0, 0) } } }
    t.qt = function (a, b) { var c = this.part; null !== c && null !== c.diagram && (c.selectionObject !== this && c.resizeObject !== this && c.rotateObject !== this || tl(c, !0), this.S(), Fc(a, b) || (c.zh(), this.Ko(c))) }; t.Ko = function (a) { null !== this.portId && (tl(a, !0), a instanceof V && ul(a, this)) };
    t.jc = function (a, b) {
        if (this.visible) {
            var c = this instanceof W && (this.type === W.TableRow || this.type === W.TableColumn), d = this.wb; if (c || 0 !== d.width && 0 !== d.height && !isNaN(d.x) && !isNaN(d.y)) {
                var e = this.opacity; if (0 !== e) {
                    var f = 1; 1 !== e && (f = a.globalAlpha, a.globalAlpha = f * e); if (!this.kx(a, b)) if (c) vl(this, a, b); else {
                    this instanceof Q && this.kk(!1); E && E.Fi && E.My && E.My(a, this); c = this.transform; var g = this.panel; 0 !== (this.I & 4096) === !0 && wl(this); var h = this.part, k = !1, l = 0; if (h && b.Ge("drawShadows") && (k = h.isShadowed)) {
                        var m =
                            h.vi; l = Math.max(m.y, m.x) * b.scale * b.Pb
                    } if (!(m = b.qj)) {
                        var n = this.naturalBounds; m = this.Fh; var p = m.m11, q = m.m21, r = m.dx, u = m.m12, x = m.m22, y = m.dy, A, C = A = 0; m = A * p + C * q + r; var G = A * u + C * x + y; A = n.width + l; C = 0; var H = A * p + C * q + r; A = A * u + C * x + y; m = Math.min(m, H); G = Math.min(G, A); var O = Math.max(m, H) - m; var S = Math.max(G, A) - G; A = n.width + l; C = n.height + l; H = A * p + C * q + r; A = A * u + C * x + y; m = Math.min(m, H); G = Math.min(G, A); O = Math.max(m + O, H) - m; S = Math.max(G + S, A) - G; A = 0; C = n.height + l; H = A * p + C * q + r; A = A * u + C * x + y; m = Math.min(m, H); G = Math.min(G, A); O = Math.max(m + O,
                            H) - m; S = Math.max(G + S, A) - G; l = b.viewportBounds; n = l.x; p = l.y; m = !(m > l.aa + n || n > O + m || G > l.$ + p || p > S + G)
                    } if (m) {
                        m = 0 !== (this.I & 256); a.clipInsteadOfFill && (m = !1); this instanceof Kh && (a.font = this.font); if (m) {
                        E && E.Oy && Ga("clip" + this.toString()); G = g.ae() ? g.naturalBounds : g.actualBounds; null !== this.md ? (n = this.md, O = n.x, S = n.y, l = n.width, n = n.height) : (O = Math.max(d.x, G.x), S = Math.max(d.y, G.y), l = Math.min(d.right, G.right) - O, n = Math.min(d.bottom, G.bottom) - S); if (O > d.width + d.x || d.x > G.width + G.x) { 1 !== e && (a.globalAlpha = f); return } a.save();
                            a.beginPath(); a.rect(O, S, l, n); a.clip()
                        } if (this.vg()) { if (!h.isVisible()) { 1 !== e && (a.globalAlpha = f); return } k && (G = h.vi, a.Uv(G.x * b.scale * b.Pb, G.y * b.scale * b.Pb, h.Qd), xl(a), a.shadowColor = h.Mj) } !0 === this.shadowVisible ? xl(a) : !1 === this.shadowVisible && yl(a); h = this.naturalBounds; null !== this.fc && (yi(this, a, this.fc, !0, !0, h, d), this.fc instanceof zl && this.fc.type === Al ? (a.beginPath(), a.rect(d.x, d.y, d.width, d.height), a.Vd(this.fc)) : a.fillRect(d.x, d.y, d.width, d.height)); a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy);
                        k && (null !== g && 0 !== (g.I & 512) || null !== g && (g.type === W.Auto || g.type === W.Spot) && g.Bb() !== this) && null === this.shadowVisible && yl(a); null !== this.jb && (l = this.naturalBounds, O = G = 0, S = l.width, l = l.height, n = 0, this instanceof Hg && (l = this.sa.bounds, G = l.x, O = l.y, S = l.width, l = l.height, n = this.strokeWidth), yi(this, a, this.jb, !0, !1, h, d), this.jb instanceof zl && this.jb.type === Al ? (a.beginPath(), a.rect(G - n / 2, O - n / 2, S + n, l + n), a.Vd(this.jb)) : a.fillRect(G - n / 2, O - n / 2, S + n, l + n)); E && E.Fi && E.Ny && E.Ny(a, this); k && (null !== this.jb || null !== this.fc ||
                            null !== g && 0 !== (g.I & 512) || null !== g && (g.type === W.Auto || g.type === W.Spot) && g.Bb() !== this) ? (Bl(this, !0), null === this.shadowVisible && yl(a)) : Bl(this, !1); this.Gi(a, b); k && 0 !== (this.I & 512) === !0 && xl(a); this.vg() && k && yl(a); m ? (a.restore(), this instanceof W ? a.Uc(!0) : a.Uc(!1)) : c.it() || (b = 1 / (c.m11 * c.m22 - c.m12 * c.m21), a.transform(c.m22 * b, -c.m12 * b, -c.m21 * b, c.m11 * b, b * (c.m21 * c.dy - c.m22 * c.dx), b * (c.m12 * c.dx - c.m11 * c.dy)))
                    }
                    } 1 !== e && (a.globalAlpha = f)
                }
            }
        }
    }; t.kx = function () { return !1 };
    function vl(a, b, c) { var d = a.wb, e = a.rc; null !== a.fc && (yi(a, b, a.fc, !0, !0, e, d), a.fc instanceof zl && a.fc.type === Al ? (b.beginPath(), b.rect(d.x, d.y, d.width, d.height), b.Vd(a.fc)) : b.fillRect(d.x, d.y, d.width, d.height)); null !== a.jb && (yi(a, b, a.jb, !0, !1, e, d), a.jb instanceof zl && a.jb.type === Al ? (b.beginPath(), b.rect(d.x, d.y, d.width, d.height), b.Vd(a.jb)) : b.fillRect(d.x, d.y, d.width, d.height)); a.Gi(b, c) } t.Gi = function () { };
    function yi(a, b, c, d, e, f, g) {
        if (null !== c) {
            var h = 1, k = 1; if ("string" === typeof c) d ? b.fillStyle = c : b.strokeStyle = c; else if (c.type === Cl) d ? b.fillStyle = c.color : b.strokeStyle = c.color; else {
                h = f.width; k = f.height; e && (h = g.width, k = g.height); if ((f = b instanceof Dl) && c.fe && (c.type === El || c.Kk === h && c.Qt === k)) var l = c.fe; else {
                    var m = 0, n = 0, p = 0, q = 0, r = 0, u = 0; u = r = 0; e && (r = g.x, u = g.y); m = c.start.x * h + c.start.offsetX; n = c.start.y * k + c.start.offsetY; p = c.end.x * h + c.end.offsetX; q = c.end.y * k + c.end.offsetY; m += r; p += r; n += u; q += u; if (c.type === Fl) l =
                        b.createLinearGradient(m, n, p, q); else if (c.type === Al) u = isNaN(c.endRadius) ? Math.max(h, k) / 2 : c.endRadius, isNaN(c.startRadius) ? (r = 0, u = Math.max(h, k) / 2) : r = c.startRadius, l = b.createRadialGradient(m, n, r, p, q, u); else if (c.type === El) try { l = b.createPattern(c.pattern, "repeat") } catch (y) { l = null } else Ba(c.type, "Brush type"); if (c.type !== El && (e = c.colorStops, null !== e)) for (e = e.iterator; e.next();)l.addColorStop(e.key, e.value); if (f && (c.fe = l, null !== l && (c.Kk = h, c.Qt = k), null === l && c.type === El && -1 !== c.Kk)) {
                        c.Kk = -1; var x = a.diagram;
                            null !== x && -1 === c.Kk && wa(function () { x.vf() }, 600)
                        }
                } d ? b.fillStyle = l : b.strokeStyle = l
            }
        }
    } t.tg = function (a) { if (a instanceof W) a: { if (this !== a && null !== a) for (var b = this.panel; null !== b;) { if (b === a) { a = !0; break a } b = b.panel } a = !1 } else a = !1; return a }; t.uf = function () { if (!this.visible) return !1; var a = this.panel; return null !== a ? a.uf() : !0 }; t.ug = function () { for (var a = this instanceof W ? this : this.panel; null !== a && a.isEnabled;)a = a.panel; return null === a };
    function wl(a) { if (0 !== (a.I & 2048) === !0) { var b = a.ub; b.reset(); if (!a.wb.o() || !a.qc.o()) { Gl(a, !1); return } b.translate(a.wb.x - a.qc.x, a.wb.y - a.qc.y); if (1 !== a.scale || 0 !== a.angle) { var c = a.naturalBounds; ol(a, b, c.x, c.y, c.width, c.height) } Gl(a, !1); Hl(a, !0) } 0 !== (a.I & 4096) === !0 && (b = a.panel, null === b ? (a.Fh.set(a.ub), a.Wk = a.scale, Hl(a, !1)) : null !== b.td && (c = a.Fh, c.reset(), b.ae() ? c.multiply(b.Fh) : null !== b.panel && c.multiply(b.panel.Fh), c.multiply(a.ub), a.Wk = a.scale * b.Wk, Hl(a, !1))) }
    function ol(a, b, c, d, e, f) { 1 !== a.scale && b.scale(a.scale); if (0 !== a.angle) { var g = qd; a.vg() && a.locationSpot.Za() && (g = a.locationSpot); var h = J.alloc(); if (a instanceof R && a.locationObject !== a) for (c = a.locationObject, d = c.naturalBounds, h.uk(d.x, d.y, d.width, d.height, g), c.Qf.va(h), h.offset(-c.measuredBounds.x, -c.measuredBounds.y), g = c.panel; null !== g && g !== a;)g.Qf.va(h), h.offset(-g.measuredBounds.x, -g.measuredBounds.y), g = g.panel; else h.uk(c, d, e, f, g); b.rotate(a.angle, h.x, h.y); J.free(h) } }
    t.v = function (a) { void 0 === a && (a = !1); if (!0 !== Dj(this)) { yj(this, !0); rl(this, !0); var b = this.panel; null === b || a || b.v() } }; t.hm = function () { !0 !== Dj(this) && (yj(this, !0), rl(this, !0)) }; function Il(a) { if (!1 === Ej(a)) { var b = a.panel; null !== b ? b.v() : a.vg() && (b = a.diagram, null !== b && (b.Fd.add(a), a instanceof V && a.gd(), b.ec())); rl(a, !0) } } t.jl = function () { 0 !== (this.I & 2048) === !1 && (Gl(this, !0), Hl(this, !0)) }; t.qv = function () { Hl(this, !0) }; t.S = function () { var a = this.part; null !== a && a.S() };
    function ql(a, b) { var c = a.stretch, d = a.panel; if (null !== d && d.type === W.Table) return Jl(a, d.getRowDefinition(a.row), d.getColumnDefinition(a.column), b); if (null !== d && d.type === W.Auto && d.Bb() === a) return Kl(a, oe, b); if (c === al) { if (null !== d) { if (d.type === W.Spot && d.Bb() === a) return Kl(a, oe, b); c = d.defaultStretch; return c === al ? Kl(a, nh, b) : Kl(a, c, b) } return Kl(a, nh, b) } return Kl(a, c, b) }
    function Jl(a, b, c, d) { var e = a.stretch; if (e !== al) return Kl(a, e, d); var f = e = null; switch (b.stretch) { case cl: f = !0; break; case oe: f = !0 }switch (c.stretch) { case bl: e = !0; break; case oe: e = !0 }b = a.panel.defaultStretch; null === e && (e = b === bl || b === oe); null === f && (f = b === cl || b === oe); return !0 === e && !0 === f ? Kl(a, oe, d) : !0 === e ? Kl(a, bl, d) : !0 === f ? Kl(a, cl, d) : Kl(a, nh, d) }
    function Kl(a, b, c) { if (c) return b; if (b === nh) return nh; c = a.desiredSize; if (c.o()) return nh; a = a.angle; if (!isNaN(c.width)) if (90 !== a && 270 !== a) { if (b === bl) return nh; if (b === oe) return cl } else { if (b === cl) return nh; if (b === oe) return bl } if (!isNaN(c.height)) if (90 !== a && 270 !== a) { if (b === cl) return nh; if (b === oe) return bl } else { if (b === bl) return nh; if (b === oe) return cl } return b } function Bl(a, b) { a.I = b ? a.I | 512 : a.I & -513 } function kl(a) { return 0 !== (a.I & 1024) } function Ll(a, b) { a.I = b ? a.I | 1024 : a.I & -1025 }
    function Gl(a, b) { a.I = b ? a.I | 2048 : a.I & -2049 } function Hl(a, b) { a.I = b ? a.I | 4096 : a.I & -4097 } function Dj(a) { return 0 !== (a.I & 8192) } function yj(a, b) { a.I = b ? a.I | 8192 : a.I & -8193 } function Ej(a) { return 0 !== (a.I & 16384) } function rl(a, b) { a.I = b ? a.I | 16384 : a.I & -16385 } t.Wi = function (a) { this.cg = a }; t.Sv = function () { }; t.Rv = function (a) { this.ua = a; Il(this); return !0 }; t.Bt = function (a, b) { this.ua.h(a, b); this.jl() };
    function Ml(a) { var b = a.part; if (b instanceof V && (null !== a.portId || a === b.port)) { var c = b.diagram; null === c || c.undoManager.isUndoingRedoing || ul(b, a) } } function Nl(a) { var b = a.diagram; null === b || b.undoManager.isUndoingRedoing || (a instanceof W ? a instanceof V ? a.gd() : a.wk(a, function (a) { Ml(a) }) : Ml(a)) } t.bind = function (a) { a.Sd = this; var b = this.Ki(); null !== b && Ol(b) && v("Cannot add a Binding to a template that has already been copied: " + a); null === this.eb && (this.eb = new F); this.eb.add(a) };
    t.Ki = function () { for (var a = this instanceof W ? this : this.panel; null !== a;) { if (null !== a.Sh) return a; a = a.panel } return null }; t.Tv = function (a) { Kj(this, a) };
    function Pl(a, b) {
        for (var c = 1; c < arguments.length; ++c); c = arguments; var d = null, e = null; if ("function" === typeof a) e = a; else if ("string" === typeof a) { var f = Ql.K(a); "function" === typeof f ? (c = Ma(arguments), d = f(c), Ia(d) || v('GraphObject.make invoked object builder "' + a + '", but it did not return an Object')) : e = qa.go[a] } null === d && (void 0 !== e && null !== e && e.constructor || v("GraphObject.make requires a class function or GoJS class name or name of an object builder, not: " + a), d = new e); e = 1; if (d instanceof P && 1 < c.length) {
            f =
            d; var g = c[1]; if ("string" === typeof g || g instanceof HTMLDivElement) Pi(f, g), e++
        } for (; e < c.length; e++)f = c[e], void 0 === f ? v("Undefined value at argument " + e + " for object being constructed by GraphObject.make: " + d) : Rl(d, f); return d
    }
    function Rl(a, b) {
        if ("string" === typeof b) if (a instanceof Kh) a.text = b; else if (a instanceof Hg) a.figure = b; else if (a instanceof lk) a.source = b; else if (a instanceof W) { var c = Sl.K(b); null !== c ? a.type = c : E && v("Unknown Panel type as an argument to GraphObject.make: " + b + ". If building from source, you may need to call Panel.definePanelLayout.") } else a instanceof zl ? (c = sb(zl, b), null !== c ? a.type = c : v("Unknown Brush type as an argument to GraphObject.make: " + b)) : a instanceof me ? (c = sb(me, b), null !== c ? a.type = c : E && v("Unknown Geometry type as an argument to GraphObject.make: " +
            b)) : a instanceof Ye ? (c = sb(Ye, b), null !== c ? a.type = c : E && v("Unknown PathSegment type as an argument to GraphObject.make: " + b)) : E && v("Unable to use a string as an argument to GraphObject.make: " + b); else if (b instanceof N) a instanceof W || v("A GraphObject can only be added to a Panel, not to: " + a), a.add(b); else if (b instanceof fk) {
                var d; b.isRow && "function" === typeof a.getRowDefinition ? d = a.getRowDefinition(b.index) : b.isRow || "function" !== typeof a.getColumnDefinition || (d = a.getColumnDefinition(b.index)); d instanceof
                    fk ? d.Zl(b) : v("A RowColumnDefinition can only be added to an object that implements getRowDefinition/getColumnDefinition, not to: " + a)
            } else if (b instanceof D) "function" === typeof a.hb ? a.hb(b) : Fa(a, b); else if (b instanceof Tl) a.type = b; else if (b instanceof Ti) a instanceof N ? a.bind(b) : a instanceof fk ? a.bind(b) : v("A Binding can only be applied to a GraphObject or RowColumnDefinition, not to: " + a); else if (b instanceof Xe) a instanceof me ? a.figures.add(b) : v("A PathFigure can only be added to a Geometry, not to: " +
                a); else if (b instanceof Ye) a instanceof Xe ? a.segments.add(b) : v("A PathSegment can only be added to a PathFigure, not to: " + a); else if (b instanceof Ni) a instanceof P ? a.layout = b : a instanceof xg ? a.layout = b : v("A Layout can only be assigned to a Diagram or a Group, not to: " + a); else if (Array.isArray(b)) for (c = 0; c < b.length; c++)Rl(a, b[c]); else if ("object" === typeof b && null !== b) if (a instanceof zl) { c = new xb; for (var e in b) d = parseFloat(e), isNaN(d) ? c[e] = b[e] : a.addColorStop(d, b[e]); Kj(a, c) } else if (a instanceof
                    fk) { void 0 !== b.row ? (e = b.row, (void 0 === e || null === e || Infinity === e || isNaN(e) || 0 > e) && v("Must specify non-negative integer row for RowColumnDefinition " + b + ", not: " + e), a.isRow = !0, a.index = e) : void 0 !== b.column && (e = b.column, (void 0 === e || null === e || Infinity === e || isNaN(e) || 0 > e) && v("Must specify non-negative integer column for RowColumnDefinition " + b + ", not: " + e), a.isRow = !1, a.index = e); e = new xb; for (c in b) "row" !== c && "column" !== c && (e[c] = b[c]); Kj(a, e) } else Kj(a, b); else v('Unknown initializer "' + b + '" for object being constructed by GraphObject.make: ' +
                        a)
    } function Ul(a, b) { z(a, "string", N, "defineBuilder:name"); z(b, "function", N, "defineBuilder:func"); var c = a.toLowerCase(); E && ("" === a || "none" === c || a === c) && v("Shape.defineFigureGenerator name must not be empty or None or all-lower-case: " + a); Ql.add(a, b) }
    function Vl(a, b, c) { void 0 === c && (c = null); var d = a[1]; if ("function" === typeof c ? c(d) : "string" === typeof d) return a.splice(1, 1), d; if (void 0 === b) throw Error("no " + ("function" === typeof c ? "satisfactory" : "string") + " argument for GraphObject builder " + a[0]); return b }
    na.Object.defineProperties(N.prototype, {
        shadowVisible: { configurable: !0, get: function () { return this.Gl }, set: function (a) { var b = this.Gl; b !== a && (E && null !== a && z(a, "boolean", N, "shadowVisible"), this.Gl = a, this.S(), this.g("shadowVisible", b, a)) } }, enabledChanged: { configurable: !0, get: function () { return null !== this.P ? this.P.Fn : null }, set: function (a) { hl(this); var b = this.P.Fn; b !== a && (null !== a && z(a, "function", N, "enabledChanged"), this.P.Fn = a, this.g("enabledChanged", b, a)) } }, segmentOrientation: {
            configurable: !0,
            enumerable: !0, get: function () { return this.El }, set: function (a) { var b = this.El; b !== a && (E && tb(a, Q, N, "segmentOrientation"), this.El = a, this.v(), this.g("segmentOrientation", b, a), a === ch && (this.angle = 0)) }
        }, segmentIndex: { configurable: !0, get: function () { return this.np }, set: function (a) { E && z(a, "number", N, "segmentIndex"); a = Math.round(a); var b = this.np; b !== a && (this.np = a, this.v(), this.g("segmentIndex", b, a)) } }, segmentFraction: {
            configurable: !0, get: function () { return this.Cl }, set: function (a) {
                E &&
                z(a, "number", N, "segmentFraction"); isNaN(a) ? a = 0 : 0 > a ? a = 0 : 1 < a && (a = 1); var b = this.Cl; b !== a && (this.Cl = a, this.v(), this.g("segmentFraction", b, a))
            }
        }, segmentOffset: { configurable: !0, get: function () { return this.Dl }, set: function (a) { var b = this.Dl; b.A(a) || (E && w(a, J, N, "segmentOffset"), this.Dl = a = a.J(), this.v(), this.g("segmentOffset", b, a)) } }, stretch: {
            configurable: !0, get: function () { return this.ye }, set: function (a) {
                var b = this.ye; b !== a && (E && tb(a, N, N, "stretch"), this.ye = a, this.v(), this.g("stretch",
                    b, a))
            }
        }, name: { configurable: !0, get: function () { return this.Wa }, set: function (a) { var b = this.Wa; b !== a && (E && z(a, "string", N, "name"), this.Wa = a, null !== this.part && (this.part.zj = null), this.g("name", b, a)) } }, opacity: { configurable: !0, get: function () { return this.mb }, set: function (a) { var b = this.mb; b !== a && (z(a, "number", N, "opacity"), (0 > a || 1 < a) && Ca(a, "0 <= value <= 1", N, "opacity"), this.mb = a, this.g("opacity", b, a), a = this.diagram, b = this.part, null !== a && null !== b && a.S(Oj(b, b.actualBounds))) } }, visible: {
            configurable: !0,
            enumerable: !0, get: function () { return 0 !== (this.I & 1) }, set: function (a) { var b = 0 !== (this.I & 1); b !== a && (E && z(a, "boolean", N, "visible"), this.I ^= 1, this.g("visible", b, a), b = this.panel, null !== b ? b.v() : this.vg() && this.Ob(a), this.S(), Nl(this)) }
        }, pickable: { configurable: !0, get: function () { return 0 !== (this.I & 2) }, set: function (a) { var b = 0 !== (this.I & 2); b !== a && (E && z(a, "boolean", N, "pickable"), this.I ^= 2, this.g("pickable", b, a)) } }, fromLinkableDuplicates: {
            configurable: !0, get: function () {
                return 0 !== (this.I &
                    4)
            }, set: function (a) { var b = 0 !== (this.I & 4); b !== a && (E && z(a, "boolean", N, "fromLinkableDuplicates"), this.I ^= 4, this.g("fromLinkableDuplicates", b, a)) }
        }, fromLinkableSelfNode: { configurable: !0, get: function () { return 0 !== (this.I & 8) }, set: function (a) { var b = 0 !== (this.I & 8); b !== a && (E && z(a, "boolean", N, "fromLinkableSelfNode"), this.I ^= 8, this.g("fromLinkableSelfNode", b, a)) } }, toLinkableDuplicates: {
            configurable: !0, get: function () { return 0 !== (this.I & 16) }, set: function (a) {
                var b = 0 !== (this.I & 16); b !==
                    a && (E && z(a, "boolean", N, "toLinkableDuplicates"), this.I ^= 16, this.g("toLinkableDuplicates", b, a))
            }
        }, toLinkableSelfNode: { configurable: !0, get: function () { return 0 !== (this.I & 32) }, set: function (a) { var b = 0 !== (this.I & 32); b !== a && (E && z(a, "boolean", N, "toLinkableSelfNode"), this.I ^= 32, this.g("toLinkableSelfNode", b, a)) } }, isPanelMain: {
            configurable: !0, get: function () { return 0 !== (this.I & 64) }, set: function (a) {
                var b = 0 !== (this.I & 64); b !== a && (E && z(a, "boolean", N, "isPanelMain"), this.I ^= 64, this.v(),
                    this.g("isPanelMain", b, a))
            }
        }, isActionable: { configurable: !0, get: function () { return 0 !== (this.I & 128) }, set: function (a) { var b = 0 !== (this.I & 128); b !== a && (E && z(a, "boolean", N, "isActionable"), this.I ^= 128, this.g("isActionable", b, a)) } }, areaBackground: { configurable: !0, get: function () { return this.fc }, set: function (a) { var b = this.fc; b !== a && (null !== a && Wl(a, "GraphObject.areaBackground"), a instanceof zl && a.freeze(), this.fc = a, this.S(), this.g("areaBackground", b, a)) } }, background: {
            configurable: !0,
            enumerable: !0, get: function () { return this.jb }, set: function (a) { var b = this.jb; b !== a && (null !== a && Wl(a, "GraphObject.background"), a instanceof zl && a.freeze(), this.jb = a, this.S(), this.g("background", b, a)) }
        }, part: { configurable: !0, get: function () { if (this.vg()) return this; if (null !== this.Ej) return this.Ej; var a; for (a = this.panel; a;) { if (a instanceof R) return this.Ej = a; a = a.panel } return null } }, svg: { configurable: !0, get: function () { return this.Gs }, set: function (a) { this.Gs = a } }, panel: {
            configurable: !0,
            enumerable: !0, get: function () { return this.cg }
        }, layer: { configurable: !0, get: function () { var a = this.part; return null !== a ? a.layer : null } }, diagram: { configurable: !0, get: function () { var a = this.part; return null !== a ? a.diagram : null } }, position: {
            configurable: !0, get: function () { return this.ua }, set: function (a) {
                E && w(a, J, N, "position"); var b = a.x, c = a.y, d = this.ua, e = d.x, f = d.y; (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) ? this.Sv() : (a = a.J(), this.Rv(a, d) && this.g("position",
                    d, a))
            }
        }, actualBounds: { configurable: !0, get: function () { return this.wb } }, scale: { configurable: !0, get: function () { return this.Da }, set: function (a) { var b = this.Da; b !== a && (E && B(a, N, "scale"), 0 >= a && v("GraphObject.scale for " + this + " must be greater than zero, not: " + a), this.Da = a, this.v(), this.g("scale", b, a)) } }, angle: {
            configurable: !0, get: function () { return this.Bc }, set: function (a) {
                var b = this.Bc; b !== a && (E && B(a, N, "angle"), a %= 360, 0 > a && (a += 360), b !== a && (this.Bc = a, Nl(this), this.v(),
                    this.g("angle", b, a)))
            }
        }, desiredSize: { configurable: !0, get: function () { return this.Qc }, set: function (a) { E && w(a, Zb, N, "desiredSize"); var b = a.width, c = a.height, d = this.Qc, e = d.width, f = d.height; (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) || (this.Qc = a = a.J(), this.v(), this instanceof Hg && this.cc(), this.g("desiredSize", d, a), kl(this) && (a = this.part, null !== a && (ll(this, a, "width"), ll(this, a, "height")))) } }, width: {
            configurable: !0, get: function () { return this.Qc.width }, set: function (a) {
                var b =
                    this.Qc.width; b === a || isNaN(b) && isNaN(a) || (E && z(a, "number", N, "width"), b = this.Qc, this.Qc = a = (new Zb(a, this.Qc.height)).freeze(), this.v(), this instanceof Hg && this.cc(), this.g("desiredSize", b, a), kl(this) && (a = this.part, null !== a && ll(this, a, "width")))
            }
        }, height: {
            configurable: !0, get: function () { return this.Qc.height }, set: function (a) {
                var b = this.Qc.height; b === a || isNaN(b) && isNaN(a) || (E && z(a, "number", N, "height"), b = this.Qc, this.Qc = a = (new Zb(this.Qc.width, a)).freeze(), this.v(), this instanceof Hg && this.cc(),
                    this.g("desiredSize", b, a), kl(this) && (a = this.part, null !== a && ll(this, a, "height")))
            }
        }, minSize: { configurable: !0, get: function () { return this.Sf }, set: function (a) { var b = this.Sf; b.A(a) || (E && w(a, Zb, N, "minSize"), a = a.copy(), isNaN(a.width) && (a.width = 0), isNaN(a.height) && (a.height = 0), a.freeze(), this.Sf = a, this.v(), this.g("minSize", b, a)) } }, maxSize: {
            configurable: !0, get: function () { return this.Rf }, set: function (a) {
                var b = this.Rf; b.A(a) || (E && w(a, Zb, N, "maxSize"), a = a.copy(), isNaN(a.width) && (a.width =
                    Infinity), isNaN(a.height) && (a.height = Infinity), a.freeze(), this.Rf = a, this.v(), this.g("maxSize", b, a))
            }
        }, measuredBounds: { configurable: !0, get: function () { return this.qc } }, naturalBounds: { configurable: !0, get: function () { return this.rc } }, margin: { configurable: !0, get: function () { return this.Wg }, set: function (a) { "number" === typeof a ? a = new Hc(a) : E && w(a, Hc, N, "margin"); var b = this.Wg; b.A(a) || (this.Wg = a = a.J(), this.v(), this.g("margin", b, a)) } }, transform: {
            configurable: !0,
            get: function () { 0 !== (this.I & 2048) === !0 && wl(this); return this.ub }
        }, td: { configurable: !0, get: function () { 0 !== (this.I & 4096) === !0 && wl(this); return this.Fh } }, alignment: { configurable: !0, get: function () { return this.xb }, set: function (a) { var b = this.xb; b.A(a) || (E && w(a, M, N, "alignment"), a.Nb() && !a.Cb() && v("GraphObject.alignment for " + this + " must be a real Spot or Spot.Default, not: " + a), this.xb = a = a.J(), Il(this), this.g("alignment", b, a)) } }, column: {
            configurable: !0, get: function () { return this.Fg },
            set: function (a) { E && B(a, N, "column"); a = Math.round(a); var b = this.Fg; b !== a && (0 > a && Ca(a, ">= 0", N, "column"), this.Fg = a, this.v(), this.g("column", b, a)) }
        }, columnSpan: { configurable: !0, get: function () { return this.cn }, set: function (a) { E && z(a, "number", N, "columnSpan"); a = Math.round(a); var b = this.cn; b !== a && (1 > a && Ca(a, ">= 1", N, "columnSpan"), this.cn = a, this.v(), this.g("columnSpan", b, a)) } }, row: {
            configurable: !0, get: function () { return this.ip }, set: function (a) {
                E && B(a, N, "row"); a = Math.round(a); var b =
                    this.ip; b !== a && (0 > a && Ca(a, ">= 0", N, "row"), this.ip = a, this.v(), this.g("row", b, a))
            }
        }, rowSpan: { configurable: !0, get: function () { return this.jp }, set: function (a) { E && z(a, "number", N, "rowSpan"); a = Math.round(a); var b = this.jp; b !== a && (1 > a && Ca(a, ">= 1", N, "rowSpan"), this.jp = a, this.v(), this.g("rowSpan", b, a)) } }, spanAllocation: {
            configurable: !0, get: function () { return this.zp }, set: function (a) {
                var b = this.zp; b !== a && (null !== a && z(a, "function", N, "spanAllocation"), this.zp = a, this.v(), this.g("spanAllocation",
                    b, a))
            }
        }, alignmentFocus: { configurable: !0, get: function () { return this.Bk }, set: function (a) { var b = this.Bk; b.A(a) || (E && w(a, M, N, "alignmentFocus"), !E || !a.Nb() || a.Cb() || a.kq() && this instanceof V || v("GraphObject.alignmentFocus must be a real Spot or Spot.Default, not: " + a), this.Bk = a = a.J(), this.v(), this.g("alignmentFocus", b, a)) } }, portId: {
            configurable: !0, get: function () { return this.Vo }, set: function (a) {
                var b = this.Vo; if (b !== a) {
                E && null !== a && z(a, "string", N, "portId"); var c = this.part; null ===
                    c || c instanceof V || (v("Cannot set portID on a Link: " + a), c = null); null !== b && null !== c && Xl(c, this); this.Vo = a; null !== a && null !== c && (c.yh = !0, Yl(c, this)); this.g("portId", b, a)
                }
            }
        }, toSpot: { configurable: !0, get: function () { return null !== this.R ? this.R.nh : ed }, set: function (a) { this.Jc(); var b = this.R.nh; b.A(a) || (E && w(a, M, N, "toSpot"), a = a.J(), this.R.nh = a, this.g("toSpot", b, a), Ml(this)) } }, toEndSegmentLength: {
            configurable: !0, get: function () { return null !== this.R ? this.R.lh : 10 }, set: function (a) {
                this.Jc();
                var b = this.R.lh; b !== a && (E && z(a, "number", N, "toEndSegmentLength"), 0 > a && Ca(a, ">= 0", N, "toEndSegmentLength"), this.R.lh = a, this.g("toEndSegmentLength", b, a), Ml(this))
            }
        }, toShortLength: { configurable: !0, get: function () { return null !== this.R ? this.R.mh : 0 }, set: function (a) { this.Jc(); var b = this.R.mh; b !== a && (E && z(a, "number", N, "toShortLength"), this.R.mh = a, this.g("toShortLength", b, a), Ml(this)) } }, toLinkable: {
            configurable: !0, get: function () { return null !== this.R ? this.R.Gp : null }, set: function (a) {
                this.Jc();
                var b = this.R.Gp; b !== a && (E && null !== a && z(a, "boolean", N, "toLinkable"), this.R.Gp = a, this.g("toLinkable", b, a))
            }
        }, toMaxLinks: { configurable: !0, get: function () { return null !== this.R ? this.R.Hp : Infinity }, set: function (a) { this.Jc(); var b = this.R.Hp; b !== a && (E && z(a, "number", N, "toMaxLinks"), 0 > a && Ca(a, ">= 0", N, "toMaxLinks"), this.R.Hp = a, this.g("toMaxLinks", b, a)) } }, fromSpot: {
            configurable: !0, get: function () { return null !== this.R ? this.R.Og : ed }, set: function (a) {
                this.Jc(); var b = this.R.Og; b.A(a) || (E &&
                    w(a, M, N, "fromSpot"), a = a.J(), this.R.Og = a, this.g("fromSpot", b, a), Ml(this))
            }
        }, fromEndSegmentLength: { configurable: !0, get: function () { return null !== this.R ? this.R.Mg : 10 }, set: function (a) { this.Jc(); var b = this.R.Mg; b !== a && (E && z(a, "number", N, "fromEndSegmentLength"), 0 > a && Ca(a, ">= 0", N, "fromEndSegmentLength"), this.R.Mg = a, this.g("fromEndSegmentLength", b, a), Ml(this)) } }, fromShortLength: {
            configurable: !0, get: function () { return null !== this.R ? this.R.Ng : 0 }, set: function (a) {
                this.Jc(); var b = this.R.Ng;
                b !== a && (E && z(a, "number", N, "fromShortLength"), this.R.Ng = a, this.g("fromShortLength", b, a), Ml(this))
            }
        }, fromLinkable: { configurable: !0, get: function () { return null !== this.R ? this.R.Hn : null }, set: function (a) { this.Jc(); var b = this.R.Hn; b !== a && (E && null !== a && z(a, "boolean", N, "fromLinkable"), this.R.Hn = a, this.g("fromLinkable", b, a)) } }, fromMaxLinks: {
            configurable: !0, get: function () { return null !== this.R ? this.R.In : Infinity }, set: function (a) {
                this.Jc(); var b = this.R.In; b !== a && (E && z(a, "number", N, "fromMaxLinks"),
                    0 > a && Ca(a, ">= 0", N, "fromMaxLinks"), this.R.In = a, this.g("fromMaxLinks", b, a))
            }
        }, cursor: { configurable: !0, get: function () { return this.nn }, set: function (a) { var b = this.nn; b !== a && (z(a, "string", N, "cursor"), this.nn = a, this.g("cursor", b, a)) } }, click: { configurable: !0, get: function () { return null !== this.P ? this.P.Df : null }, set: function (a) { hl(this); var b = this.P.Df; b !== a && (null !== a && z(a, "function", N, "click"), this.P.Df = a, this.g("click", b, a)) } }, doubleClick: {
            configurable: !0, get: function () {
                return null !==
                    this.P ? this.P.If : null
            }, set: function (a) { hl(this); var b = this.P.If; b !== a && (null !== a && z(a, "function", N, "doubleClick"), this.P.If = a, this.g("doubleClick", b, a)) }
        }, contextClick: { configurable: !0, get: function () { return null !== this.P ? this.P.Ef : null }, set: function (a) { hl(this); var b = this.P.Ef; b !== a && (null !== a && z(a, "function", N, "contextClick"), this.P.Ef = a, this.g("contextClick", b, a)) } }, mouseEnter: {
            configurable: !0, get: function () { return null !== this.P ? this.P.Uf : null }, set: function (a) {
                hl(this);
                var b = this.P.Uf; b !== a && (null !== a && z(a, "function", N, "mouseEnter"), this.P.Uf = a, this.g("mouseEnter", b, a))
            }
        }, mouseLeave: { configurable: !0, get: function () { return null !== this.P ? this.P.Xf : null }, set: function (a) { hl(this); var b = this.P.Xf; b !== a && (null !== a && z(a, "function", N, "mouseLeave"), this.P.Xf = a, this.g("mouseLeave", b, a)) } }, mouseOver: {
            configurable: !0, get: function () { return null !== this.P ? this.P.Yf : null }, set: function (a) {
                hl(this); var b = this.P.Yf; b !== a && (null !== a && z(a, "function", N, "mouseOver"),
                    this.P.Yf = a, this.g("mouseOver", b, a))
            }
        }, mouseHover: { configurable: !0, get: function () { return null !== this.P ? this.P.Wf : null }, set: function (a) { hl(this); var b = this.P.Wf; b !== a && (null !== a && z(a, "function", N, "mouseHover"), this.P.Wf = a, this.g("mouseHover", b, a)) } }, mouseHold: { configurable: !0, get: function () { return null !== this.P ? this.P.Vf : null }, set: function (a) { hl(this); var b = this.P.Vf; b !== a && (null !== a && z(a, "function", N, "mouseHold"), this.P.Vf = a, this.g("mouseHold", b, a)) } }, mouseDragEnter: {
            configurable: !0,
            enumerable: !0, get: function () { return null !== this.P ? this.P.xo : null }, set: function (a) { hl(this); var b = this.P.xo; b !== a && (null !== a && z(a, "function", N, "mouseDragEnter"), this.P.xo = a, this.g("mouseDragEnter", b, a)) }
        }, mouseDragLeave: { configurable: !0, get: function () { return null !== this.P ? this.P.yo : null }, set: function (a) { hl(this); var b = this.P.yo; b !== a && (null !== a && z(a, "function", N, "mouseDragLeave"), this.P.yo = a, this.g("mouseDragLeave", b, a)) } }, mouseDrop: {
            configurable: !0, get: function () {
                return null !==
                    this.P ? this.P.Tf : null
            }, set: function (a) { hl(this); var b = this.P.Tf; b !== a && (null !== a && z(a, "function", N, "mouseDrop"), this.P.Tf = a, this.g("mouseDrop", b, a)) }
        }, actionDown: { configurable: !0, get: function () { return null !== this.P ? this.P.Mm : null }, set: function (a) { hl(this); var b = this.P.Mm; b !== a && (null !== a && z(a, "function", N, "actionDown"), this.P.Mm = a, this.g("actionDown", b, a)) } }, actionMove: {
            configurable: !0, get: function () { return null !== this.P ? this.P.Nm : null }, set: function (a) {
                hl(this); var b = this.P.Nm;
                b !== a && (null !== a && z(a, "function", N, "actionMove"), this.P.Nm = a, this.g("actionMove", b, a))
            }
        }, actionUp: { configurable: !0, get: function () { return null !== this.P ? this.P.Om : null }, set: function (a) { hl(this); var b = this.P.Om; b !== a && (null !== a && z(a, "function", N, "actionUp"), this.P.Om = a, this.g("actionUp", b, a)) } }, actionCancel: {
            configurable: !0, get: function () { return null !== this.P ? this.P.Lm : null }, set: function (a) {
                hl(this); var b = this.P.Lm; b !== a && (null !== a && z(a, "function", N, "actionCancel"), this.P.Lm =
                    a, this.g("actionCancel", b, a))
            }
        }, toolTip: { configurable: !0, get: function () { return null !== this.P ? this.P.jg : null }, set: function (a) { hl(this); var b = this.P.jg; b !== a && (!E || null === a || a instanceof Cf || a instanceof Hf || v("GraphObject.toolTip must be an Adornment or HTMLInfo."), this.P.jg = a, this.g("toolTip", b, a)) } }, contextMenu: {
            configurable: !0, get: function () { return null !== this.P ? this.P.Ff : null }, set: function (a) {
                hl(this); var b = this.P.Ff; b !== a && (!E || a instanceof Cf || a instanceof Hf || v("GraphObject.contextMenu must be an Adornment or HTMLInfo."),
                    this.P.Ff = a, this.g("contextMenu", b, a))
            }
        }
    }); N.prototype.setProperties = N.prototype.Tv; N.prototype.findTemplateBinder = N.prototype.Ki; N.prototype.bind = N.prototype.bind; N.prototype.isEnabledObject = N.prototype.ug; N.prototype.isVisibleObject = N.prototype.uf; N.prototype.isContainedBy = N.prototype.tg; N.prototype.getNearestIntersectionPoint = N.prototype.Wc; N.prototype.getLocalPoint = N.prototype.at; N.prototype.getDocumentScale = N.prototype.Fe; N.prototype.getDocumentAngle = N.prototype.Ni;
    N.prototype.getDocumentBounds = N.prototype.eq; N.prototype.getDocumentPoint = N.prototype.oa; N.prototype.intersectsRect = N.prototype.Kc; N.prototype.containedInRect = N.prototype.vh; N.prototype.containsRect = N.prototype.pf; N.prototype.containsPoint = N.prototype.ea; N.prototype.raiseChanged = N.prototype.g; N.prototype.raiseChangedEvent = N.prototype.cb; N.prototype.addCopyProperty = N.prototype.Vw; var Ql = null; N.className = "GraphObject"; Ql = new Ub;
    Ul("Button", function () {
        function a(a, b) { return null !== a.diagram.Tb(a.documentPoint, function (a) { for (; null !== a.panel && !a.isActionable;)a = a.panel; return a }, function (a) { return a === b }) } var b = Pl(W, W.Auto, {
            isActionable: !0, enabledChanged: function (a, b) { if (a instanceof W) { var c = a.bb("ButtonBorder"); null !== c && (c.fill = b ? a._buttonFillNormal : a._buttonFillDisabled) } }, cursor: "pointer", _buttonFillNormal: "#F5F5F5", _buttonStrokeNormal: "#BDBDBD", _buttonFillOver: "#E0E0E0", _buttonStrokeOver: "#9E9E9E", _buttonFillPressed: "#BDBDBD",
            _buttonStrokePressed: "#9E9E9E", _buttonFillDisabled: "#E5E5E5"
        }, Pl(Hg, { name: "ButtonBorder", figure: "RoundedRectangle", spot1: new M(0, 0, 2.76142374915397, 2.761423749153969), spot2: new M(1, 1, -2.76142374915397, -2.761423749153969), parameter1: 2, parameter2: 2, fill: "#F5F5F5", stroke: "#BDBDBD" })); b.mouseEnter = function (a, b) { if (b.ug() && b instanceof W && (a = b.bb("ButtonBorder"), a instanceof Hg)) { var c = b._buttonFillOver; b._buttonFillNormal = a.fill; a.fill = c; c = b._buttonStrokeOver; b._buttonStrokeNormal = a.stroke; a.stroke = c } };
        b.mouseLeave = function (a, b) { b.ug() && b instanceof W && (a = b.bb("ButtonBorder"), a instanceof Hg && (a.fill = b._buttonFillNormal, a.stroke = b._buttonStrokeNormal)) }; b.actionDown = function (a, b) {
            if (b.ug() && b instanceof W && null !== b._buttonFillPressed && 0 === a.button) {
                var c = b.bb("ButtonBorder"); if (c instanceof Hg) {
                    a = a.diagram; var d = a.skipsUndoManager; a.skipsUndoManager = !0; var g = b._buttonFillPressed; b._buttonFillOver = c.fill; c.fill = g; g = b._buttonStrokePressed; b._buttonStrokeOver = c.stroke; c.stroke = g; a.skipsUndoManager =
                        d
                }
            }
        }; b.actionUp = function (b, d) { if (d.ug() && d instanceof W && null !== d._buttonFillPressed && 0 === b.button) { var c = d.bb("ButtonBorder"); if (c instanceof Hg) { var f = b.diagram, g = f.skipsUndoManager; f.skipsUndoManager = !0; a(b, d) ? (c.fill = d._buttonFillOver, c.stroke = d._buttonStrokeOver) : (c.fill = d._buttonFillNormal, c.stroke = d._buttonStrokeNormal); f.skipsUndoManager = g } } }; b.actionCancel = function (b, d) {
            if (d.ug() && d instanceof W && null !== d._buttonFillPressed) {
                var c = d.bb("ButtonBorder"); if (c instanceof Hg) {
                    var f = b.diagram,
                    g = f.skipsUndoManager; f.skipsUndoManager = !0; a(b, d) ? (c.fill = d._buttonFillOver, c.stroke = d._buttonStrokeOver) : (c.fill = d._buttonFillNormal, c.stroke = d._buttonStrokeNormal); f.skipsUndoManager = g
                }
            }
        }; b.actionMove = function (b, d) {
            if (d.ug() && d instanceof W && null !== d._buttonFillPressed) {
                var c = b.diagram; if (0 === c.firstInput.button && (c.currentTool.standardMouseOver(), a(b, d) && (b = d.bb("ButtonBorder"), b instanceof Hg))) {
                    var f = c.skipsUndoManager; c.skipsUndoManager = !0; var g = d._buttonFillPressed; b.fill !== g && (b.fill = g); g =
                        d._buttonStrokePressed; b.stroke !== g && (b.stroke = g); c.skipsUndoManager = f
                }
            }
        }; return b
    });
    Ul("TreeExpanderButton", function () {
        var a = Pl("Button", { _treeExpandedFigure: "MinusLine", _treeCollapsedFigure: "PlusLine" }, Pl(Hg, { name: "ButtonIcon", figure: "MinusLine", stroke: "#424242", strokeWidth: 2, desiredSize: uc }, (new Ti("figure", "isTreeExpanded", function (a, c) { c = c.panel; return a ? c._treeExpandedFigure : c._treeCollapsedFigure })).rq()), { visible: !1 }, (new Ti("visible", "isTreeLeaf", function (a) { return !a })).rq()); a.click = function (a, c) {
            c = c.part; c instanceof Cf && (c = c.adornedPart); if (c instanceof V) {
                var b = c.diagram;
                if (null !== b) { b = b.commandHandler; if (c.isTreeExpanded) { if (!b.canCollapseTree(c)) return } else if (!b.canExpandTree(c)) return; a.handled = !0; c.isTreeExpanded ? b.collapseTree(c) : b.expandTree(c) }
            }
        }; return a
    });
    Ul("SubGraphExpanderButton", function () {
        var a = Pl("Button", { _subGraphExpandedFigure: "MinusLine", _subGraphCollapsedFigure: "PlusLine" }, Pl(Hg, { name: "ButtonIcon", figure: "MinusLine", stroke: "#424242", strokeWidth: 2, desiredSize: uc }, (new Ti("figure", "isSubGraphExpanded", function (a, c) { c = c.panel; return a ? c._subGraphExpandedFigure : c._subGraphCollapsedFigure })).rq())); a.click = function (a, c) {
            c = c.part; c instanceof Cf && (c = c.adornedPart); if (c instanceof xg) {
                var b = c.diagram; if (null !== b) {
                    b = b.commandHandler; if (c.isSubGraphExpanded) { if (!b.canCollapseSubGraph(c)) return } else if (!b.canExpandSubGraph(c)) return;
                    a.handled = !0; c.isSubGraphExpanded ? b.collapseSubGraph(c) : b.expandSubGraph(c)
                }
            }
        }; return a
    }); Ul("ToolTip", function () { return Pl(Cf, W.Auto, { isShadowed: !0, shadowColor: "rgba(0, 0, 0, .4)", shadowOffset: new J(0, 3), shadowBlur: 5 }, Pl(Hg, { name: "Border", figure: "RoundedRectangle", parameter1: 1, parameter2: 1, fill: "#F5F5F5", stroke: "#F0F0F0", spot1: new M(0, 0, 4, 6), spot2: new M(1, 1, -4, -4) })) });
    Ul("ContextMenu", function () { return Pl(Cf, W.Vertical, { background: "#F5F5F5", isShadowed: !0, shadowColor: "rgba(0, 0, 0, .4)", shadowOffset: new J(0, 3), shadowBlur: 5 }, new Ti("background", "", function (a) { return null !== a.adornedPart && null !== a.placeholder ? null : "#F5F5F5" })) }); Ul("ContextMenuButton", function () { var a = Pl("Button"); a.stretch = bl; var b = a.bb("ButtonBorder"); b instanceof Hg && (b.figure = "Rectangle", b.strokeWidth = 0, b.spot1 = new M(0, 0, 2, 3), b.spot2 = new M(1, 1, -2, -2)); return a });
    Ul("PanelExpanderButton", function (a) {
        var b = Vl(a, "COLLAPSIBLE"), c = Pl("Button", { _buttonExpandedFigure: "M0 0 M0 6 L4 2 8 6 M8 8", _buttonCollapsedFigure: "M0 0 M0 2 L4 6 8 2 M8 8", _buttonFillNormal: "rgba(0, 0, 0, 0)", _buttonStrokeNormal: null, _buttonFillOver: "rgba(0, 0, 0, .2)", _buttonStrokeOver: null, _buttonFillPressed: "rgba(0, 0, 0, .4)", _buttonStrokePressed: null }, Pl(Hg, { name: "ButtonIcon", strokeWidth: 2 }, (new Ti("geometryString", "visible", function (a) { return a ? c._buttonExpandedFigure : c._buttonCollapsedFigure })).rq(b)));
        a = c.bb("ButtonBorder"); a instanceof Hg && (a.stroke = null, a.fill = "rgba(0, 0, 0, 0)"); c.click = function (a, c) { a = c.diagram; if (null !== a && !a.isReadOnly) { var d = c.Ki(); null === d && (d = c.part); null !== d && (c = d.bb(b), null !== c && (a.Ca("Collapse/Expand Panel"), c.visible = !c.visible, a.ab("Collapse/Expand Panel"))) } }; return c
    });
    Ul("CheckBoxButton", function (a) {
        var b = Vl(a); a = Pl("Button", { desiredSize: new Zb(14, 14) }, Pl(Hg, { name: "ButtonIcon", geometryString: "M0 0 M0 8.85 L4.9 13.75 16.2 2.45 M16.2 16.2", strokeWidth: 2, stretch: oe, geometryStretch: ph, visible: !1 }, "" !== b ? (new Ti("visible", b)).yx() : [])); a.click = function (a, d) {
            if (d instanceof W) {
                var c = a.diagram; if (!(null === c || c.isReadOnly || "" !== b && c.model.isReadOnly)) {
                a.handled = !0; var f = d.bb("ButtonIcon"); c.Ca("checkbox"); f.visible = !f.visible; "function" === typeof d._doClick && d._doClick(a,
                    d); c.ab("checkbox")
                }
            }
        }; return a
    });
    Ul("CheckBox", function (a) {
        a = Vl(a); a = Pl("CheckBoxButton", a, { name: "Button", isActionable: !1, margin: new Hc(0, 1, 0, 0) }); var b = Pl(W, "Horizontal", a, {
            isActionable: !0, cursor: a.cursor, margin: 1, _buttonFillNormal: a._buttonFillNormal, _buttonStrokeNormal: a._buttonStrokeNormal, _buttonFillOver: a._buttonFillOver, _buttonStrokeOver: a._buttonStrokeOver, _buttonFillPressed: a._buttonFillPressed, _buttonStrokePressed: a._buttonStrokePressed, _buttonFillDisabled: a._buttonFillDisabled, mouseEnter: a.mouseEnter, mouseLeave: a.mouseLeave,
            actionDown: a.actionDown, actionUp: a.actionUp, actionCancel: a.actionCancel, actionMove: a.actionMove, click: a.click, _buttonClick: a.click
        }); a.mouseEnter = null; a.mouseLeave = null; a.actionDown = null; a.actionUp = null; a.actionCancel = null; a.actionMove = null; a.click = null; return b
    }); N.None = nh = new D(N, "None", 0); N.Default = al = new D(N, "Default", 0); N.Vertical = cl = new D(N, "Vertical", 4); N.Horizontal = bl = new D(N, "Horizontal", 5); N.Fill = oe = new D(N, "Fill", 3); N.Uniform = ph = new D(N, "Uniform", 1);
    N.UniformToFill = dl = new D(N, "UniformToFill", 2); N.FlipVertical = el = new D(N, "FlipVertical", 1); N.FlipHorizontal = fl = new D(N, "FlipHorizontal", 2); N.FlipBoth = gl = new D(N, "FlipBoth", 3); N.make = Pl; N.getBuilders = function () { var a = new Ub, b; for (b in Ql) if (b !== b.toLowerCase()) { var c = Ql.K(b); "function" === typeof c && a.add(b, c) } a.freeze(); return a }; N.defineBuilder = Ul; N.takeBuilderArgument = Vl;
    function il() { this.Fn = this.Ff = this.jg = this.Lm = this.Om = this.Nm = this.Mm = this.Tf = this.yo = this.xo = this.Vf = this.Wf = this.Yf = this.Xf = this.Uf = this.Ef = this.If = this.Df = null } il.prototype.copy = function () { var a = new il; a.Df = this.Df; a.If = this.If; a.Ef = this.Ef; a.Uf = this.Uf; a.Xf = this.Xf; a.Yf = this.Yf; a.Wf = this.Wf; a.Vf = this.Vf; a.xo = this.xo; a.yo = this.yo; a.Tf = this.Tf; a.Mm = this.Mm; a.Nm = this.Nm; a.Om = this.Om; a.Lm = this.Lm; a.jg = this.jg; a.Ff = this.Ff; a.Fn = this.Fn; return a }; il.className = "GraphObjectEventHandlers";
    function Zl() { this.Qa = [1, 0, 0, 1, 0, 0] } Zl.prototype.copy = function () { var a = new Zl; a.Qa[0] = this.Qa[0]; a.Qa[1] = this.Qa[1]; a.Qa[2] = this.Qa[2]; a.Qa[3] = this.Qa[3]; a.Qa[4] = this.Qa[4]; a.Qa[5] = this.Qa[5]; return a }; Zl.prototype.translate = function (a, b) { this.Qa[4] += this.Qa[0] * a + this.Qa[2] * b; this.Qa[5] += this.Qa[1] * a + this.Qa[3] * b }; Zl.prototype.scale = function (a, b) { this.Qa[0] *= a; this.Qa[1] *= a; this.Qa[2] *= b; this.Qa[3] *= b }; Zl.className = "STransform";
    function $l(a) { this.type = a; this.r2 = this.y2 = this.x2 = this.r1 = this.y1 = this.x1 = 0; this.bx = []; this.pattern = null } $l.prototype.addColorStop = function (a, b) { this.bx.push({ offset: a, color: b }) }; $l.className = "SGradient";
    function Nj(a, b) { this.ownerDocument = a = void 0 === b ? qa.document : b; this.Oz = "http://www.w3.org/2000/svg"; void 0 !== a && (this.Ha = this.vb("svg", { width: "1px", height: "1px", viewBox: "0 0 1 1" }), this.Ha.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg"), this.Ha.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink")); this.Zp = null; this.context = new am(this) }
    Nj.prototype.resize = function (a, b, c, d) { return this.width !== a || this.height !== b ? (this.style.width = c + "px", this.style.height = d + "px", this.Ha.setAttributeNS(null, "width", c + "px"), this.Ha.setAttributeNS(null, "height", d + "px"), this.Ha.setAttributeNS(null, "viewBox", "0 0 " + c + " " + d), this.context.lu.firstElementChild.setAttributeNS(null, "width", c + "px"), this.context.lu.firstElementChild.setAttributeNS(null, "height", d + "px"), !0) : !1 };
    Nj.prototype.vb = function (a, b, c) { a = this.ownerDocument.createElementNS(this.Oz, a); if (Ia(b)) for (var d in b) a.setAttributeNS("href" === d ? "http://www.w3.org/1999/xlink" : "", d, b[d]); void 0 !== c && (a.textContent = c); return a }; Nj.prototype.getBoundingClientRect = function () { return this.Ha.getBoundingClientRect() }; Nj.prototype.focus = function () { this.Ha.focus() }; Nj.prototype.jx = function () { this.ownerDocument = null };
    na.Object.defineProperties(Nj.prototype, { width: { configurable: !0, get: function () { return this.Ha.width.baseVal.value }, set: function (a) { this.Ha.width = a } }, height: { configurable: !0, get: function () { return this.Ha.height.baseVal.value }, set: function (a) { this.Ha.height = a } }, style: { configurable: !0, get: function () { return this.Ha.style } } }); Nj.className = "SVGSurface";
    function am(a) {
    this.vk = a; this.svg = a.Ha; this.stack = []; this.yc = []; this.fillStyle = "#000000"; this.font = "10px sans-serif"; this.globalAlpha = 1; this.lineCap = "butt"; this.lineDashOffset = 0; this.lineJoin = "miter"; this.lineWidth = 1; this.miterLimit = 10; this.shadowBlur = 0; this.shadowColor = "rgba(0, 0, 0, 0)"; this.shadowOffsetY = this.shadowOffsetX = 0; this.strokeStyle = "#000000"; this.textAlign = "start"; this.clipInsteadOfFill = !1; this.Qd = this.vp = this.tp = 0; this.lq = null; this.path = []; this.hu = !1; this.gh = null; this.hh = 0; this.Ud = new Zl;
        bm(this, 1, 0, 0, 1, 0, 0); var b = Pb++, c = this.vb("clipPath", { id: "mainClip" + b }); c.appendChild(this.vb("rect", { x: 0, y: 0, width: a.width, height: a.height })); this.lu = c; this.vk.Ha.appendChild(c); this.yc[0].setAttributeNS(null, "clip-path", "url(#mainClip" + b + ")"); this.Qz = {}
    } t = am.prototype;
    t.reset = function () {
    this.stack = []; this.yc = []; this.fillStyle = "#000000"; this.font = "10px sans-serif"; this.globalAlpha = 1; this.lineCap = "butt"; this.lineDashOffset = 0; this.lineJoin = "miter"; this.lineWidth = 1; this.miterLimit = 10; this.shadowBlur = 0; this.shadowColor = "rgba(0, 0, 0, 0)"; this.shadowOffsetY = this.shadowOffsetX = 0; this.strokeStyle = "#000000"; this.textAlign = "start"; this.clipInsteadOfFill = !1; this.Qd = this.vp = this.tp = 0; this.lq = null; this.path = []; this.Ud = new Zl; bm(this, 1, 0, 0, 1, 0, 0); var a = Pb++, b = this.vb("clipPath",
        { id: "mainClip" + a }); b.appendChild(this.vb("rect", { x: 0, y: 0, width: this.vk.width, height: this.vk.height })); this.lu = b; this.vk.Ha.appendChild(b); this.yc[0].setAttributeNS(null, "clip-path", "url(#mainClip" + a + ")")
    };
    t.arc = function (a, b, c, d, e, f, g, h) { var k = 2 * Math.PI, l = k - 1E-6, m = c * Math.cos(d), n = c * Math.sin(d), p = a + m, q = b + n, r = f ? 0 : 1; d = f ? d - e : e - d; (1E-6 < Math.abs(g - p) || 1E-6 < Math.abs(h - q)) && this.path.push(["L", p, +q]); 0 > d && (d = d % k + k); d > l ? (this.path.push(["A", c, c, 0, 1, r, a - m, b - n]), this.path.push(["A", c, c, 0, 1, r, p, q])) : 1E-6 < d && this.path.push(["A", c, c, 0, +(d >= Math.PI), r, a + c * Math.cos(e), b + c * Math.sin(e)]) }; t.beginPath = function () { this.path = [] }; t.bezierCurveTo = function (a, b, c, d, e, f) { this.path.push(["C", a, b, c, d, e, f]) }; t.clearRect = function () { };
    t.clip = function () { this.addPath("clipPath", this.path, this.Ud); this.addPath("clipPath", this.path, new Zl) }; t.closePath = function () { this.path.push(["z"]) }; t.createLinearGradient = function (a, b, c, d) { var e = new $l("linear"); e.x1 = a; e.y1 = b; e.x2 = c; e.y2 = d; return e };
    t.createPattern = function (a) { var b = ""; a instanceof HTMLCanvasElement && (b = a.toDataURL()); a instanceof HTMLImageElement && (b = a.src); var c = this.Qz; if (c[b]) return "url(#" + c[b] + ")"; var d = "PATTERN" + Pb++, e = { x: 0, y: 0, width: a.width, height: a.height, href: b }; a = this.vb("pattern", { width: a.width, height: a.height, id: d, patternUnits: "userSpaceOnUse" }); a.appendChild(this.vb("image", e)); this.svg.appendChild(a); c[b] = d; return "url(#" + d + ")" };
    t.createRadialGradient = function (a, b, c, d, e, f) { var g = new $l("radial"); g.x1 = a; g.y1 = b; g.r1 = c; g.x2 = d; g.y2 = e; g.r2 = f; return g };
    t.drawImage = function (a, b, c, d, e, f, g, h, k) {
        var l = ""; a instanceof HTMLCanvasElement && (l = a.toDataURL()); a instanceof HTMLImageElement && (l = a.src); var m = a instanceof HTMLImageElement ? a.naturalWidth : a.width, n = a instanceof HTMLImageElement ? a.naturalHeight : a.height; void 0 === d && (f = b, g = c, h = d = m, k = e = n); d = d || 0; e = e || 0; f = f || 0; g = g || 0; h = h || 0; k = k || 0; l = { x: 0, y: 0, width: m || d, height: n || e, href: l, preserveAspectRatio: "xMidYMid slice" }; K.da(d, h) && K.da(e, k) || (l.preserveAspectRatio = "none"); a = ""; h /= d; k /= e; if (0 !== f || 0 !== g) a += " translate(" +
            f + ", " + g + ")"; if (1 !== h || 1 !== k) a += " scale(" + h + ", " + k + ")"; if (0 !== b || 0 !== c) a += " translate(" + -b + ", " + -c + ")"; if (0 !== b || 0 !== c || d !== m || e !== n) f = "CLIP" + Pb++ , g = this.vb("clipPath", { id: f }), g.appendChild(this.vb("rect", { x: b, y: c, width: d, height: e })), this.svg.appendChild(g), l["clip-path"] = "url(#" + f + ")"; cm(this, "image", l, this.Ud, a); this.addElement("image", l)
    }; t.fill = function () { this.addPath("fill", this.path, this.Ud) }; t.Vd = function () { this.clipInsteadOfFill ? this.clip() : this.fill() };
    t.fillRect = function (a, b, c, d) { a = [a, b, c, d]; a = { x: a[0], y: a[1], width: a[2], height: a[3] }; cm(this, "fill", a, this.Ud); this.addElement("rect", a) }; t.fillText = function (a, b, c) { a = [a, b, c]; b = this.textAlign; "left" === b ? b = "start" : "right" === b ? b = "end" : "center" === b && (b = "middle"); b = { x: a[1], y: a[2], style: "font: " + this.font, "text-anchor": b }; cm(this, "fill", b, this.Ud); this.addElement("text", b, a[0]) }; t.lineTo = function (a, b) { this.path.push(["L", a, b]) }; t.moveTo = function (a, b) { this.path.push(["M", a, b]) };
    t.quadraticCurveTo = function (a, b, c, d) { this.path.push(["Q", a, b, c, d]) }; t.rect = function (a, b, c, d) { this.path.push(["M", a, b], ["L", a + c, b], ["L", a + c, b + d], ["L", a, b + d], ["z"]) };
    t.restore = function () { this.Ud = this.stack.pop(); this.path = this.stack.pop(); var a = this.stack.pop(); this.fillStyle = a.fillStyle; this.font = a.font; this.globalAlpha = a.globalAlpha; this.lineCap = a.lineCap; this.lineDashOffset = a.lineDashOffset; this.lineJoin = a.lineJoin; this.lineWidth = a.lineWidth; this.miterLimit = a.miterLimit; this.shadowBlur = a.shadowBlur; this.shadowColor = a.shadowColor; this.shadowOffsetX = a.shadowOffsetX; this.shadowOffsetY = a.shadowOffsetY; this.strokeStyle = a.strokeStyle; this.textAlign = a.textAlign };
    t.save = function () { this.stack.push({ fillStyle: this.fillStyle, font: this.font, globalAlpha: this.globalAlpha, lineCap: this.lineCap, lineDashOffset: this.lineDashOffset, lineJoin: this.lineJoin, lineWidth: this.lineWidth, miterLimit: this.miterLimit, shadowBlur: this.shadowBlur, shadowColor: this.shadowColor, shadowOffsetX: this.shadowOffsetX, shadowOffsetY: this.shadowOffsetY, strokeStyle: this.strokeStyle, textAlign: this.textAlign }); for (var a = [], b = 0; b < this.path.length; b++)a.push(this.path[b]); this.stack.push(a); this.stack.push(this.Ud.copy()) };
    t.setTransform = function (a, b, c, d, e, f) { 1 === a && 0 === b && 0 === c && 1 === d && 0 === e && 0 === f || bm(this, a, b, c, d, e, f) }; t.scale = function (a, b) { this.Ud.scale(a, b) }; t.translate = function (a, b) { this.Ud.translate(a, b) }; t.transform = function () { }; t.stroke = function () { this.addPath("stroke", this.path, this.Ud) }; t.$i = function () { this.clipInsteadOfFill || this.stroke() }; t.vb = function (a, b, c) { return this.vk.vb(a, b, c) };
    t.addElement = function (a, b, c) { a = this.vb(a, b, c); 0 < this.yc.length ? this.yc[this.yc.length - 1].appendChild(a) : this.svg.appendChild(a); return this.lq = a };
    function cm(a, b, c, d, e) {
    1 !== a.globalAlpha && (c.opacity = a.globalAlpha); "fill" === b ? (a.fillStyle instanceof $l ? c.fill = dm(a, a.fillStyle) : (/^rgba\(/.test(a.fillStyle) && (b = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(a.fillStyle), c.fill = "rgb(" + b[1] + "," + b[2] + "," + b[3] + ")", c["fill-opacity"] = b[4]), c.fill = a.fillStyle), c.stroke = "none") : "stroke" === b && (c.fill = "none", a.strokeStyle instanceof $l ? c.stroke = dm(a, a.strokeStyle) : (/^rgba\(/.test(a.strokeStyle) && (b = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(a.strokeStyle),
        c.stroke = "rgb(" + b[1] + "," + b[2] + "," + b[3] + ")", c["stroke-opacity"] = b[4]), c.stroke = a.strokeStyle), c["stroke-width"] = a.lineWidth, c["stroke-linecap"] = a.lineCap, c["stroke-linejoin"] = a.lineJoin, c["stroke-miterlimit"] = a.miterLimit); a = d.Qa; a = "matrix(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")"; void 0 !== e && (a += e); c.transform = a
    }
    function dm(a, b) {
        var c = "GRAD" + Pb++; if ("linear" === b.type) var d = a.vb("linearGradient", { x1: b.x1, x2: b.x2, y1: b.y1, y2: b.y2, id: c, gradientUnits: "userSpaceOnUse" }); else if ("radial" === b.type) d = a.vb("radialGradient", { x1: b.x1, x2: b.x2, y1: b.y1, y2: b.y2, r1: b.r1, r2: b.r2, id: c }); else throw Error("invalid gradient"); var e = b.bx; b = e.length; for (var f = [], g = 0; g < b; g++) {
            var h = e[g], k = h.color; h = { offset: h.offset, "stop-color": k }; /^rgba\(/.test(k) && (k = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(k),
                h["stop-color"] = "rgb(" + k[1] + "," + k[2] + "," + k[3] + ")", h["stop-opacity"] = k[4]); f.push(h)
        } f.sort(function (a, b) { return a.offset > b.offset ? 1 : -1 }); for (e = 0; e < b; e++)d.appendChild(a.vb("stop", f[e])); a.svg.appendChild(d); return "url(#" + c + ")"
    }
    t.addPath = function (a, b, c) {
        for (var d = [], e = 0; e < b.length; e++) { var f = Ma(b[e]), g = [f.shift()]; if ("A" === g[0]) g.push(f.shift() + "," + f.shift(), f.shift(), f.shift() + "," + f.shift(), f.shift() + "," + f.shift()); else for (; f.length;)g.push(f.shift() + "," + f.shift()); d.push(g.join(" ")) } b = { d: d.join(" ") }; "stroke" === a && this.hu && (b["stroke-dasharray"] = this.gh.toString(), b["stroke-dashoffset"] = this.hh); cm(this, a, b, c); "clipPath" === a ? (a = "CLIP" + Pb++ , c = this.vb("clipPath", { id: a }), c.appendChild(this.vb("path", b)), this.svg.appendChild(c),
            0 < this.yc.length && this.yc[this.yc.length - 1].setAttributeNS(null, "clip-path", "url(#" + a + ")")) : this.addElement("path", b)
    }; function bm(a, b, c, d, e, f, g) { var h = new Zl; h.Qa = [b, c, d, e, f, g]; b = {}; cm(a, "g", b, h); h = a.addElement("g", b); a.yc.push(h) }
    t.Aq = function () {
        if (0 !== this.shadowOffsetX || 0 !== this.shadowOffsetY || 0 !== this.shadowBlur) {
            var a = "SHADOW" + Pb++, b = this.addElement("filter", { id: a, x: "-100%", y: "-100%", width: "300%", height: "300%" }, null); var c = this.vb("feGaussianBlur", { "in": "SourceAlpha", result: "blur", vA: this.shadowBlur / 2 }); var d = this.vb("feFlood", { "in": "blur", result: "flood", "flood-color": this.shadowColor }); var e = this.vb("feComposite", { "in": "flood", in2: "blur", operator: "in", result: "comp" }); var f = this.vb("feOffset", {
                "in": "comp", result: "offsetBlur",
                dx: this.shadowOffsetX, dy: this.shadowOffsetY
            }); var g = this.vb("feMerge", {}); g.appendChild(this.vb("feMergeNode", { "in": "offsetBlur" })); g.appendChild(this.vb("feMergeNode", { "in": "SourceGraphic" })); b.appendChild(c); b.appendChild(d); b.appendChild(e); b.appendChild(f); b.appendChild(g); 0 < this.yc.length && this.yc[this.yc.length - 1].setAttributeNS(null, "filter", "url(#" + a + ")")
        }
    }; t.Uv = function (a, b, c) { this.tp = a; this.vp = b; this.Qd = c }; function yl(a) { a.shadowOffsetX = 0; a.shadowOffsetY = 0; a.shadowBlur = 0 }
    function xl(a) { a.shadowOffsetX = a.tp; a.shadowOffsetY = a.vp; a.shadowBlur = a.Qd } t.Us = function (a, b) { this.hu = !0; this.gh = a; this.hh = b }; t.Ss = function () { this.hu = !1 }; t.Uc = function () { }; t.Mx = function () { }; am.prototype.rotate = function () { }; am.prototype.getImageData = function () { return null }; am.prototype.measureText = function () { return null }; am.className = "SVGContext";
    P.prototype.nt = function (a) { var b = new Nj(this, qa.document); void 0 === a && (a = new xb); var c = this; return Hk(this, function (a, e) { a = Ik(c, a, "SVG", b); a = null !== a ? a.svg : null; return "function" === typeof e ? (e(a), null) : a }, a) }; P.prototype.makeSvg = P.prototype.nt; P.prototype.tv = function (a) { return this.nt(a) }; P.prototype.makeSVG = P.prototype.tv;
    N.prototype.kx = function (a, b) {
        if (!(a instanceof am)) return !1; if (!this.visible) return !0; var c = null, d = a.lq; if (this instanceof W && (this.type === W.TableRow || this.type === W.TableColumn)) return vl(this, a, b), !0; var e = this.wb; if (0 === e.width || 0 === e.height || isNaN(e.x) || isNaN(e.y)) return !0; var f = this.transform, g = this.panel; 0 !== (this.I & 4096) === !0 && wl(this); var h = 0 !== (this.I & 256), k = !1; this instanceof Kh && (a.font = this.font); if (h) {
            k = g.ae() ? g.naturalBounds : g.actualBounds; if (null !== this.md) {
                var l = this.md; var m = l.x; var n =
                    l.y; var p = l.width; l = l.height
            } else m = Math.max(e.x, k.x), n = Math.max(e.y, k.y), p = Math.min(e.right, k.right) - m, l = Math.min(e.bottom, k.bottom) - n; if (m > e.width + e.x || e.x > k.width + k.x || n > e.height + e.y || e.y > k.height + k.y) return !0; k = !0; bm(a, 1, 0, 0, 1, 0, 0); a.save(); a.beginPath(); a.rect(m, n, p, l); a.clip()
        } if (this.vg() && !this.isVisible()) return !0; a.Ud.Qa = [1, 0, 0, 1, 0, 0]; this instanceof Kh && 1 < this.lineCount && bm(a, 1, 0, 0, 1, 0, 0); m = !1; this.vg() && this.isShadowed && b.Ge("drawShadows") && (n = this.vi, a.Uv(n.x * b.scale * b.Pb, n.y * b.scale *
            b.Pb, this.Qd), xl(a), a.shadowColor = this.Mj); n = !1; this.part && b.Ge("drawShadows") && (n = this.part.isShadowed); !0 === this.shadowVisible ? (xl(a), !1 === m && n && (bm(a, 1, 0, 0, 1, 0, 0), a.Aq(), m = !0)) : !1 === this.shadowVisible && yl(a); p = this.naturalBounds; null !== this.areaBackground && (yi(this, a, this.areaBackground, !0, !0, p, e), !1 === m && n && (bm(a, 1, 0, 0, 1, 0, 0), a.Aq(), m = !0), this.areaBackground instanceof zl && this.areaBackground.type === Al ? (a.beginPath(), a.rect(e.x, e.y, e.width, e.height), a.Vd(this.areaBackground)) : a.fillRect(e.x, e.y,
                e.width, e.height)); this instanceof W ? bm(a, f.m11, f.m12, f.m21, f.m22, f.dx, f.dy) : a.Ud.Qa = [f.m11, f.m12, f.m21, f.m22, f.dx, f.dy]; if (null !== this.background) {
                !1 === m && n && (bm(a, 1, 0, 0, 1, 0, 0), a.Aq(), m = !0); var q = this.naturalBounds; l = f = 0; var r = q.width; q = q.height; var u = 0; this instanceof Hg && (q = this.geometry.bounds, f = q.x, l = q.y, r = q.width, q = q.height, u = this.strokeWidth); yi(this, a, this.background, !0, !1, p, e); this.background instanceof zl && this.background.type === Al ? (a.beginPath(), a.rect(f - u / 2, l - u / 2, r + u, q + u), a.Vd(this.background)) :
                    a.fillRect(f - u / 2, l - u / 2, r + u, q + u)
                } n && (null !== this.background || null !== this.areaBackground || null !== g && 0 !== (g.I & 512) || null !== g && (g.type === W.Auto || g.type === W.Spot) && g.Bb() !== this) ? (Bl(this, !0), null === this.shadowVisible && yl(a)) : Bl(this, !1); this.Gi(a, b); n && 0 !== (this.I & 512) === !0 && xl(a); this.vg() && n && yl(a); h && (a.restore(), k && a.yc.pop()); this instanceof W && (c = a.yc.pop()); !0 === m && a.yc.pop(); this instanceof Kh && 1 < this.lineCount && (c = a.yc.pop()); null !== a.vk.Zp && (null === c && (d === a.lq ? (bm(a, 1, 0, 0, 1, 0, 0), c = a.yc.pop()) :
                    c = a.lq), a.vk.Zp(this, c)); this.svg = c; return !0
    }; function Jk(a, b) { this.ownerDocument = b = void 0 === b ? qa.document : b; this.Zp = null; b = b.createElement("canvas"); b.tabIndex = 0; this.Ha = b; this.Ha.innerHTML = "This text is displayed if your browser does not support the Canvas HTML element."; this.context = new Dl(b); b.D = a } Jk.prototype.resize = function (a, b, c, d) { return this.width !== a || this.height !== b ? (this.width = a, this.height = b, this.style.width = c + "px", this.style.height = d + "px", !0) : !1 };
    Jk.prototype.toDataURL = function (a, b) { return this.Ha.toDataURL(a, b) }; Jk.prototype.getBoundingClientRect = function () { return this.Ha.getBoundingClientRect() }; Jk.prototype.focus = function () { this.Ha.focus() }; Jk.prototype.jx = function () { this.ownerDocument = this.Ha.D = null };
    na.Object.defineProperties(Jk.prototype, { width: { configurable: !0, get: function () { return this.Ha.width }, set: function (a) { this.Ha.width = a } }, height: { configurable: !0, get: function () { return this.Ha.height }, set: function (a) { this.Ha.height = a } }, style: { configurable: !0, get: function () { return this.Ha.style } } }); Jk.className = "CanvasSurface";
    function Dl(a) { a.getContext && a.getContext("2d") || v("Browser does not support HTML Canvas Element"); this.Y = a.getContext("2d"); this.Nt = this.Pt = this.Ot = ""; this.bn = !1; this.Qd = this.vp = this.tp = 0 } t = Dl.prototype; t.Mx = function (a) { this.Y.imageSmoothingEnabled = a }; t.arc = function (a, b, c, d, e, f) { this.Y.arc(a, b, c, d, e, f) }; t.beginPath = function () { this.Y.beginPath() }; t.bezierCurveTo = function (a, b, c, d, e, f) { this.Y.bezierCurveTo(a, b, c, d, e, f) }; t.clearRect = function (a, b, c, d) { this.Y.clearRect(a, b, c, d) }; t.clip = function () { this.Y.clip() };
    t.closePath = function () { this.Y.closePath() }; t.createLinearGradient = function (a, b, c, d) { return this.Y.createLinearGradient(a, b, c, d) }; t.createPattern = function (a, b) { return this.Y.createPattern(a, b) }; t.createRadialGradient = function (a, b, c, d, e, f) { return this.Y.createRadialGradient(a, b, c, d, e, f) }; t.drawImage = function (a, b, c, d, e, f, g, h, k) { void 0 === d ? this.Y.drawImage(a, b, c) : this.Y.drawImage(a, b, c, d, e, f, g, h, k) }; t.fill = function () { this.Y.fill() }; t.fillRect = function (a, b, c, d) { this.Y.fillRect(a, b, c, d) };
    t.fillText = function (a, b, c) { this.Y.fillText(a, b, c) }; t.getImageData = function (a, b, c, d) { return this.Y.getImageData(a, b, c, d) }; t.lineTo = function (a, b) { this.Y.lineTo(a, b) }; t.measureText = function (a) { return this.Y.measureText(a) }; t.moveTo = function (a, b) { this.Y.moveTo(a, b) }; t.quadraticCurveTo = function (a, b, c, d) { this.Y.quadraticCurveTo(a, b, c, d) }; t.rect = function (a, b, c, d) { this.Y.rect(a, b, c, d) }; t.restore = function () { this.Y.restore() }; Dl.prototype.rotate = function (a) { this.Y.rotate(a) }; t = Dl.prototype; t.save = function () { this.Y.save() };
    t.setTransform = function (a, b, c, d, e, f) { this.Y.setTransform(a, b, c, d, e, f) }; t.scale = function (a, b) { this.Y.scale(a, b) }; t.stroke = function () { this.Y.stroke() }; t.transform = function (a, b, c, d, e, f) { 1 === a && 0 === b && 0 === c && 1 === d && 0 === e && 0 === f || this.Y.transform(a, b, c, d, e, f) }; t.translate = function (a, b) { this.Y.translate(a, b) };
    t.Vd = function (a) { if (a instanceof zl && a.type === Al) { var b = a.Kk; a = a.Qt; a > b ? (this.scale(b / a, 1), this.translate((a - b) / 2, 0)) : b > a && (this.scale(1, a / b), this.translate(0, (b - a) / 2)); this.bn ? this.clip() : this.fill(); a > b ? (this.translate(-(a - b) / 2, 0), this.scale(1 / (b / a), 1)) : b > a && (this.translate(0, -(b - a) / 2), this.scale(1, 1 / (a / b))) } else this.bn ? this.clip() : this.fill() }; t.$i = function () { this.bn || this.stroke() }; t.Uv = function (a, b, c) { this.tp = a; this.vp = b; this.Qd = c };
    t.Us = function (a, b) { var c = this.Y; void 0 !== c.setLineDash && (c.setLineDash(a), c.lineDashOffset = b) }; t.Ss = function () { var a = this.Y; void 0 !== a.setLineDash && (a.setLineDash(em), a.lineDashOffset = 0) }; t.Uc = function (a) { a && (this.Ot = ""); this.Nt = this.Pt = "" };
    na.Object.defineProperties(Dl.prototype, {
        fillStyle: { configurable: !0, get: function () { return this.Y.fillStyle }, set: function (a) { this.Nt !== a && (this.Nt = this.Y.fillStyle = a) } }, font: { configurable: !0, get: function () { return this.Y.font }, set: function (a) { this.Ot !== a && (this.Ot = this.Y.font = a) } }, globalAlpha: { configurable: !0, get: function () { return this.Y.globalAlpha }, set: function (a) { this.Y.globalAlpha = a } }, lineCap: {
            configurable: !0, get: function () { return this.Y.lineCap },
            set: function (a) { this.Y.lineCap = a }
        }, lineDashOffset: { configurable: !0, get: function () { return this.Y.lineDashOffset }, set: function (a) { this.Y.lineDashOffset = a } }, lineJoin: { configurable: !0, get: function () { return this.Y.lineJoin }, set: function (a) { this.Y.lineJoin = a } }, lineWidth: { configurable: !0, get: function () { return this.Y.lineWidth }, set: function (a) { this.Y.lineWidth = a } }, miterLimit: {
            configurable: !0, get: function () { return this.Y.miterLimit }, set: function (a) {
                this.Y.miterLimit =
                a
            }
        }, shadowBlur: { configurable: !0, get: function () { return this.Y.shadowBlur }, set: function (a) { this.Y.shadowBlur = a } }, shadowColor: { configurable: !0, get: function () { return this.Y.shadowColor }, set: function (a) { this.Y.shadowColor = a } }, shadowOffsetX: { configurable: !0, get: function () { return this.Y.shadowOffsetX }, set: function (a) { this.Y.shadowOffsetX = a } }, shadowOffsetY: {
            configurable: !0, get: function () { return this.Y.shadowOffsetY }, set: function (a) {
                this.Y.shadowOffsetY =
                a
            }
        }, strokeStyle: { configurable: !0, get: function () { return this.Y.strokeStyle }, set: function (a) { this.Pt !== a && (this.Pt = this.Y.strokeStyle = a) } }, textAlign: { configurable: !0, get: function () { return this.Y.textAlign }, set: function (a) { this.Y.textAlign = a } }, imageSmoothingEnabled: { configurable: !0, get: function () { return this.Y.imageSmoothingEnabled }, set: function (a) { this.Y.imageSmoothingEnabled = a } }, clipInsteadOfFill: {
            configurable: !0, get: function () { return this.bn },
            set: function (a) { this.bn = a }
        }
    }); var em = Object.freeze([]); Dl.className = "CanvasSurfaceContext"; function fm() { this.ca = this.w = this.L = this.l = 0 } fm.className = "ColorNumbers";
    function zl(a) {
    E && 1 < arguments.length && v("Brush constructor can take at most one optional argument, the Brush type."); gm || (hm(), gm = !0); qb(this); this.u = !1; void 0 === a ? (this.wa = Cl, this.Jk = "black") : "string" === typeof a ? (this.wa = Cl, E && !im(a) && v('Color "' + a + '" is not a valid color string for Brush constructor'), this.Jk = a) : (E && tb(a, zl, zl, "constructor:type"), this.wa = a, this.Jk = "black"); var b = this.wa; b === Fl ? (this.Kl = gd, this.Xk = td) : this.Xk = b === Al ? this.Kl = qd : this.Kl = ed; this.Es = 0; this.sr = NaN; this.fe = this.ns = this.ee =
        null; this.Qt = this.Kk = 0
    } zl.prototype.copy = function () { var a = new zl; a.wa = this.wa; a.Jk = this.Jk; a.Kl = this.Kl.J(); a.Xk = this.Xk.J(); a.Es = this.Es; a.sr = this.sr; null !== this.ee && (a.ee = this.ee.copy()); a.ns = this.ns; return a }; t = zl.prototype; t.freeze = function () { this.u = !0; null !== this.ee && this.ee.freeze(); return this }; t.ja = function () { Object.isFrozen(this) && v("cannot thaw constant: " + this); this.u = !1; null !== this.ee && this.ee.ja(); return this }; t.hb = function (a) { a.classType === zl ? this.type = a : Fa(this, a) };
    t.toString = function () { var a = "Brush("; if (this.type === Cl) a += this.color; else if (a = this.type === Fl ? a + "Linear " : this.type === Al ? a + "Radial " : this.type === El ? a + "Pattern " : a + "(unknown) ", a += this.start + " " + this.end, null !== this.colorStops) for (var b = this.colorStops.iterator; b.next();)a += " " + b.key + ":" + b.value; return a + ")" };
    t.addColorStop = function (a, b) { this.u && ya(this); ("number" !== typeof a || !isFinite(a) || 1 < a || 0 > a) && Ca(a, "0 <= loc <= 1", zl, "addColorStop:loc"); z(b, "string", zl, "addColorStop:color"); E && !im(b) && v('Color "' + b + '" is not a valid color string for Brush.addColorStop'); null === this.ee && (this.ee = new Ub); this.ee.add(a, b); this.wa === Cl && (this.type = Fl); this.fe = null; return this };
    function im(a) { if ("black" === a) return !0; if ("" === a) return !1; E && z(a, "string", zl, "isValidColor"); gm || (hm(), gm = !0); var b = jm; if (null === b) return !0; b.fillStyle = "#000000"; var c = b.fillStyle; b.fillStyle = a; if (b.fillStyle !== c) return !0; b.fillStyle = "#FFFFFF"; c = b.fillStyle; b.fillStyle = a; return b.fillStyle !== c }
    t.Iz = function (a, b) { this.u && ya(this); a = void 0 === a || "number" !== typeof a ? .2 : a; b = void 0 === b ? km : b; if (this.type === Cl) lm(this.color), this.color = mm(a, b); else if ((this.type === Fl || this.type === Al) && null !== this.colorStops) for (var c = this.colorStops.iterator; c.next();)lm(c.value), this.addColorStop(c.key, mm(a, b)); return this }; function nm(a, b, c) { b = void 0 === b || "number" !== typeof b ? .2 : b; c = void 0 === c ? km : c; lm(a); return mm(b, c) }
    t.Ey = function (a, b) { this.u && ya(this); a = void 0 === a || "number" !== typeof a ? .2 : a; b = void 0 === b ? km : b; if (this.type === Cl) lm(this.color), this.color = mm(-a, b); else if ((this.type === Fl || this.type === Al) && null !== this.colorStops) for (var c = this.colorStops.iterator; c.next();)lm(c.value), this.addColorStop(c.key, mm(-a, b)); return this }; function om(a, b, c) { b = void 0 === b || "number" !== typeof b ? .2 : b; c = void 0 === c ? km : c; lm(a); return mm(-b, c) }
    function pm(a, b, c) { lm(a); a = qm.l; var d = qm.L, e = qm.w, f = qm.ca; lm(b); void 0 === c && (c = .5); return "rgba(" + Math.round((qm.l - a) * c + a) + ", " + Math.round((qm.L - d) * c + d) + ", " + Math.round((qm.w - e) * c + e) + ", " + Math.round((qm.ca - f) * c + f) + ")" }
    t.vx = function () { if (this.type === Cl) return rm(this.color); if ((this.type === Fl || this.type === Al) && null !== this.colorStops) { var a = this.colorStops; if (this.type === Al) return rm(a.first().value); if (null !== a.get(.5)) return rm(a.get(.5)); if (2 === a.count) return a = a.Oa(), rm(pm(a[0].value, a[1].value)); for (var b = a.iterator, c = -1, d = -1, e = 1, f = 1; b.next();) { var g = b.key, h = Math.abs(.5 - b.key); e > f && h < e ? (c = g, e = h) : f >= e && h < f && (d = g, f = h) } c > d && (c = [d, d = c][0]); b = d - c; return rm(pm(a.get(c), a.get(d), 1 - e / b)) } return !1 };
    function rm(a) { if (null === a) return null; if (a instanceof zl) return a.vx(); lm(a); return 128 > (299 * qm.l + 587 * qm.L + 114 * qm.w) / 1E3 }
    function mm(a, b) {
        switch (b) {
            case km: var c = 100 * sm(qm.l); b = 100 * sm(qm.L); var d = 100 * sm(qm.w); tm.l = .4124564 * c + .3575761 * b + .1804375 * d; tm.L = .2126729 * c + .7151522 * b + .072175 * d; tm.w = .0193339 * c + .119192 * b + .9503041 * d; tm.ca = qm.ca; c = um(tm.l / vm[0]); b = um(tm.L / vm[1]); d = um(tm.w / vm[2]); wm.l = 116 * b - 16; wm.L = 500 * (c - b); wm.w = 200 * (b - d); wm.ca = tm.ca; wm.l = Math.min(100, Math.max(0, wm.l + 100 * a)); a = (wm.l + 16) / 116; c = a - wm.w / 200; tm.l = vm[0] * xm(wm.L / 500 + a); tm.L = vm[1] * (wm.l > ym * zm ? Math.pow(a, 3) : wm.l / ym); tm.w = vm[2] * xm(c); tm.ca = wm.ca; a = -.969266 *
                tm.l + 1.8760108 * tm.L + .041556 * tm.w; c = .0556434 * tm.l + -.2040259 * tm.L + 1.0572252 * tm.w; qm.l = 255 * Am((3.2404542 * tm.l + -1.5371385 * tm.L + -.4985314 * tm.w) / 100); qm.L = 255 * Am(a / 100); qm.w = 255 * Am(c / 100); qm.ca = tm.ca; qm.l = Math.round(qm.l); 255 < qm.l ? qm.l = 255 : 0 > qm.l && (qm.l = 0); qm.L = Math.round(qm.L); 255 < qm.L ? qm.L = 255 : 0 > qm.L && (qm.L = 0); qm.w = Math.round(qm.w); 255 < qm.w ? qm.w = 255 : 0 > qm.w && (qm.w = 0); return "rgba(" + qm.l + ", " + qm.L + ", " + qm.w + ", " + qm.ca + ")"; case Bm: b = qm.l / 255; d = qm.L / 255; var e = qm.w / 255, f = Math.max(b, d, e), g = Math.min(b, d, e), h =
                    f - g; g = (f + g) / 2; if (0 === h) c = b = 0; else { switch (f) { case b: c = (d - e) / h % 6; break; case d: c = (e - b) / h + 2; break; case e: c = (b - d) / h + 4 }c *= 60; 0 > c && (c += 360); b = h / (1 - Math.abs(2 * g - 1)) } Cm.l = Math.round(c); Cm.L = Math.round(100 * b); Cm.w = Math.round(100 * g); Cm.ca = qm.ca; Cm.w = Math.min(100, Math.max(0, Cm.w + 100 * a)); return "hsla(" + Cm.l + ", " + Cm.L + "%, " + Cm.w + "%, " + Cm.ca + ")"; default: return v("Unknown color space: " + b), "rgba(0, 0, 0, 1)"
        }
    }
    function lm(a) { gm || (hm(), gm = !0); var b = jm; if (null !== b) { b.clearRect(0, 0, 1, 1); b.fillStyle = "#000000"; var c = b.fillStyle; b.fillStyle = a; b.fillStyle !== c ? (b.fillRect(0, 0, 1, 1), a = b.getImageData(0, 0, 1, 1).data, qm.l = a[0], qm.L = a[1], qm.w = a[2], qm.ca = a[3] / 255) : (b.fillStyle = "#FFFFFF", c = b.fillStyle, b.fillStyle = a, b.fillStyle === c && E && v('Color "' + a + '" is not a valid color string for RGBA color conversion'), qm.l = 0, qm.L = 0, qm.w = 0, qm.ca = 1) } } function sm(a) { a /= 255; return .04045 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4) }
    function Am(a) { return .0031308 >= a ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - .055 } function um(a) { return a > zm ? Math.pow(a, 1 / 3) : (ym * a + 16) / 116 } function xm(a) { var b = a * a * a; return b > zm ? b : (116 * a - 16) / ym } function Wl(a, b) { "string" === typeof a ? E && !im(a) && v('Color "' + a + '" is not a valid color string for ' + b) : a instanceof zl || v("Value for " + b + " must be a color string or a Brush, not " + a) } function hm() { jm = Ih ? (new Jk(null)).context : null }
    na.Object.defineProperties(zl.prototype, {
        type: { configurable: !0, get: function () { return this.wa }, set: function (a) { this.u && ya(this, a); tb(a, zl, zl, "type"); this.wa = a; this.start.Nb() && (a === Fl ? this.start = gd : a === Al && (this.start = qd)); this.end.Nb() && (a === Fl ? this.end = td : a === Al && (this.end = qd)); this.fe = null } }, color: {
            configurable: !0, get: function () { return this.Jk }, set: function (a) {
            this.u && ya(this, a); E && !im(a) && v('Color "' + a + '" is not a valid color string for Brush.color'); this.Jk = a; this.fe =
                null
            }
        }, start: { configurable: !0, get: function () { return this.Kl }, set: function (a) { this.u && ya(this, a); w(a, M, zl, "start"); this.Kl = a.J(); this.fe = null } }, end: { configurable: !0, get: function () { return this.Xk }, set: function (a) { this.u && ya(this, a); w(a, M, zl, "end"); this.Xk = a.J(); this.fe = null } }, startRadius: { configurable: !0, get: function () { return this.Es }, set: function (a) { this.u && ya(this, a); B(a, zl, "startRadius"); 0 > a && Ca(a, ">= zero", zl, "startRadius"); this.Es = a; this.fe = null } }, endRadius: {
            configurable: !0,
            enumerable: !0, get: function () { return this.sr }, set: function (a) { this.u && ya(this, a); B(a, zl, "endRadius"); 0 > a && Ca(a, ">= zero", zl, "endRadius"); this.sr = a; this.fe = null }
        }, colorStops: { configurable: !0, get: function () { return this.ee }, set: function (a) { this.u && ya(this, a); E && w(a, Ub, zl, "colorStops"); this.ee = a; this.fe = null } }, pattern: { configurable: !0, get: function () { return this.ns }, set: function (a) { this.u && ya(this, a); this.ns = a; this.fe = null } }
    }); zl.prototype.isDark = zl.prototype.vx;
    zl.prototype.darkenBy = zl.prototype.Ey; zl.prototype.lightenBy = zl.prototype.Iz; zl.prototype.addColorStop = zl.prototype.addColorStop; var zm = 216 / 24389, ym = 24389 / 27, vm = [95.047, 100, 108.883], jm = null, qm = new fm, Cm = new fm, tm = new fm, wm = new fm, gm = !1; zl.className = "Brush"; var Cl; zl.Solid = Cl = new D(zl, "Solid", 0); var Fl; zl.Linear = Fl = new D(zl, "Linear", 1); var Al; zl.Radial = Al = new D(zl, "Radial", 2); var El; zl.Pattern = El = new D(zl, "Pattern", 4); var km; zl.Lab = km = new D(zl, "Lab", 5); var Bm; zl.HSL = Bm = new D(zl, "HSL", 6);
    zl.randomColor = function (a, b) {
    void 0 === a && (a = 128); E && (B(a, zl, "randomColor:min"), (0 > a || 255 < a) && Ca(a, "0 <= min <= 255", zl, "randomColor:min")); void 0 === b && (b = Math.max(a, 255)); E && (B(b, zl, "randomColor:max"), (b < a || 255 < b) && Ca(b, "min <= max <= 255", zl, "randomColor:max")); var c = Math.abs(b - a); b = Math.floor(a + Math.random() * c).toString(16); var d = Math.floor(a + Math.random() * c).toString(16); a = Math.floor(a + Math.random() * c).toString(16); 2 > b.length && (b = "0" + b); 2 > d.length && (d = "0" + d); 2 > a.length && (a = "0" + a); return "#" + b + d +
        a
    }; zl.isValidColor = im; zl.lighten = function (a) { return nm(a) }; zl.lightenBy = nm; zl.darken = function (a) { return om(a) }; zl.darkenBy = om; zl.mix = pm; zl.isDark = rm; function Tl() { this.name = "Base" } Tl.prototype.measure = function () { }; Tl.prototype.Lz = function (a, b, c, d, e) { a.measure(b, c, d, e) }; Tl.prototype.arrange = function () { }; Tl.prototype.ty = function (a, b, c, d, e, f) { a.arrange(b, c, d, e, f) }; na.Object.defineProperties(Tl.prototype, { classType: { configurable: !0, get: function () { return W } } });
    Tl.prototype.arrangeElement = Tl.prototype.ty; Tl.prototype.measureElement = Tl.prototype.Lz; Tl.className = "PanelLayout"; function Dm() { this.name = "Base"; this.name = "Position" } ma(Dm, Tl);
    Dm.prototype.measure = function (a, b, c, d, e, f, g) { var h = d.length; a = Em(a); for (var k = 0; k < h; k++) { var l = d[k]; if (l.visible || l === a) { var m = l.margin, n = m.right + m.left; m = m.top + m.bottom; l.measure(b, c, f, g); var p = l.measuredBounds; n = Math.max(p.width + n, 0); m = Math.max(p.height + m, 0); p = l.position.x; var q = l.position.y; isFinite(p) || (p = 0); isFinite(q) || (q = 0); l instanceof Hg && l.isGeometryPositioned && (l = l.strokeWidth / 2, p -= l, q -= l); Mc(e, p, q, n, m) } } };
    Dm.prototype.arrange = function (a, b, c) { var d = b.length, e = a.padding; a = c.x - e.left; c = c.y - e.top; for (e = 0; e < d; e++) { var f = b[e], g = f.measuredBounds, h = f.margin, k = f.position.x, l = f.position.y; k = isNaN(k) ? -a : k - a; l = isNaN(l) ? -c : l - c; if (f instanceof Hg && f.isGeometryPositioned) { var m = f.strokeWidth / 2; k -= m; l -= m } f.visible && f.arrange(k + h.left, l + h.top, g.width, g.height) } }; function Fm() { this.name = "Base"; this.name = "Horizontal" } ma(Fm, Tl);
    Fm.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = d.length; b = Qa(); f = Em(a); for (var k = 0; k < h; k++) { var l = d[k]; if (l.visible || l === f) { var m = ql(l, !1); if (m !== nh && m !== bl) b.push(l); else { l.measure(Infinity, c, 0, g); m = l.margin; l = l.measuredBounds; var n = Math.max(l.height + m.top + m.bottom, 0); e.width += Math.max(l.width + m.right + m.left, 0); e.height = Math.max(e.height, n) } } } d = b.length; a.desiredSize.height ? c = Math.min(a.desiredSize.height, a.maxSize.height) : 0 !== e.height && (c = Math.min(e.height, a.maxSize.height)); for (a = 0; a < d; a++)if (k =
            b[a], k.visible || k === f) m = k.margin, h = m.right + m.left, m = m.top + m.bottom, k.measure(Infinity, c, 0, g), k = k.measuredBounds, m = Math.max(k.height + m, 0), e.width += Math.max(k.width + h, 0), e.height = Math.max(e.height, m); Ta(b)
    };
    Fm.prototype.arrange = function (a, b, c) {
        for (var d = b.length, e = a.padding, f = e.top, g = a.isOpposite, h = g ? c.width : e.left, k = 0; k < d; k++) {
            var l = f, m = b[k]; if (m.visible) {
                var n = m.measuredBounds, p = m.margin, q = p.top + p.bottom, r = f + e.bottom, u = n.height, x = ql(m, !1); if (isNaN(m.desiredSize.height) && x === oe || x === cl) u = Math.max(c.height - q - r, 0); q = u + q + r; r = m.alignment; r.Cb() && (r = a.defaultAlignment); r.Za() || (r = qd); g && (h -= n.width + p.left + p.right); m.arrange(h + r.offsetX + p.left, l + r.offsetY + p.top + (c.height * r.y - q * r.y), n.width, u); g || (h += n.width +
                    p.left + p.right)
            }
        }
    }; function Gm() { this.name = "Base"; this.name = "Vertical" } ma(Gm, Tl);
    Gm.prototype.measure = function (a, b, c, d, e, f) {
        var g = d.length; c = Qa(); for (var h = Em(a), k = 0; k < g; k++) { var l = d[k]; if (l.visible || l === h) { var m = ql(l, !1); if (m !== nh && m !== cl) c.push(l); else { var n = l.margin; m = n.right + n.left; n = n.top + n.bottom; l.measure(b, Infinity, f, 0); l = l.measuredBounds; Cc(e, Math.max(e.width, Math.max(l.width + m, 0)), e.height + Math.max(l.height + n, 0)) } } } d = c.length; if (0 !== d) {
            a.desiredSize.width ? b = Math.min(a.desiredSize.width, a.maxSize.width) : 0 !== e.width && (b = Math.min(e.width, a.maxSize.width)); for (a = 0; a < d; a++)if (k =
                c[a], k.visible || k === h) l = k.margin, g = l.right + l.left, l = l.top + l.bottom, k.measure(b, Infinity, f, 0), k = k.measuredBounds, l = Math.max(k.height + l, 0), e.width = Math.max(e.width, Math.max(k.width + g, 0)), e.height += l; Ta(c)
        }
    };
    Gm.prototype.arrange = function (a, b, c) {
        for (var d = b.length, e = a.padding, f = e.left, g = a.isOpposite, h = g ? c.height : e.top, k = 0; k < d; k++) {
            var l = f, m = b[k]; if (m.visible) {
                var n = m.measuredBounds, p = m.margin, q = p.left + p.right, r = f + e.right, u = n.width, x = ql(m, !1); if (isNaN(m.desiredSize.width) && x === oe || x === bl) u = Math.max(c.width - q - r, 0); q = u + q + r; r = m.alignment; r.Cb() && (r = a.defaultAlignment); r.Za() || (r = qd); g && (h -= n.height + p.bottom + p.top); m.arrange(l + r.offsetX + p.left + (c.width * r.x - q * r.x), h + r.offsetY + p.top, u, n.height); g || (h += n.height +
                    p.bottom + p.top)
            }
        }
    }; function Hm() { this.name = "Base"; this.name = "Spot" } ma(Hm, Tl);
    Hm.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = d.length, k = a.Bb(), l = k.margin, m = l.right + l.left, n = l.top + l.bottom; k.measure(b, c, f, g); var p = k.measuredBounds; f = p.width; g = p.height; var q = Math.max(f + m, 0); var r = Math.max(g + n, 0); for (var u = a.isClipping, x = L.allocAt(-l.left, -l.top, q, r), y = !0, A = Em(a), C = 0; C < h; C++) {
            var G = d[C]; if (G !== k && (G.visible || G === A)) {
                l = G.margin; q = l.right + l.left; r = l.top + l.bottom; p = ql(G, !1); switch (p) { case oe: b = f; c = g; break; case bl: b = f; break; case cl: c = g }G.measure(b, c, 0, 0); p = G.measuredBounds; q =
                    Math.max(p.width + q, 0); r = Math.max(p.height + r, 0); var H = G.alignment; H.Cb() && (H = a.defaultAlignment); H.Za() || (H = qd); var O = G.alignmentFocus; O.Cb() && (O = qd); var S = null; G instanceof W && "" !== G.Bg && (G.arrange(0, 0, p.width, p.height), S = G.bb(G.Bg), S === G && (S = null)); if (null !== S) { l = S.naturalBounds; p = S.margin; for (l = J.allocAt(O.x * l.width - O.offsetX - p.left, O.y * l.height - O.offsetY - p.top); S !== G;)S.transform.va(l), S = S.panel; G = H.x * f + H.offsetX - l.x; p = H.y * g + H.offsetY - l.y; J.free(l) } else G = H.x * f + H.offsetX - (O.x * p.width + O.offsetX) -
                        l.left, p = H.y * g + H.offsetY - (O.y * p.height + O.offsetY) - l.top; y ? (y = !1, e.h(G, p, q, r)) : Mc(e, G, p, q, r)
            }
        } y ? e.assign(x) : u ? e.ov(x.x, x.y, x.width, x.height) : Mc(e, x.x, x.y, x.width, x.height); L.free(x); p = k.stretch; p === al && (p = ql(k, !1)); switch (p) { case nh: return; case oe: if (!isFinite(b) && !isFinite(c)) return; break; case bl: if (!isFinite(b)) return; break; case cl: if (!isFinite(c)) return }p = k.measuredBounds; f = p.width; g = p.height; q = Math.max(f + m, 0); r = Math.max(g + n, 0); l = k.margin; x = L.allocAt(-l.left, -l.top, q, r); for (b = 0; b < h; b++)c = d[b], c ===
            k || !c.visible && c !== A || (l = c.margin, q = l.right + l.left, r = l.top + l.bottom, p = c.measuredBounds, q = Math.max(p.width + q, 0), r = Math.max(p.height + r, 0), m = c.alignment, m.Cb() && (m = a.defaultAlignment), m.Za() || (m = qd), c = c.alignmentFocus, c.Cb() && (c = qd), y ? (y = !1, e.h(m.x * f + m.offsetX - (c.x * p.width + c.offsetX) - l.left, m.y * g + m.offsetY - (c.y * p.height + c.offsetY) - l.top, q, r)) : Mc(e, m.x * f + m.offsetX - (c.x * p.width + c.offsetX) - l.left, m.y * g + m.offsetY - (c.y * p.height + c.offsetY) - l.top, q, r)); y ? e.assign(x) : u ? e.ov(x.x, x.y, x.width, x.height) : Mc(e, x.x,
                x.y, x.width, x.height); L.free(x)
    };
    Hm.prototype.arrange = function (a, b, c) {
        var d = b.length, e = a.Bb(), f = e.measuredBounds, g = f.width; f = f.height; var h = a.padding, k = h.left; h = h.top; var l = k - c.x, m = h - c.y; e.arrange(l, m, g, f); for (var n = 0; n < d; n++) {
            var p = b[n]; if (p !== e) {
                var q = p.measuredBounds, r = q.width; q = q.height; m = p.alignment; m.Cb() && (m = a.defaultAlignment); m.Za() || (m = qd); var u = p.alignmentFocus; u.Cb() && (u = qd); l = null; p instanceof W && "" !== p.Bg && (l = p.bb(p.Bg), l === p && (l = null)); if (null !== l) {
                    var x = l.naturalBounds; for (u = J.allocAt(u.x * x.width - u.offsetX, u.y * x.height -
                        u.offsetY); l !== p;)l.transform.va(u), l = l.panel; l = m.x * g + m.offsetX - u.x; m = m.y * f + m.offsetY - u.y; J.free(u)
                } else l = m.x * g + m.offsetX - (u.x * r + u.offsetX), m = m.y * f + m.offsetY - (u.y * q + u.offsetY); l -= c.x; m -= c.y; p.visible && p.arrange(k + l, h + m, r, q)
            }
        }
    }; function Im() { this.name = "Base"; this.name = "Auto" } ma(Im, Tl);
    Im.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = d.length, k = a.Bb(), l = k.margin, m = b, n = c, p = l.right + l.left, q = l.top + l.bottom; k.measure(b, c, f, g); l = k.measuredBounds; var r = 0, u = null; k instanceof Hg && (u = k, r = u.strokeWidth * u.scale); var x = Math.max(l.width + p, 0); l = Math.max(l.height + q, 0); var y = Jm(k), A = y.x * x + y.offsetX; y = y.y * l + y.offsetY; var C = Km(k), G = C.x * x + C.offsetX; C = C.y * l + C.offsetY; isFinite(b) && (m = Math.max(Math.abs(A - G) - r, 0)); isFinite(c) && (n = Math.max(Math.abs(y - C) - r, 0)); r = Zb.alloc(); r.h(0, 0); a = Em(a); for (C = 0; C <
            h; C++)y = d[C], y === k || !y.visible && y !== a || (l = y.margin, x = l.right + l.left, A = l.top + l.bottom, y.measure(m, n, 0, 0), l = y.measuredBounds, x = Math.max(l.width + x, 0), l = Math.max(l.height + A, 0), r.h(Math.max(x, r.width), Math.max(l, r.height))); if (1 === h) e.width = x, e.height = l, Zb.free(r); else {
                y = Jm(k); C = Km(k); h = d = 0; C.x !== y.x && C.y !== y.y && (d = r.width / Math.abs(C.x - y.x), h = r.height / Math.abs(C.y - y.y)); Zb.free(r); r = 0; null !== u && (r = u.strokeWidth * u.scale, oh(u) === ph && (d = h = Math.max(d, h))); d += Math.abs(y.offsetX) + Math.abs(C.offsetX) + r; h += Math.abs(y.offsetY) +
                    Math.abs(C.offsetY) + r; u = k.stretch; u === al && (u = ql(k, !1)); switch (u) { case nh: g = f = 0; break; case oe: isFinite(b) && (d = b); isFinite(c) && (h = c); break; case bl: isFinite(b) && (d = b); g = 0; break; case cl: f = 0, isFinite(c) && (h = c) }k.hm(); k.measure(d, h, f, g); e.width = k.measuredBounds.width + p; e.height = k.measuredBounds.height + q
            }
    };
    Im.prototype.arrange = function (a, b) {
        var c = b.length, d = a.Bb(), e = d.measuredBounds, f = L.alloc(); f.h(0, 0, 1, 1); var g = d.margin, h = g.left; g = g.top; var k = a.padding, l = k.left; k = k.top; d.arrange(l + h, k + g, e.width, e.height); var m = Jm(d), n = Km(d), p = m.y * e.height + m.offsetY, q = n.x * e.width + n.offsetX; n = n.y * e.height + n.offsetY; f.x = m.x * e.width + m.offsetX; f.y = p; Mc(f, q, n, 0, 0); f.x += h + l; f.y += g + k; for (e = 0; e < c; e++)h = b[e], h !== d && (l = h.measuredBounds, g = h.margin, k = Math.max(l.width + g.right + g.left, 0), m = Math.max(l.height + g.top + g.bottom, 0), p = h.alignment,
            p.Cb() && (p = a.defaultAlignment), p.Za() || (p = qd), k = f.width * p.x + p.offsetX - k * p.x + g.left + f.x, g = f.height * p.y + p.offsetY - m * p.y + g.top + f.y, h.visible && (Qc(f.x, f.y, f.width, f.height, k, g, l.width, l.height) ? h.arrange(k, g, l.width, l.height) : h.arrange(k, g, l.width, l.height, new L(f.x, f.y, f.width, f.height)))); L.free(f)
    }; function Lm() { this.name = "Base"; this.name = "Table" } ma(Lm, Tl);
    Lm.prototype.measure = function (a, b, c, d, e, f, g) {
        for (var h = d.length, k = Qa(), l = Qa(), m = 0; m < h; m++) {
            var n = d[m], p = n instanceof W ? n : null; if (null === p || p.type !== W.TableRow && p.type !== W.TableColumn || !n.visible) k.push(n); else {
                E && (p.desiredSize.o() && v(p.toString() + " TableRow/TableColumn Panels cannot set a desiredSize: " + p.desiredSize.toString()), p.minSize.A(rc) || v(p.toString() + " TableRow/TableColumn Panels cannot set a minSize: " + p.minSize.toString()), p.maxSize.A(wc) || v(p.toString() + " TableRow/TableColumn Panels cannot set a maxSize: " +
                    p.maxSize.toString())); l.push(p); for (var q = p.Z.j, r = q.length, u = 0; u < r; u++) { var x = q[u]; p.type === W.TableRow ? x.row = n.row : p.type === W.TableColumn && (x.column = n.column); k.push(x) }
            }
        } h = k.length; 0 === h && (a.getRowDefinition(0), a.getColumnDefinition(0)); for (var y = [], A = 0; A < h; A++) { var C = k[A]; yj(C, !0); rl(C, !0); y[C.row] || (y[C.row] = []); y[C.row][C.column] || (y[C.row][C.column] = []); y[C.row][C.column].push(C) } Ta(k); var G = Qa(), H = Qa(), O = Qa(), S = { count: 0 }, T = { count: 0 }, ea = b, Z = c, va = a.tb; h = va.length; for (var za = 0; za < h; za++) {
            var U =
                va[za]; void 0 !== U && (U.actual = 0)
        } va = a.ob; h = va.length; for (var aa = 0; aa < h; aa++)U = va[aa], void 0 !== U && (U.actual = 0); for (var Ja = y.length, Eb = 0, Xa = 0; Xa < Ja; Xa++)y[Xa] && (Eb = Math.max(Eb, y[Xa].length)); var Sa = Math.min(a.topIndex, Ja - 1), Ua = Math.min(a.leftIndex, Eb - 1), hb = 0; Ja = y.length; for (var kc = Em(a), rb = 0; rb < Ja; rb++)if (y[rb]) {
            Eb = y[rb].length; for (var mb = a.getRowDefinition(rb), cb = mb.actual = 0; cb < Eb; cb++)if (y[rb][cb]) {
                var ta = a.getColumnDefinition(cb); void 0 === G[cb] && (ta.actual = 0, G[cb] = !0); for (var sa = y[rb][cb], wb = sa.length,
                    yb = 0; yb < wb; yb++) {
                        var db = sa[yb]; if (db.visible || db === kc) {
                            var qe = 1 < db.rowSpan || 1 < db.columnSpan; qe && (rb < Sa || cb < Ua || H.push(db)); var Yd = db.margin, Lb = Yd.right + Yd.left, Pf = Yd.top + Yd.bottom; var Wb = Jl(db, mb, ta, !1); var De = db.desiredSize, id = !isNaN(De.height), lc = !isNaN(De.width) && id; qe || Wb === nh || lc || rb < Sa || cb < Ua || (void 0 !== S[cb] || Wb !== oe && Wb !== bl || (S[cb] = -1, S.count++), void 0 !== T[rb] || Wb !== oe && Wb !== cl || (T[rb] = -1, T.count++), O.push(db)); db.measure(Infinity, Infinity, 0, 0); if (!(rb < Sa || cb < Ua)) {
                                var Zd = db.measuredBounds,
                                Wc = Math.max(Zd.width + Lb, 0), Ze = Math.max(Zd.height + Pf, 0); if (1 === db.rowSpan && (Wb === nh || Wb === bl)) { U = a.getRowDefinition(rb); var $e = U.vc(); hb = Math.max(Ze - U.actual, 0); hb + $e > Z && (hb = Math.max(Z - $e, 0)); var Qf = 0 === U.actual; U.actual = U.actual + hb; Z = Math.max(Z - (hb + (Qf ? $e : 0)), 0) } if (1 === db.columnSpan && (Wb === nh || Wb === cl)) { U = a.getColumnDefinition(cb); var wf = U.vc(); hb = Math.max(Wc - U.actual, 0); hb + wf > ea && (hb = Math.max(ea - wf, 0)); var Rf = 0 === U.actual; U.actual = U.actual + hb; ea = Math.max(ea - (hb + (Rf ? wf : 0)), 0) } qe && db.hm()
                            }
                        }
                }
            }
        } Ta(G);
        var mc = 0, ob = 0; h = a.columnCount; for (var nb = 0; nb < h; nb++) { var Nc = a.ob[nb]; void 0 !== Nc && (mc += Nc.ma, 0 !== Nc.ma && (mc += Nc.vc())) } h = a.rowCount; for (var Sf = 0; Sf < h; Sf++) { var zc = a.tb[Sf]; void 0 !== zc && (ob += zc.ma, 0 !== zc.ma && (ob += zc.vc())) } ea = Math.max(b - mc, 0); var $d = Z = Math.max(c - ob, 0), Ic = ea; h = O.length; for (var ae = 0; ae < h; ae++) {
            var nc = O[ae], Zh = a.getRowDefinition(nc.row), $h = a.getColumnDefinition(nc.column), af = nc.measuredBounds, Fb = nc.margin, Tf = Fb.right + Fb.left, bf = Fb.top + Fb.bottom; S[nc.column] = 0 === $h.actual && void 0 !== S[nc.column] ?
                Math.max(af.width + Tf, S[nc.column]) : null; T[nc.row] = 0 === Zh.actual && void 0 !== T[nc.row] ? Math.max(af.height + bf, T[nc.row]) : null
        } var oc = 0, cf = 0, $c; for ($c in T) "count" !== $c && (oc += T[$c]); for ($c in S) "count" !== $c && (cf += S[$c]); for (var vb = Zb.alloc(), df = 0; df < h; df++) {
            var Ib = O[df]; if (Ib.visible || Ib === kc) {
                var Jc = a.getRowDefinition(Ib.row), zb = a.getColumnDefinition(Ib.column), jd = 0; isFinite(zb.width) ? jd = zb.width : (isFinite(ea) && null !== S[Ib.column] ? 0 === cf ? jd = zb.actual + ea : jd = S[Ib.column] / cf * Ic : null !== S[Ib.column] ? jd = ea :
                    jd = zb.actual || ea, jd = Math.max(0, jd - zb.vc())); var kd = 0; isFinite(Jc.height) ? kd = Jc.height : (isFinite(Z) && null !== T[Ib.row] ? 0 === oc ? kd = Jc.actual + Z : kd = T[Ib.row] / oc * $d : null !== T[Ib.row] ? kd = Z : kd = Jc.actual || Z, kd = Math.max(0, kd - Jc.vc())); vb.h(Math.max(zb.minimum, Math.min(jd, zb.maximum)), Math.max(Jc.minimum, Math.min(kd, Jc.maximum))); Wb = Jl(Ib, Jc, zb, !1); switch (Wb) { case bl: vb.height = Math.max(vb.height, Jc.actual + Z); break; case cl: vb.width = Math.max(vb.width, zb.actual + ea) }var Jd = Ib.margin, Vg = Jd.right + Jd.left, Uf = Jd.top +
                        Jd.bottom; Ib.hm(); Ib.measure(vb.width, vb.height, zb.minimum, Jc.minimum); var Vf = Ib.measuredBounds, xf = Math.max(Vf.width + Vg, 0), xd = Math.max(Vf.height + Uf, 0); isFinite(ea) && (xf = Math.min(xf, vb.width)); isFinite(Z) && (xd = Math.min(xd, vb.height)); var Kd = 0; Kd = Jc.actual; Jc.actual = Math.max(Jc.actual, xd); hb = Jc.actual - Kd; Z = Math.max(Z - hb, 0); Kd = zb.actual; zb.actual = Math.max(zb.actual, xf); hb = zb.actual - Kd; ea = Math.max(ea - hb, 0)
            }
        } Ta(O); var ad = Zb.alloc(), yd = Qa(), Ab = Qa(); h = H.length; if (0 !== h) for (var pb = 0; pb < Ja; pb++)if (y[pb]) {
            Eb =
            y[pb].length; var bd = a.getRowDefinition(pb); yd[pb] = bd.actual; for (var ld = 0; ld < Eb; ld++)if (y[pb][ld]) { var zd = a.getColumnDefinition(ld); Ab[ld] = zd.actual }
        } for (var Oc = 0; Oc < h; Oc++) {
            var Pa = H[Oc]; if (Pa.visible || Pa === kc) {
                var md = a.getRowDefinition(Pa.row), pc = a.getColumnDefinition(Pa.column); vb.h(Math.max(pc.minimum, Math.min(b, pc.maximum)), Math.max(md.minimum, Math.min(c, md.maximum))); Wb = Jl(Pa, md, pc, !1); switch (Wb) {
                    case oe: 0 !== Ab[pc.index] && (vb.width = Math.min(vb.width, Ab[pc.index])); 0 !== yd[md.index] && (vb.height =
                        Math.min(vb.height, yd[md.index])); break; case bl: 0 !== Ab[pc.index] && (vb.width = Math.min(vb.width, Ab[pc.index])); break; case cl: 0 !== yd[md.index] && (vb.height = Math.min(vb.height, yd[md.index]))
                }isFinite(pc.width) && (vb.width = pc.width); isFinite(md.height) && (vb.height = md.height); ad.h(0, 0); for (var re = 1; re < Pa.rowSpan && !(Pa.row + re >= a.rowCount); re++)U = a.getRowDefinition(Pa.row + re), hb = 0, hb = Wb === oe || Wb === cl ? Math.max(U.minimum, 0 === yd[Pa.row + re] ? U.maximum : Math.min(yd[Pa.row + re], U.maximum)) : Math.max(U.minimum, isNaN(U.Sc) ?
                    U.maximum : Math.min(U.Sc, U.maximum)), ad.height += hb; for (var ef = 1; ef < Pa.columnSpan && !(Pa.column + ef >= a.columnCount); ef++)U = a.getColumnDefinition(Pa.column + ef), hb = 0, hb = Wb === oe || Wb === bl ? Math.max(U.minimum, 0 === Ab[Pa.column + ef] ? U.maximum : Math.min(Ab[Pa.column + ef], U.maximum)) : Math.max(U.minimum, isNaN(U.Sc) ? U.maximum : Math.min(U.Sc, U.maximum)), ad.width += hb; vb.width += ad.width; vb.height += ad.height; var se = Pa.margin, Pc = se.right + se.left, Ee = se.top + se.bottom; Pa.measure(vb.width, vb.height, f, g); for (var nd = Pa.measuredBounds,
                        Mb = Math.max(nd.width + Pc, 0), be = Math.max(nd.height + Ee, 0), bc = 0, Fe = 0; Fe < Pa.rowSpan && !(Pa.row + Fe >= a.rowCount); Fe++)U = a.getRowDefinition(Pa.row + Fe), bc += U.total || 0; if (bc < be) {
                            var Ld = be - bc, te = be - bc; if (null !== Pa.spanAllocation) for (var Wg = Pa.spanAllocation, od = 0; od < Pa.rowSpan && !(0 >= Ld) && !(Pa.row + od >= a.rowCount); od++) {
                                U = a.getRowDefinition(Pa.row + od); var ff = U.ma || 0, Wf = Wg(Pa, U, te); E && "number" !== typeof Wf && v(Pa + " spanAllocation does not return a number: " + Wf); U.actual = Math.min(U.maximum, ff + Wf); U.ma !== ff && (Ld -= U.ma -
                                    ff)
                            } for (; 0 < Ld;) { var Xf = U.ma || 0; isNaN(U.height) && U.maximum > Xf && (U.actual = Math.min(U.maximum, Xf + Ld), U.ma !== Xf && (Ld -= U.ma - Xf)); if (0 === U.index) break; U = a.getRowDefinition(U.index - 1) }
                        } for (var gf = 0, Xg = 0; Xg < Pa.columnSpan && !(Pa.column + Xg >= a.columnCount); Xg++)U = a.getColumnDefinition(Pa.column + Xg), gf += U.total || 0; if (gf < Mb) {
                            var rg = Mb - gf, $i = Mb - gf; if (null !== Pa.spanAllocation) for (var hf = Pa.spanAllocation, Ge = 0; Ge < Pa.columnSpan && !(0 >= rg) && !(Pa.column + Ge >= a.columnCount); Ge++) {
                                U = a.getColumnDefinition(Pa.column + Ge); var sg =
                                    U.ma || 0, Cn = hf(Pa, U, $i); E && "number" !== typeof Cn && v(Pa + " spanAllocation does not return a number: " + Cn); U.actual = Math.min(U.maximum, sg + Cn); U.ma !== sg && (rg -= U.ma - sg)
                            } for (; 0 < rg;) { var mk = U.ma || 0; isNaN(U.width) && U.maximum > mk && (U.actual = Math.min(U.maximum, mk + rg), U.ma !== mk && (rg -= U.ma - mk)); if (0 === U.index) break; U = a.getColumnDefinition(U.index - 1) }
                        }
            }
        } Ta(H); Zb.free(ad); Zb.free(vb); void 0 !== yd && Ta(yd); void 0 !== Ab && Ta(Ab); var Yg = 0, Zg = 0, nk = a.desiredSize, gr = a.maxSize; Wb = ql(a, !0); var aj = ob = mc = 0, bj = 0; h = a.columnCount;
        for (var ok = 0; ok < h; ok++)void 0 !== a.ob[ok] && (U = a.getColumnDefinition(ok), isFinite(U.width) ? (aj += U.width, aj += U.vc()) : Mm(U) === Nm ? (aj += U.ma, aj += U.vc()) : 0 !== U.ma && (mc += U.ma, mc += U.vc())); isFinite(nk.width) ? Yg = Math.min(nk.width, gr.width) : Yg = Wb !== nh && isFinite(b) ? b : mc; Yg = Math.max(Yg, a.minSize.width); Yg = Math.max(Yg - aj, 0); for (var Kt = 0 === mc ? 1 : Math.max(Yg / mc, 1), qk = 0; qk < h; qk++)void 0 !== a.ob[qk] && (U = a.getColumnDefinition(qk), isFinite(U.width) || Mm(U) === Nm || (U.actual = U.ma * Kt), U.position = e.width, 0 !== U.ma && (e.width +=
            U.ma, e.width += U.vc())); h = a.rowCount; for (var rk = 0; rk < h; rk++)void 0 !== a.tb[rk] && (U = a.getRowDefinition(rk), isFinite(U.height) ? (bj += U.height, bj += U.vc()) : Mm(U) === Nm ? (bj += U.ma, bj += U.vc()) : 0 !== U.ma && (ob += U.ma, 0 !== U.ma && (ob += U.vc()))); isFinite(nk.height) ? Zg = Math.min(nk.height, gr.height) : Zg = Wb !== nh && isFinite(c) ? c : ob; Zg = Math.max(Zg, a.minSize.height); Zg = Math.max(Zg - bj, 0); for (var Lt = 0 === ob ? 1 : Math.max(Zg / ob, 1), sk = 0; sk < h; sk++)void 0 !== a.tb[sk] && (U = a.getRowDefinition(sk), isFinite(U.height) || Mm(U) === Nm || (U.actual =
                U.ma * Lt), U.position = e.height, 0 !== U.ma && (e.height += U.ma, 0 !== U.ma && (e.height += U.vc()))); h = l.length; for (var Dn = 0; Dn < h; Dn++) { var ce = l[Dn], En = 0, Fn = 0; ce.type === W.TableRow ? (En = e.width, U = a.getRowDefinition(ce.row), Fn = U.actual) : (U = a.getColumnDefinition(ce.column), En = U.actual, Fn = e.height); ce.measuredBounds.h(0, 0, En, Fn); yj(ce, !1); y[ce.row] || (y[ce.row] = []); y[ce.row][ce.column] || (y[ce.row][ce.column] = []); y[ce.row][ce.column].push(ce) } Ta(l); a.kp = y
    };
    Lm.prototype.arrange = function (a, b, c) {
        var d = b.length, e = a.padding, f = e.left; e = e.top; for (var g = a.kp, h, k, l = g.length, m = 0, n = 0; n < l; n++)g[n] && (m = Math.max(m, g[n].length)); for (n = Math.min(a.topIndex, l - 1); n !== l && (void 0 === a.tb[n] || 0 === a.tb[n].ma);)n++; n = Math.min(n, l - 1); n = -a.tb[n].position; for (h = Math.min(a.leftIndex, m - 1); h !== m && (void 0 === a.ob[h] || 0 === a.ob[h].ma);)h++; h = Math.min(h, m - 1); for (var p = -a.ob[h].position, q = Zb.alloc(), r = 0; r < l; r++)if (g[r]) {
            m = g[r].length; var u = a.getRowDefinition(r); k = u.position + n + e; 0 !== u.ma &&
                (k += u.Tu()); for (var x = 0; x < m; x++)if (g[r][x]) {
                    var y = a.getColumnDefinition(x); h = y.position + p + f; 0 !== y.ma && (h += y.Tu()); for (var A = g[r][x], C = A.length, G = 0; G < C; G++) {
                        var H = A[G], O = H.measuredBounds, S = H instanceof W ? H : null; if (null === S || S.type !== W.TableRow && S.type !== W.TableColumn) {
                            q.h(0, 0); for (var T = 1; T < H.rowSpan && !(r + T >= a.rowCount); T++)S = a.getRowDefinition(r + T), q.height += S.total; for (T = 1; T < H.columnSpan && !(x + T >= a.columnCount); T++)S = a.getColumnDefinition(x + T), q.width += S.total; var ea = y.ma + q.width, Z = u.ma + q.height;
                            T = h; S = k; var va = ea, za = Z, U = h, aa = k, Ja = ea, Eb = Z; h + ea > c.width && (Ja = Math.max(c.width - h, 0)); k + Z > c.height && (Eb = Math.max(c.height - k, 0)); var Xa = H.alignment; if (Xa.Cb()) { Xa = a.defaultAlignment; Xa.Za() || (Xa = qd); var Sa = Xa.x; var Ua = Xa.y; var hb = Xa.offsetX; Xa = Xa.offsetY; var kc = y.alignment, rb = u.alignment; kc.Za() && (Sa = kc.x, hb = kc.offsetX); rb.Za() && (Ua = rb.y, Xa = rb.offsetY) } else Sa = Xa.x, Ua = Xa.y, hb = Xa.offsetX, Xa = Xa.offsetY; if (isNaN(Sa) || isNaN(Ua)) Ua = Sa = .5, Xa = hb = 0; kc = O.width; rb = O.height; var mb = H.margin, cb = mb.left + mb.right,
                                ta = mb.top + mb.bottom, sa = Jl(H, u, y, !1); !isNaN(H.desiredSize.width) || sa !== oe && sa !== bl || (kc = Math.max(ea - cb, 0)); !isNaN(H.desiredSize.height) || sa !== oe && sa !== cl || (rb = Math.max(Z - ta, 0)); ea = H.maxSize; Z = H.minSize; kc = Math.min(ea.width, kc); rb = Math.min(ea.height, rb); kc = Math.max(Z.width, kc); rb = Math.max(Z.height, rb); ea = rb + ta; T += va * Sa - (kc + cb) * Sa + hb + mb.left; S += za * Ua - ea * Ua + Xa + mb.top; H.visible && (Qc(U, aa, Ja, Eb, T, S, O.width, O.height) ? H.arrange(T, S, kc, rb) : H.arrange(T, S, kc, rb, new L(U, aa, Ja, Eb)))
                        } else H.jl(), H.actualBounds.ja(),
                            va = H.actualBounds, T = L.allocAt(va.x, va.y, va.width, va.height), va.x = S.type === W.TableRow ? f : h, va.y = S.type === W.TableColumn ? e : k, va.width = O.width, va.height = O.height, H.actualBounds.freeze(), rl(H, !1), Fc(T, va) || (O = H.part, null !== O && (O.zh(), H.Ko(O))), L.free(T)
                    }
                }
        } Zb.free(q); for (a = 0; a < d; a++)c = b[a], f = c instanceof W ? c : null, null === f || f.type !== W.TableRow && f.type !== W.TableColumn || (f = c.actualBounds, c.naturalBounds.ja(), c.naturalBounds.h(0, 0, f.width, f.height), c.naturalBounds.freeze())
    };
    function Om() { this.name = "Base"; this.name = "TableRow" } ma(Om, Tl); Om.prototype.measure = function () { }; Om.prototype.arrange = function () { }; function Pm() { this.name = "Base"; this.name = "TableColumn" } ma(Pm, Tl); Pm.prototype.measure = function () { }; Pm.prototype.arrange = function () { }; function Qm() { this.name = "Base"; this.name = "Viewbox" } ma(Qm, Tl);
    Qm.prototype.measure = function (a, b, c, d, e, f, g) {
    1 < d.length && v("Viewbox Panel cannot contain more than one GraphObject."); d = d[0]; d.Da = 1; d.hm(); d.measure(Infinity, Infinity, f, g); var h = d.measuredBounds, k = d.margin, l = k.right + k.left; k = k.top + k.bottom; if (isFinite(b) || isFinite(c)) {
        var m = d.scale, n = h.width; h = h.height; var p = Math.max(b - l, 0), q = Math.max(c - k, 0), r = 1; a.viewboxStretch === ph ? 0 !== n && 0 !== h && (r = Math.min(p / n, q / h)) : 0 !== n && 0 !== h && (r = Math.max(p / n, q / h)); 0 === r && (r = 1E-4); d.Da *= r; m !== d.scale && (yj(d, !0), d.measure(Infinity,
            Infinity, f, g))
    } h = d.measuredBounds; e.width = isFinite(b) ? b : Math.max(h.width + l, 0); e.height = isFinite(c) ? c : Math.max(h.height + k, 0)
    }; Qm.prototype.arrange = function (a, b, c) { b = b[0]; var d = b.measuredBounds, e = b.margin, f = Math.max(d.width + (e.right + e.left), 0); e = Math.max(d.height + (e.top + e.bottom), 0); var g = b.alignment; g.Cb() && (g = a.defaultAlignment); g.Za() || (g = qd); b.arrange(c.width * g.x - f * g.x + g.offsetX, c.height * g.y - e * g.y + g.offsetY, d.width, d.height) }; function Rm() { this.name = "Base"; this.name = "Grid" } ma(Rm, Tl);
    Rm.prototype.measure = function () { }; Rm.prototype.arrange = function () { }; function Sm() { this.name = "Base"; this.name = "Link" } ma(Sm, Tl);
    Sm.prototype.measure = function (a, b, c, d, e) {
        c = d.length; if (a instanceof Cf || a instanceof Q) {
            var f = null, g = null, h = null; a instanceof Q && (g = f = a); a instanceof Cf && (h = a, f = h.adornedPart); if (f instanceof Q) {
                var k = f; if (0 === c) Cc(a.naturalBounds, 0, 0), a.measuredBounds.h(0, 0, 0, 0); else {
                    var l = a instanceof Cf ? null : f.path, m = f.routeBounds; b = a.kg; b.h(0, 0, m.width, m.height); var n = k.points; f = f.pointsCount; null !== h ? h.kk(!1) : null !== g && g.kk(!1); var p = m.width, q = m.height; a.location.h(m.x, m.y); a.l.length = 0; null !== l && (Tm(a, p, q, l),
                        h = l.measuredBounds, b.Lc(h), a.l.push(h)); h = $b.alloc(); for (var r = J.alloc(), u = J.alloc(), x = 0; x < c; x++) {
                            var y = d[x]; if (y !== l) if (y.isPanelMain && y instanceof Hg) { Tm(a, p, q, y); var A = y.measuredBounds; b.Lc(A); a.l.push(A) } else if (2 > f) y.measure(Infinity, Infinity, 0, 0), A = y.measuredBounds, b.Lc(A), a.l.push(A); else {
                                var C = y.segmentIndex; A = y.segmentFraction; var G = y.alignmentFocus; G.Nb() && (G = qd); var H = y.segmentOrientation, O = y.segmentOffset; if (C < -f || C >= f) {
                                    A = k.midPoint; var S = k.midAngle; if (H !== ch) {
                                        var T = k.computeAngle(y, H,
                                            S); y.Bc = T
                                    } T = A.x - m.x; var ea = A.y - m.y
                                } else { T = 0; if (0 <= C) { ea = n.O(C); var Z = C < f - 1 ? n.O(C + 1) : ea } else T = f + C, ea = n.O(T), Z = 0 < T ? n.O(T - 1) : ea; if (ea.Sa(Z)) { 0 <= C ? (S = 0 < C ? n.O(C - 1) : ea, T = C < f - 2 ? n.O(C + 2) : Z) : (S = T < f - 1 ? n.O(T + 1) : ea, T = 1 < T ? n.O(T - 2) : Z); var va = S.Ee(ea), za = Z.Ee(T); S = va > za + 10 ? 0 <= C ? S.Xa(ea) : ea.Xa(S) : za > va + 10 ? 0 <= C ? Z.Xa(T) : T.Xa(Z) : 0 <= C ? S.Xa(T) : T.Xa(S) } else S = 0 <= C ? ea.Xa(Z) : Z.Xa(ea); H !== ch && (T = k.computeAngle(y, H, S), y.Bc = T); T = ea.x + (Z.x - ea.x) * A - m.x; ea = ea.y + (Z.y - ea.y) * A - m.y } y.measure(Infinity, Infinity, 0, 0); A = y.measuredBounds;
                                za = y.naturalBounds; va = 0; y instanceof Hg && (va = y.strokeWidth); Z = za.width + va; za = za.height + va; h.reset(); h.translate(-A.x, -A.y); h.scale(y.scale, y.scale); h.rotate(H === ch ? y.angle : S, Z / 2, za / 2); H !== Um && H !== Vm || h.rotate(90, Z / 2, za / 2); H !== Wm && H !== Xm || h.rotate(-90, Z / 2, za / 2); H === Ym && (45 < S && 135 > S || 225 < S && 315 > S) && h.rotate(-S, Z / 2, za / 2); H = new L(0, 0, Z, za); r.Xi(H, G); h.va(r); G = -r.x + va / 2 * y.scale; y = -r.y + va / 2 * y.scale; u.assign(O); isNaN(u.x) && (u.x = 0 <= C ? Z / 2 + 3 : -(Z / 2 + 3)); isNaN(u.y) && (u.y = -(za / 2 + 3)); u.rotate(S); T += u.x; ea += u.y;
                                H.set(A); H.h(T + G, ea + y, A.width, A.height); a.l.push(H); b.Lc(H)
                            }
                        } if (null !== g) for (d = g.labelNodes; d.next();)d.value.measure(Infinity, Infinity); a.kg = b; a = a.location; a.h(a.x + b.x, a.y + b.y); Cc(e, b.width || 0, b.height || 0); $b.free(h); J.free(r); J.free(u)
                }
            }
        }
    };
    Sm.prototype.arrange = function (a, b) {
        var c = b.length; if (a instanceof Cf || a instanceof Q) {
            var d = null, e = null, f = null; a instanceof Q && (e = d = a); a instanceof Cf && (f = a, d = f.adornedPart); var g = a instanceof Cf ? null : d.path; if (0 !== a.l.length) { var h = a.l, k = 0; if (null !== g && k < a.l.length) { var l = h[k]; k++; g.arrange(l.x - a.kg.x, l.y - a.kg.y, l.width, l.height) } for (l = 0; l < c; l++) { var m = b[l]; if (m !== g && k < a.l.length) { var n = h[k]; k++; m.arrange(n.x - a.kg.x, n.y - a.kg.y, n.width, n.height) } } } b = d.points; c = b.count; if (2 <= c && a instanceof Q) for (d =
                a.labelNodes; d.next();) {
                    n = a; g = d.value; h = g.segmentIndex; var p = g.segmentFraction; l = g.alignmentFocus; var q = g.segmentOrientation; k = g.segmentOffset; if (h < -c || h >= c) { var r = n.midPoint; m = n.midAngle; q !== ch && (n = n.computeAngle(g, q, m), g.angle = n); n = r.x; var u = r.y } else {
                        var x = 0; 0 <= h ? (u = b.j[h], r = h < c - 1 ? b.j[h + 1] : u) : (x = c + h, u = b.j[x], r = 0 < x ? b.j[x - 1] : u); if (u.Sa(r)) {
                            0 <= h ? (m = 0 < h ? b.j[h - 1] : u, x = h < c - 2 ? b.j[h + 2] : r) : (m = x < c - 1 ? b.j[x + 1] : u, x = 1 < x ? b.j[x - 2] : r); var y = m.Ee(u), A = r.Ee(x); m = y > A + 10 ? 0 <= h ? m.Xa(u) : u.Xa(m) : A > y + 10 ? 0 <= h ? r.Xa(x) : x.Xa(r) :
                                0 <= h ? m.Xa(x) : x.Xa(m)
                        } else m = 0 <= h ? u.Xa(r) : r.Xa(u); q !== ch && (n = n.computeAngle(g, q, m), g.angle = n); n = u.x + (r.x - u.x) * p; u = u.y + (r.y - u.y) * p
                    } l.kq() ? g.location = new J(n, u) : (l.Nb() && (l = qd), r = $b.alloc(), r.reset(), r.scale(g.scale, g.scale), r.rotate(g.angle, 0, 0), p = g.naturalBounds, p = L.allocAt(0, 0, p.width, p.height), q = J.alloc(), q.Xi(p, l), r.va(q), l = -q.x, x = -q.y, k = k.copy(), isNaN(k.x) && (0 <= h ? k.x = q.x + 3 : k.x = -(q.x + 3)), isNaN(k.y) && (k.y = -(q.y + 3)), k.rotate(m), n += k.x, u += k.y, r.aw(p), l += p.x, x += p.y, h = J.allocAt(n + l, u + x), g.move(h), J.free(h),
                        J.free(q), L.free(p), $b.free(r))
            } null !== f ? f.kk(!1) : null !== e && e.kk(!1)
        }
    }; function Tm(a, b, c, d) { if (!1 !== Dj(d)) { var e = d.strokeWidth; 0 === e && a instanceof Cf && a.type === W.Link && a.adornedObject instanceof Hg && (e = a.adornedObject.strokeWidth); e *= d.Da; a instanceof Q && null !== a.sa ? (a = a.sa.bounds, nl(d, a.x - e / 2, a.y - e / 2, a.width + e, a.height + e)) : a instanceof Cf && null !== a.adornedPart.sa ? (a = a.adornedPart.sa.bounds, nl(d, a.x - e / 2, a.y - e / 2, a.width + e, a.height + e)) : nl(d, -(e / 2), -(e / 2), b + e, c + e); yj(d, !1) } }
    function Zm() { this.name = "Base"; this.name = "Graduated" } ma(Zm, Tl);
    Zm.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = a.Bb(); a.lj = []; var k = h.margin, l = k.right + k.left, m = k.top + k.bottom; h.measure(b, c, f, g); var n = h.measuredBounds, p = new L(-k.left, -k.top, Math.max(n.width + l, 0), Math.max(n.height + m, 0)); a.lj.push(p); e.assign(p); for (var q = h.geometry, r = h.strokeWidth, u = q.flattenedSegments, x = q.flattenedLengths, y = q.flattenedTotalLength, A = u.length, C = 0, G = 0, H = Qa(), O = 0; O < A; O++) {
            var S = u[O], T = []; G = C = 0; for (var ea = S.length, Z = 0; Z < ea; Z += 2) {
                var va = S[Z], za = S[Z + 1]; if (0 !== Z) {
                    var U = 180 * Math.atan2(za -
                        G, va - C) / Math.PI; 0 > U && (U += 360); T.push(U)
                } C = va; G = za
            } H.push(T)
        } if (null === a.Pg) { for (var aa = [], Ja = a.Z.j, Eb = Ja.length, Xa = 0; Xa < Eb; Xa++) { var Sa = Ja[Xa], Ua = []; aa.push(Ua); if (Sa.visible) for (var hb = Sa.interval, kc = 0; kc < Eb; kc++) { var rb = Ja[kc]; if (rb.visible && Sa !== rb && !(Sa instanceof Hg && !(rb instanceof Hg) || Sa instanceof Kh && !(rb instanceof Kh))) { var mb = rb.interval; mb > hb && Ua.push(mb) } } } a.Pg = aa } var cb = a.Pg; var ta = a.Z.j, sa = ta.length, wb = 0, yb = 0, db = y; a.nj = []; for (var qe, Yd = 0; Yd < sa; Yd++) {
            var Lb = ta[Yd]; qe = []; if (Lb.visible &&
                Lb !== h) {
                    var Pf = Lb.interval, Wb = a.graduatedTickUnit; if (!(2 > Wb * Pf * y / a.graduatedRange)) {
                        var De = x[0][0], id = 0, lc = 0; yb = y * Lb.graduatedStart - 1E-4; db = y * Lb.graduatedEnd + 1E-4; var Zd = Wb * Pf, Wc = a.graduatedTickBase; if (Wc < a.graduatedMin) { var Ze = (a.graduatedMin - Wc) / Zd; Ze = 0 === Ze % 1 ? Ze : Math.floor(Ze + 1); Wc += Ze * Zd } else Wc > a.graduatedMin + Zd && (Wc -= Math.floor((Wc - a.graduatedMin) / Zd) * Zd); for (var $e = cb[Yd]; Wc <= a.graduatedMax;) {
                            a: {
                                for (var Qf = $e.length, wf = 0; wf < Qf; wf++)if (K.da((Wc - a.graduatedTickBase) % ($e[wf] * a.graduatedTickUnit),
                                    0)) { var Rf = !1; break a } Rf = !0
                            } if (Rf && (null === Lb.graduatedSkip || !Lb.graduatedSkip(Wc)) && (wb = (Wc - a.graduatedMin) * y / a.graduatedRange, wb > y && (wb = y), yb <= wb && wb <= db)) {
                                for (var mc = H[id][lc], ob = x[id][lc]; id < x.length;) { for (; wb > De && lc < x[id].length - 1;)lc++ , mc = H[id][lc], ob = x[id][lc], De += ob; if (wb <= De) break; id++; lc = 0; mc = H[id][lc]; ob = x[id][lc]; De += ob } var nb = u[id], Nc = nb[2 * lc], Sf = nb[2 * lc + 1], zc = (wb - (De - ob)) / ob, $d = new J(Nc + (nb[2 * lc + 2] - Nc) * zc + r / 2 - q.bounds.x, Sf + (nb[2 * lc + 3] - Sf) * zc + r / 2 - q.bounds.y); $d.scale(h.scale, h.scale);
                                var Ic = mc, ae = H[id]; 1E-4 > zc ? 0 < lc ? Ic = ae[lc - 1] : K.da(nb[0], nb[nb.length - 2]) && K.da(nb[1], nb[nb.length - 1]) && (Ic = ae[ae.length - 1]) : .9999 < zc && (lc + 1 < ae.length ? Ic = ae[lc + 1] : K.da(nb[0], nb[nb.length - 2]) && K.da(nb[1], nb[nb.length - 1]) && (Ic = ae[0])); mc !== Ic && (180 < Math.abs(mc - Ic) && (mc < Ic ? mc += 360 : Ic += 360), mc = (mc + Ic) / 2 % 360); if (Lb instanceof Kh) { var nc = ""; null !== Lb.graduatedFunction ? (nc = Lb.graduatedFunction(Wc), nc = null !== nc && void 0 !== nc ? nc.toString() : "") : nc = (+Wc.toFixed(2)).toString(); "" !== nc && qe.push([$d, mc, nc]) } else qe.push([$d,
                                    mc])
                            } Wc += Zd
                        }
                    }
            } a.nj.push(qe)
        } Ta(H); for (var Zh = a.nj, $h = d.length, af = 0; af < $h; af++) {
            var Fb = d[af], Tf = Zh[af]; if (Fb.visible && Fb !== h && 0 !== Tf.length) {
                if (Fb instanceof Hg) {
                    var bf = a, oc = e, cf = Fb.alignmentFocus; cf.Nb() && (cf = gd); var $c = Fb.angle; Fb.Bc = 0; Fb.measure(Infinity, Infinity, 0, 0); Fb.Bc = $c; var vb = Fb.measuredBounds, df = vb.width, Ib = vb.height, Jc = L.allocAt(0, 0, df, Ib), zb = J.alloc(); zb.Xi(Jc, cf); L.free(Jc); for (var jd = -zb.x, kd = -zb.y, Jd = new L, Vg = Tf.length, Uf = 0; Uf < Vg; Uf++)for (var Vf = Tf[Uf], xf = Vf[0].x, xd = Vf[0].y, Kd = Vf[1],
                        ad = 0; 4 > ad; ad++) { switch (ad) { case 0: zb.h(jd, kd); break; case 1: zb.h(jd + df, kd); break; case 2: zb.h(jd, kd + Ib); break; case 3: zb.h(jd + df, kd + Ib) }zb.rotate(Kd + Fb.angle); zb.offset(xf, xd); 0 === Uf && 0 === ad ? Jd.h(zb.x, zb.y, 0, 0) : Jd.Le(zb); zb.offset(-xf, -xd); zb.rotate(-Kd - Fb.angle) } J.free(zb); bf.lj.push(Jd); Mc(oc, Jd.x, Jd.y, Jd.width, Jd.height)
                } else if (Fb instanceof Kh) {
                    var yd = a, Ab = e; null === yd.kh && (yd.kh = new Kh); var pb = yd.kh; $m(pb, Fb); var bd = Fb.alignmentFocus; bd.Nb() && (bd = gd); for (var ld = Fb.segmentOrientation, zd = Fb.segmentOffset,
                        Oc = null, Pa = 0, md = 0, pc = 0, re = 0, ef = Tf.length, se = 0; se < ef; se++) {
                            var Pc = Tf[se]; Pa = Pc[0].x; md = Pc[0].y; pc = Pc[1]; ld !== ch && (re = Q.computeAngle(ld, pc), pb.Bc = re); pb.text = Pc[2]; pb.measure(Infinity, Infinity, 0, 0); var Ee = pb.measuredBounds, nd = pb.naturalBounds, Mb = nd.width, be = nd.height, bc = $b.alloc(); bc.reset(); bc.translate(-Ee.x, -Ee.y); bc.scale(pb.scale, pb.scale); bc.rotate(ld === ch ? pb.angle : pc, Mb / 2, be / 2); ld !== Um && ld !== Vm || bc.rotate(90, Mb / 2, be / 2); ld !== Wm && ld !== Xm || bc.rotate(-90, Mb / 2, be / 2); ld === Ym && (45 < pc && 135 > pc || 225 < pc &&
                                315 > pc) && bc.rotate(-pc, Mb / 2, be / 2); var Fe = L.allocAt(0, 0, Mb, be), Ld = J.alloc(); Ld.Xi(Fe, bd); bc.va(Ld); var te = -Ld.x, Wg = -Ld.y, od = J.alloc(); od.assign(zd); isNaN(od.x) && (od.x = Mb / 2 + 3); isNaN(od.y) && (od.y = -(be / 2 + 3)); od.rotate(pc); Pa += od.x + te; md += od.y + Wg; var ff = new L(Pa, md, Ee.width, Ee.height), Wf = new L(Ee.x, Ee.y, Ee.width, Ee.height), Xf = new L(nd.x, nd.y, nd.width, nd.height), gf = new an; gf.Zl(pb.metrics); Pc.push(re); Pc.push(pb.lineCount); Pc.push(gf); Pc.push(ff); Pc.push(Wf); Pc.push(Xf); 0 === se ? Oc = ff.copy() : Oc.Lc(ff); J.free(od);
                        J.free(Ld); L.free(Fe); $b.free(bc)
                    } yd.lj.push(Oc); Mc(Ab, Oc.x, Oc.y, Oc.width, Oc.height)
                } yj(Fb, !1)
            }
        }
    }; Zm.prototype.arrange = function (a, b, c) { if (null !== a.lj) { var d = a.Bb(), e = a.nj, f = a.lj, g = 0, h = f[g]; g++; d.arrange(h.x - c.x, h.y - c.y, h.width, h.height); for (var k = b.length, l = 0; l < k; l++) { var m = b[l]; h = e[l]; m.visible && m !== d && 0 !== h.length && (h = f[g], g++ , m.arrange(h.x - c.x, h.y - c.y, h.width, h.height)) } a.lj = null } };
    function W(a) {
        N.call(this); void 0 === a ? this.wa = W.Position : (w(a, Tl, W, "type"), this.wa = a); null === this.wa && v("Panel type not specified or PanelLayout not loaded: " + a); this.Z = new F; this.gb = Zc; this.wa === W.Grid && (this.isAtomic = !0); this.rn = Qd; this.Gf = al; this.wa === W.Table && bn(this); this.Mp = ph; this.Pn = vc; this.Qn = gc; this.Mn = 0; this.Ln = 100; this.On = 10; this.Nn = 0; this.Sh = this.kb = this.Pg = this.lj = this.nj = null; this.co = NaN; this.le = this.gi = null; this.kl = "category"; this.Gd = null; this.kg = new L(NaN, NaN, NaN, NaN); this.kh = this.kp =
            this.wi = null; this.Bg = ""
    } ma(W, N); function bn(a) { a.hj = Zc; a.Jg = 1; a.Xh = null; a.Wh = null; a.Ig = 1; a.Hg = null; a.Vh = null; a.tb = []; a.ob = []; a.Jj = cn; a.fj = cn; a.zi = 0; a.ii = 0 }
    W.prototype.cloneProtected = function (a) {
        N.prototype.cloneProtected.call(this, a); a.wa = this.wa; a.gb = this.gb.J(); a.rn = this.rn.J(); a.Gf = this.Gf; if (a.wa === W.Table) {
        a.hj = this.hj.J(); a.Jg = this.Jg; a.Xh = this.Xh; a.Wh = this.Wh; a.Ig = this.Ig; a.Hg = this.Hg; a.Vh = this.Vh; var b = []; if (0 < this.tb.length) for (var c = this.tb, d = c.length, e = 0; e < d; e++)if (void 0 !== c[e]) { var f = c[e].copy(); f.Wi(a); b[e] = f } a.tb = b; b = []; if (0 < this.ob.length) for (c = this.ob, d = c.length, e = 0; e < d; e++)void 0 !== c[e] && (f = c[e].copy(), f.Wi(a), b[e] = f); a.ob = b; a.Jj =
            this.Jj; a.fj = this.fj; a.zi = this.zi; a.ii = this.ii
        } a.Mp = this.Mp; a.Pn = this.Pn.J(); a.Qn = this.Qn.J(); a.Mn = this.Mn; a.Ln = this.Ln; a.On = this.On; a.Nn = this.Nn; a.nj = this.nj; a.Pg = this.Pg; a.kb = this.kb; a.Sh = this.Sh; a.co = this.co; a.gi = this.gi; a.le = this.le; a.kl = this.kl; a.kg.assign(this.kg); a.Bg = this.Bg; null !== this.kp && (a.kp = this.kp)
    }; W.prototype.qf = function (a) { N.prototype.qf.call(this, a); a.Z = this.Z; for (var b = a.Z.j, c = b.length, d = 0; d < c; d++)b[d].cg = a; a.wi = null };
    W.prototype.copy = function () { var a = N.prototype.copy.call(this); if (null !== a) { for (var b = this.Z.j, c = b.length, d = 0; d < c; d++) { var e = b[d].copy(); e.Wi(a); e.Ej = null; var f = a.Z, g = f.count; f.Lb(g, e); f = a.part; if (null !== f) { f.zj = null; null !== e.portId && f instanceof V && (f.yh = !0); var h = a.diagram; null !== h && h.undoManager.isUndoingRedoing || f.cb(qf, "elements", a, null, e, null, g) } } return a } return null }; t = W.prototype; t.toString = function () { return "Panel(" + this.type + ")#" + Jb(this) };
    t.Ko = function (a) { N.prototype.Ko.call(this, a); for (var b = this.Z.j, c = b.length, d = 0; d < c; d++)b[d].Ko(a) };
    t.Gi = function (a, b) {
        if (this.wa === W.Grid) {
            b = this.Fe() * b.scale; 0 >= b && (b = 1); var c = this.gridCellSize, d = c.width; c = c.height; var e = this.naturalBounds, f = this.actualBounds, g = e.width, h = e.height, k = Math.ceil(g / d), l = Math.ceil(h / c), m = this.gridOrigin; a.save(); a.beginPath(); a.rect(0, 0, g, h); a.clip(); for (var n = [], p = this.Z.j, q = p.length, r = 0; r < q; r++) { var u = p[r], x = []; n.push(x); if (u.visible) { u = hk(u.figure); for (var y = r + 1; y < q; y++) { var A = p[y]; A.visible && hk(A.figure) === u && (A = A.interval, 2 <= A && x.push(A)) } } } p = this.Z.j; q = p.length;
            for (r = 0; r < q; r++) {
                var C = p[r]; if (C.visible && (x = C.interval, !(2 > d * x * b))) {
                    u = C.opacity; y = 1; if (1 !== u) { if (0 === u) continue; y = a.globalAlpha; a.globalAlpha = y * u } A = n[r]; var G = !1, H = C.strokeDashArray; null !== H && (G = !0, a.Us(H, C.strokeDashOffset)); if ("LineV" === C.figure && null !== C.stroke) { a.lineWidth = C.strokeWidth; yi(this, a, C.stroke, !1, !1, e, f); a.beginPath(); for (H = C = Math.floor(-m.x / d); H <= C + k; H++) { var O = H * d + m.x; 0 <= O && O <= g && dn(H, x, A) && (a.moveTo(O, 0), a.lineTo(O, h)) } a.stroke() } else if ("LineH" === C.figure && null !== C.stroke) {
                    a.lineWidth =
                        C.strokeWidth; yi(this, a, C.stroke, !1, !1, e, f); a.beginPath(); for (H = C = Math.floor(-m.y / c); H <= C + l; H++)O = H * c + m.y, 0 <= O && O <= h && dn(H, x, A) && (a.moveTo(0, O), a.lineTo(g, O)); a.stroke()
                    } else if ("BarV" === C.figure && null !== C.fill) for (yi(this, a, C.fill, !0, !1, e, f), C = C.width, isNaN(C) && (C = d), O = H = Math.floor(-m.x / d); O <= H + k; O++) { var S = O * d + m.x; 0 <= S && S <= g && dn(O, x, A) && a.fillRect(S, 0, C, h) } else if ("BarH" === C.figure && null !== C.fill) for (yi(this, a, C.fill, !0, !1, e, f), C = C.height, isNaN(C) && (C = c), O = H = Math.floor(-m.y / c); O <= H + l; O++)S = O * c +
                        m.y, 0 <= S && S <= h && dn(O, x, A) && a.fillRect(0, S, g, C); G && a.Ss(); 1 !== u && (a.globalAlpha = y)
                }
            } a.restore(); a.Uc(!1)
        } else if (this.wa === W.Graduated) {
            d = b.qj; b.qj = !0; e = this.naturalBounds; c = e.width; e = e.height; a.save(); a.beginPath(); a.rect(-1, -1, c + 1, e + 1); a.clip(); c = this.Bb(); c.jc(a, b); e = this.Fe() * b.scale; 0 >= e && (e = 1); f = c.actualBounds; g = this.Z.j; h = this.nj; k = g.length; for (l = 0; l < k; l++)if (p = g[l], m = h[l], n = m.length, p.visible && p !== c && 0 !== m.length) if (p instanceof Hg) {
                if (!(2 > this.graduatedTickUnit * p.interval * e)) for (q = p.measuredBounds,
                    r = p.strokeWidth * p.scale, x = p.alignmentFocus, x.Nb() && (x = gd), u = 0; u < n; u++)y = m[u][0], A = m[u][1], G = x, C = p.ub, C.reset(), C.translate(y.x + f.x, y.y + f.y), C.rotate(A + p.angle, 0, 0), C.translate(-q.width * G.x + G.offsetX + r / 2, -q.height * G.y + G.offsetY + r / 2), C.scale(p.scale, p.scale), Gl(p, !1), p.Fh.set(p.ub), p.Wk = p.scale, Hl(p, !1), p.jc(a, b), p.ub.reset()
            } else if (p instanceof Kh) for (null === this.kh && (this.kh = new Kh), q = this.kh, $m(q, p), p = 0; p < n; p++)u = m[p], 3 < u.length && (r = u[6], q.Rb = u[2], q.Bc = u[3], q.pc = u[4], q.pd = u[5], q.rc = u[8], q.arrange(r.x,
                r.y, r.width, r.height), r = u[6], q.arrange(r.x, r.y, r.width, r.height), x = u[7], u = u[8], y = q.ub, y.reset(), y.translate(r.x + f.x, r.y + f.y), y.translate(-x.x, -x.y), ol(q, y, u.x, u.y, u.width, u.height), Gl(q, !1), q.Fh.set(q.ub), q.Wk = q.scale, Hl(q, !1), q.jc(a, b)); b.qj = d; a.restore(); a.Uc(!0)
        } else {
        this.wa === W.Table && (a.lineCap = "butt", en(this, a, !0, this.tb, !0), en(this, a, !1, this.ob, !0), fn(this, a, !0, this.tb), fn(this, a, !1, this.ob), en(this, a, !0, this.tb, !1), en(this, a, !1, this.ob, !1)); if (d = this.isClipping) a.save(), E && this.type !== W.Spot &&
            Ga("Warning: Panel.isClipping set on non-Spot Panel: " + this.toString()); c = this.Bb(); e = this.Z.j; f = e.length; for (g = 0; g < f; g++)h = e[g], d && h === c && (a.clipInsteadOfFill = !0), h.jc(a, b), d && h === c && (a.clipInsteadOfFill = !1); d && (a.restore(), a.Uc(!0))
        }
    };
    function fn(a, b, c, d) {
        for (var e = d.length, f = a.actualBounds, g = a.naturalBounds, h = !0, k = 0; k < e; k++) {
            var l = d[k]; if (void 0 !== l) if (h) h = !1; else if (0 !== l.actual) {
                if (c) { if (l.position > f.height) continue } else if (l.position > f.width) continue; var m = l.separatorStrokeWidth; isNaN(m) && (m = c ? a.Jg : a.Ig); var n = l.separatorStroke; null === n && (n = c ? a.Xh : a.Hg); if (0 !== m && null !== n) {
                    yi(a, b, n, !1, !1, g, f); n = !1; var p = l.separatorDashArray; null === p && (p = c ? a.Wh : a.Vh); null !== p && (n = !0, b.Us(p, 0)); b.beginPath(); p = l.position + m; c ? p > f.height && (m -=
                        p - f.height) : p > f.width && (m -= p - f.width); l = l.position + m / 2; b.lineWidth = m; m = a.gb; c ? (l += m.top, p = f.width - m.right, b.moveTo(m.left, l), b.lineTo(p, l)) : (l += m.left, p = f.height - m.bottom, b.moveTo(l, m.top), b.lineTo(l, p)); b.stroke(); n && b.Ss()
                }
            }
        }
    }
    function en(a, b, c, d, e) {
        for (var f = d.length, g = a.actualBounds, h = a.naturalBounds, k = 0; k < f; k++) {
            var l = d[k]; if (void 0 !== l && null !== l.background && l.coversSeparators !== e && 0 !== l.actual) {
                var m = c ? g.height : g.width; if (!(l.position > m)) {
                    var n = l.vc(), p = l.separatorStrokeWidth; isNaN(p) && (p = c ? a.Jg : a.Ig); var q = l.separatorStroke; null === q && (q = c ? a.Xh : a.Hg); null === q && (p = 0); n -= p; p = l.position + p; n += l.actual; p + n > m && (n = m - p); 0 >= n || (m = a.gb, yi(a, b, l.background, !0, !1, h, g), c ? b.fillRect(m.left, p + m.top, g.width - (m.left + m.right), n) : b.fillRect(p +
                        m.left, m.top, n, g.height - (m.top + m.bottom)))
                }
            }
        }
    } function dn(a, b, c) { if (0 !== a % b) return !1; b = c.length; for (var d = 0; d < b; d++)if (0 === a % c[d]) return !1; return !0 } function hk(a) { return "LineV" === a || "BarV" === a }
    t.fk = function (a, b, c, d, e) {
        var f = this.ae(), g = this.transform, h = 1 / (g.m11 * g.m22 - g.m12 * g.m21), k = g.m22 * h, l = -g.m12 * h, m = -g.m21 * h, n = g.m11 * h, p = h * (g.m21 * g.dy - g.m22 * g.dx), q = h * (g.m12 * g.dx - g.m11 * g.dy); if (null !== this.areaBackground) return g = this.actualBounds, K.Wc(g.left, g.top, g.right, g.bottom, a, b, c, d, e); if (null !== this.background) return f = a * k + b * m + p, h = a * l + b * n + q, a = c * k + d * m + p, k = c * l + d * n + q, e.h(0, 0), c = this.naturalBounds, f = K.Wc(0, 0, c.width, c.height, f, h, a, k, e), e.transform(g), f; f || (k = 1, m = l = 0, n = 1, q = p = 0); h = a * k + b * m + p; a = a * l + b *
            n + q; k = c * k + d * m + p; c = c * l + d * n + q; e.h(k, c); d = (k - h) * (k - h) + (c - a) * (c - a); l = !1; n = this.Z.j; q = n.length; m = J.alloc(); p = null; b = Infinity; var r = null; this.isClipping && (r = J.alloc(), p = this.Bb(), (l = p.fk(h, a, k, c, r)) && (b = (h - r.x) * (h - r.x) + (a - r.y) * (a - r.y))); for (var u = 0; u < q; u++) { var x = n[u]; x.visible && x !== p && x.fk(h, a, k, c, m) && (l = !0, x = (h - m.x) * (h - m.x) + (a - m.y) * (a - m.y), x < d && (d = x, e.set(m))) } this.isClipping && (b > d && e.set(r), J.free(r)); J.free(m); f && e.transform(g); return l
    };
    t.v = function (a) { N.prototype.v.call(this, a); a = null; if (this.wa === W.Auto || this.wa === W.Link) a = this.Bb(); for (var b = this.Z.j, c = b.length, d = 0; d < c; d++) { var e = b[d]; (e === a || e.isPanelMain) && e.v(!0); if (!e.desiredSize.o()) { var f = ql(e, !1); (e instanceof lh || e instanceof W || e instanceof Kh || f !== nh) && e.v(!0) } } }; t.hm = function () { if (!1 === Dj(this)) { yj(this, !0); rl(this, !0); for (var a = this.Z.j, b = a.length, c = 0; c < b; c++)a[c].hm() } };
    t.jl = function () { if (0 !== (this.I & 2048) === !1) { Gl(this, !0); Hl(this, !0); for (var a = this.Z.j, b = a.length, c = 0; c < b; c++)a[c].qv() } }; t.qv = function () { Hl(this, !0); for (var a = this.Z.j, b = a.length, c = 0; c < b; c++)a[c].qv() };
    t.lm = function (a, b, c, d) {
        var e = this.kg; e.h(0, 0, 0, 0); var f = this.desiredSize, g = this.minSize; void 0 === c && (c = g.width, d = g.height); c = Math.max(c, g.width); d = Math.max(d, g.height); var h = this.maxSize; isNaN(f.width) || (a = Math.min(f.width, h.width)); isNaN(f.height) || (b = Math.min(f.height, h.height)); a = Math.max(c, a); b = Math.max(d, b); var k = this.gb; a = Math.max(a - k.left - k.right, 0); b = Math.max(b - k.top - k.bottom, 0); var l = this.Z.j; 0 !== l.length && this.wa.measure(this, a, b, l, e, c, d); a = e.width + k.left + k.right; k = e.height + k.top + k.bottom;
        isFinite(f.width) && (a = f.width); isFinite(f.height) && (k = f.height); a = Math.min(h.width, a); k = Math.min(h.height, k); a = Math.max(g.width, a); k = Math.max(g.height, k); a = Math.max(c, a); k = Math.max(d, k); Cc(e, a, k); Cc(this.naturalBounds, a, k); nl(this, 0, 0, a, k)
    }; t.Bb = function () { if (null === this.wi) { var a = this.Z.j, b = a.length; if (0 === b) return null; for (var c = 0; c < b; c++) { var d = a[c]; if (!0 === d.isPanelMain) return this.wi = d } this.wi = a[0] } return this.wi }; function Em(a) { return null !== a.part ? a.part.locationObject : null }
    t.uh = function (a, b, c, d) { var e = this.Z.j; this.actualBounds.h(a, b, c, d); if (0 !== e.length) { if (!this.desiredSize.o()) { a = ql(this, !0); var f = this.measuredBounds; b = f.width; f = f.height; var g = this.Wg, h = g.left + g.right; g = g.top + g.bottom; b === c && f === d && (a = nh); switch (a) { case nh: if (b > c || f > d) this.v(), this.measure(b > c ? c : b, f > d ? d : f, 0, 0); break; case oe: this.v(!0); this.measure(c + h, d + g, 0, 0); break; case bl: this.v(!0); this.measure(c + h, f + g, 0, 0); break; case cl: this.v(!0), this.measure(b + h, d + g, 0, 0) } } this.wa.arrange(this, e, this.kg) } };
    t.wh = function (a) { var b = this.naturalBounds, c = Em(this); if (Qc(0, 0, b.width, b.height, a.x, a.y)) { b = this.Z.j; for (var d = b.length, e = J.allocAt(0, 0); d--;) { var f = b[d]; if (f.visible || f === c) if (ac(e.set(a), f.transform), f.ea(e)) return J.free(e), !0 } J.free(e); return null === this.jb && null === this.fc ? !1 : !0 } return !1 }; t.Vs = function (a) { if (this.Hk === a) return this; for (var b = this.Z.j, c = b.length, d = 0; d < c; d++) { var e = b[d].Vs(a); if (null !== e) return e } return null };
    t.wk = function (a, b) { b(this, a); if (a instanceof W) { a = a.Z.j; for (var c = a.length, d = 0; d < c; d++)this.wk(a[d], b) } }; function Qj(a, b) { gn(a, a, b) } function gn(a, b, c) { c(b); b = b.Z.j; for (var d = b.length, e = 0; e < d; e++) { var f = b[e]; f instanceof W && gn(a, f, c) } } function hn(a, b) { jn(a, a, b) } function jn(a, b, c) { c(b); if (b instanceof W) { b = b.Z.j; for (var d = b.length, e = 0; e < d; e++)jn(a, b[e], c) } } t.bm = function (a) { return kn(this, this, a) };
    function kn(a, b, c) { if (c(b)) return b; if (b instanceof W) { b = b.Z.j; for (var d = b.length, e = 0; e < d; e++) { var f = kn(a, b[e], c); if (null !== f) return f } } return null } t.bb = function (a) { if (this.name === a) return this; var b = this.Z.j, c = b.length; null === this.gi && null === this.le || (c = ln(this)); for (var d = 0; d < c; d++) { var e = b[d]; if (e instanceof W) { var f = e.bb(a); if (null !== f) return f } if (e.name === a) return e } return null };
    function mn(a) {
        a = a.Z.j; for (var b = a.length, c = 0, d = 0; d < b; d++) {
            var e = a[d]; if (e instanceof W) c = Math.max(c, mn(e)); else if (e instanceof Hg) {
                a: {
                    switch (e.Yk) { case "None": case "Square": case "Ellipse": case "Circle": case "LineH": case "LineV": case "FramedRectangle": case "RoundedRectangle": case "Line1": case "Line2": case "Border": case "Cube1": case "Cube2": case "Junction": case "Cylinder1": case "Cylinder2": case "Cylinder3": case "Cylinder4": case "PlusLine": case "XLine": case "ThinCross": case "ThickCross": e = 0; break a }e =
                        e.ih / 2 * e.Nj * e.Fe()
                } c = Math.max(c, e)
            }
        } return c
    } t.ae = function () { return !(this.type === W.TableRow || this.type === W.TableColumn) };
    t.Tb = function (a, b, c) {
        if (!1 === this.pickable) return null; void 0 === b && (b = null); void 0 === c && (c = null); if (Ej(this)) return null; var d = this.naturalBounds, e = 1 / this.Fe(), f = this.ae(), g = f ? a : ac(J.allocAt(a.x, a.y), this.transform), h = this.diagram, k = 10, l = 5; null !== h && (k = h.fm("extraTouchArea"), l = k / 2); if (Qc(-(l * e), -(l * e), d.width + k * e, d.height + k * e, g.x, g.y)) {
            if (!this.isAtomic) {
                e = this.Z.j; var m = e.length; h = J.alloc(); l = (k = this.isClipping) ? this.Bb() : null; if (k && (l.ae() ? ac(h.set(a), l.transform) : h.set(a), !l.ea(h))) return J.free(h),
                    f || J.free(g), null; for (var n = Em(this); m--;) { var p = e[m]; if (p.visible || p === n) if (p.ae() ? ac(h.set(a), p.transform) : h.set(a), !k || p !== l) { var q = null; p instanceof W ? q = p.Tb(h, b, c) : !0 === p.pickable && p.ea(h) && (q = p); if (null !== q && (null !== b && (q = b(q)), null !== q && (null === c || c(q)))) return J.free(h), f || J.free(g), q } } J.free(h)
            } if (null === this.background && null === this.areaBackground) return f || J.free(g), null; a = Qc(0, 0, d.width, d.height, g.x, g.y) ? this : null; f || J.free(g); return a
        } f || J.free(g); return null
    };
    t.Ji = function (a, b, c, d) {
        if (!1 === this.pickable) return !1; void 0 === b && (b = null); void 0 === c && (c = null); var e = this.naturalBounds, f = this.ae(), g = f ? a : ac(J.allocAt(a.x, a.y), this.transform), h = this.type === W.TableRow || this.type === W.TableColumn; e = Qc(0, 0, e.width, e.height, g.x, g.y); if (h || e) {
            if (!this.isAtomic) {
                h = this.Z.j; for (var k = h.length, l = J.alloc(), m = Em(this); k--;) {
                    var n = h[k]; if (n.visible || n === m) {
                        n.ae() ? ac(l.set(a), n.transform) : l.set(a); var p = n; n = n instanceof W ? n : null; (null !== n ? n.Ji(l, b, c, d) : p.ea(l)) && !1 !== p.pickable &&
                            (null !== b && (p = b(p)), null === p || null !== c && !c(p) || d.add(p))
                    }
                } J.free(l)
            } f || J.free(g); return e && (null !== this.background || null !== this.areaBackground)
        } f || J.free(g); return !1
    };
    t.pg = function (a, b, c, d, e, f) {
        if (!1 === this.pickable) return !1; void 0 === b && (b = null); void 0 === c && (c = null); var g = f; void 0 === f && (g = $b.alloc(), g.reset()); g.multiply(this.transform); if (this.vh(a, g)) return nn(this, b, c, e), void 0 === f && $b.free(g), !0; if (this.Kc(a, g)) {
            if (!this.isAtomic) for (var h = Em(this), k = this.Z.j, l = k.length; l--;) {
                var m = k[l]; if (m.visible || m === h) {
                    var n = m.actualBounds, p = this.naturalBounds; if (!(n.x > p.width || n.y > p.height || 0 > n.x + n.width || 0 > n.y + n.height)) {
                        n = m; m = m instanceof W ? m : null; p = $b.alloc(); p.set(g);
                        if (null !== m ? m.pg(a, b, c, d, e, p) : pl(n, a, d, p)) null !== b && (n = b(n)), null === n || null !== c && !c(n) || e.add(n); $b.free(p)
                    }
                }
            } void 0 === f && $b.free(g); return d
        } void 0 === f && $b.free(g); return !1
    }; function nn(a, b, c, d) { for (var e = a.Z.j, f = e.length; f--;) { var g = e[f]; if (g.visible) { var h = g.actualBounds, k = a.naturalBounds; h.x > k.width || h.y > k.height || 0 > h.x + h.width || 0 > h.y + h.height || (g instanceof W && nn(g, b, c, d), null !== b && (g = b(g)), null === g || null !== c && !c(g) || d.add(g)) } } }
    t.qg = function (a, b, c, d, e, f) {
        if (!1 === this.pickable) return !1; void 0 === c && (c = null); void 0 === d && (d = null); var g = this.naturalBounds, h = this.ae(), k = h ? a : ac(J.allocAt(a.x, a.y), this.transform), l = h ? b : ac(J.allocAt(b.x, b.y), this.transform), m = k.Ee(l), n = 0 < k.x && k.x < g.width && 0 < k.y && k.y < g.height || cc(k.x, k.y, 0, 0, 0, g.height) <= m || cc(k.x, k.y, 0, g.height, g.width, g.height) <= m || cc(k.x, k.y, g.width, g.height, g.width, 0) <= m || cc(k.x, k.y, g.width, 0, 0, 0) <= m; g = k.ed(0, 0) <= m && k.ed(0, g.height) <= m && k.ed(g.width, 0) <= m && k.ed(g.width, g.height) <=
            m; h || (J.free(k), J.free(l)); if (n) { if (!this.isAtomic) { k = J.alloc(); l = J.alloc(); m = Em(this); for (var p = this.Z.j, q = p.length; q--;) { var r = p[q]; if (r.visible || r === m) { var u = r.actualBounds, x = this.naturalBounds; if (!h || !(u.x > x.width || u.y > x.height || 0 > u.x + u.width || 0 > u.y + u.height)) if (r.ae() ? (u = r.transform, ac(k.set(a), u), ac(l.set(b), u)) : (k.set(a), l.set(b)), u = r, r = r instanceof W ? r : null, null !== r ? r.qg(k, l, c, d, e, f) : u.nx(k, l, e)) null !== c && (u = c(u)), null === u || null !== d && !d(u) || f.add(u) } } J.free(k); J.free(l) } return e ? n : g } return !1
    };
    function Jm(a) { var b = null; a instanceof Hg && (b = a.spot1, b === Qd && (b = null), a = a.geometry, null !== a && null === b && (b = a.spot1)); null === b && (b = fd); return b } function Km(a) { var b = null; a instanceof Hg && (b = a.spot2, b === Qd && (b = null), a = a.geometry, null !== a && null === b && (b = a.spot2)); null === b && (b = ud); return b } t.add = function (a) { w(a, N, W, "add:element"); this.Lb(this.Z.count, a) }; t.O = function (a) { return this.Z.O(a) };
    t.Lb = function (a, b) {
    b instanceof R && v("Cannot add a Part to a Panel: " + b + "; use a Panel instead"); if (this === b || this.tg(b)) this === b && v("Cannot make a Panel contain itself: " + this.toString()), v("Cannot make a Panel indirectly contain itself: " + this.toString() + " already contains " + b.toString()); var c = b.panel; null !== c && c !== this && v("Cannot add a GraphObject that already belongs to another Panel to this Panel: " + b.toString() + ", already contained by " + c.toString() + ", cannot be shared by this Panel: " + this.toString());
        this.wa !== W.Grid || b instanceof Hg || v("Can only add Shapes to a Grid Panel, not: " + b); this.wa !== W.Graduated || b instanceof Hg || b instanceof Kh || v("Can only add Shapes or TextBlocks to a Graduated Panel, not: " + b); b.Wi(this); b.Ej = null; if (null !== this.itemArray) { var d = b.data; null !== d && "object" === typeof d && (null === this.Gd && (this.Gd = new Ub), this.Gd.add(d, b)) } var e = this.Z; d = -1; if (c === this) {
            for (var f = -1, g = this.Z.j, h = g.length, k = 0; k < h; k++)if (g[k] === b) { f = k; break } if (-1 !== f) {
                if (f === a || f + 1 >= e.count && a >= e.count) return;
                e.nb(f); d = f
            } else v("element " + b.toString() + " has panel " + c.toString() + " but is not contained by it.")
        } if (0 > a || a > e.count) a = e.count; e.Lb(a, b); if (0 === a || b.isPanelMain) this.wi = null; Dj(this) || this.v(); b.v(!1); null !== b.portId ? this.yh = !0 : b instanceof W && !0 === b.yh && (this.yh = !0); this.Pg = null; c = this.part; null !== c && (c.zj = null, c.Xg = NaN, this.yh && c instanceof V && (c.yh = !0), c.yh && c instanceof V && (c.tc = null), e = this.diagram, null !== e && e.undoManager.isUndoingRedoing || (-1 !== d && c.cb(rf, "elements", this, b, null, d, null), c.cb(qf,
            "elements", this, null, b, null, a), this.ug() || on(this, b, !1)))
    }; function pn(a, b) { a.I = b ? a.I | 16777216 : a.I & -16777217 } t.remove = function (a) { w(a, N, W, "remove:element"); for (var b = this.Z.j, c = b.length, d = -1, e = 0; e < c; e++)if (b[e] === a) { d = e; break } -1 !== d && this.zc(d, !0) }; t.nb = function (a) { E && B(a, W, "removeAt:idx"); 0 <= a && this.zc(a, !0) };
    t.zc = function (a, b) { var c = this.Z, d = c.O(a); d.Ej = null; d.Wi(null); if (null !== this.Gd) { var e = d.data; "object" === typeof e && this.Gd.remove(e) } c.nb(a); yj(this, !1); this.v(); this.wi === d && (this.wi = null); this.Pg = null; var f = this.part; null !== f && (f.zj = null, f.Xg = NaN, f.Mb(), f instanceof V && (d instanceof W ? d.wk(d, function (a, c) { Xl(f, c, b) }) : Xl(f, d, b)), c = this.diagram, null !== c && c.undoManager.isUndoingRedoing || f.cb(rf, "elements", this, d, null, a, null)) };
    W.prototype.getRowDefinition = function (a) { E && B(a, W, "getRowDefinition:idx"); 0 > a && Ca(a, ">= 0", W, "getRowDefinition:idx"); a = Math.round(a); var b = this.tb; if (void 0 === b) return null; if (void 0 === b[a]) { var c = new fk; c.Wi(this); c.isRow = !0; c.index = a; b[a] = c } return b[a] }; W.prototype.Hv = function (a) { E && B(a, W, "removeRowDefinition:idx"); 0 > a && Ca(a, ">= 0", W, "removeRowDefinition:idx"); a = Math.round(a); var b = this.tb; void 0 !== b && (this.cb(rf, "coldefs", this, b[a], null, a, null), b[a] && delete b[a], this.v()) };
    W.prototype.getColumnDefinition = function (a) { E && B(a, W, "getColumnDefinition:idx"); 0 > a && Ca(a, ">= 0", W, "getColumnDefinition:idx"); a = Math.round(a); var b = this.ob; if (void 0 === b) return null; if (void 0 === b[a]) { var c = new fk; c.Wi(this); c.isRow = !1; c.index = a; b[a] = c } return b[a] }; t = W.prototype; t.Fv = function (a) { E && B(a, W, "removeColumnDefinition:idx"); 0 > a && Ca(a, ">= 0", W, "removeColumnDefinition:idx"); a = Math.round(a); var b = this.ob; void 0 !== b && (this.cb(rf, "coldefs", this, b[a], null, a, null), b[a] && delete b[a], this.v()) };
    t.$y = function (a) { if (0 > a || this.type !== W.Table) return -1; for (var b = 0, c = this.tb, d = c.length, e = this.zi; e < d; e++) { var f = c[e]; if (void 0 !== f && (b += f.total, a < b)) break } return e }; t.Sy = function (a) { if (0 > a || this.type !== W.Table) return -1; for (var b = 0, c = this.ob, d = c.length, e = this.ii; e < d; e++) { var f = c[e]; if (void 0 !== f && (b += f.total, a < b)) break } return e };
    t.rz = function (a, b) { void 0 === b && (b = new J(NaN, NaN)); if (this.type !== W.Graduated) return b.h(NaN, NaN), b; a = Math.min(Math.max(a, this.graduatedMin), this.graduatedMax); var c = this.Bb(); c.geometry.kv((a - this.graduatedMin) / this.graduatedRange, b); return c.transform.va(b) }; t.sz = function (a) { if (this.type !== W.Graduated) return NaN; var b = this.Bb(); b.transform.Wd(a); return b.geometry.qx(a) * this.graduatedRange + this.graduatedMin }; function Ol(a) { a = a.Sh; return null !== a && a.u }
    function mh(a) {
        var b = a.Sh; if (null === b) null !== a.data && v("Template cannot have .data be non-null: " + a), a.Sh = b = new F; else if (b.u) return; var c = new F; pn(a, !1); a.wk(a, function (a, d) {
            var e = d.eb; if (null !== e) for (Ll(d, !1), e = e.iterator; e.next();) { var f = e.value; f.mode === qn && Ll(d, !0); var g = f.sourceName; null !== g && ("/" === g && pn(a, !0), g = ml(f, a, d), null !== g && (c.add(g), null === g.Jl && (g.Jl = new F), g.Jl.add(f))); b.add(f) } if (d instanceof W && d.type === W.Table) {
                if (0 < d.tb.length) for (a = d.tb, e = a.length, f = 0; f < e; f++)if (g = a[f], void 0 !==
                    g && null !== g.eb) for (var h = g.eb.iterator; h.next();) { var k = h.value; k.Sd = g; k.Dp = 2; k.Rl = g.index; b.add(k) } if (0 < d.ob.length) for (d = d.ob, a = d.length, e = 0; e < a; e++)if (f = d[e], void 0 !== f && null !== f.eb) for (g = f.eb.iterator; g.next();)h = g.value, h.Sd = f, h.Dp = 1, h.Rl = f.index, b.add(h)
            }
        }); for (var d = c.iterator; d.next();) { var e = d.value; if (null !== e.Jl) { Ll(e, !0); for (var f = e.Jl.iterator; f.next();) { var g = f.value; null === e.eb && (e.eb = new F); e.eb.add(g) } } e.Jl = null } for (var h = b.iterator; h.next();)if (d = h.value, e = d.Sd, null !== e) {
        d.Sd = null;
            g = d.targetProperty; var k = g.indexOf("."); 0 < k && e instanceof W && (f = g.substring(0, k), g = g.substr(k + 1), k = e.bb(f), null !== k ? (e = k, d.targetProperty = g) : Ga('Warning: unable to find GraphObject named "' + f + '" for Binding: ' + d.toString())); e instanceof fk ? (f = Jb(e.panel), d.aj = void 0 === f ? -1 : f, e.panel.Hk = d.aj) : e instanceof N ? (f = Jb(e), d.aj = void 0 === f ? -1 : f, e.Hk = d.aj) : v("Unknown type of binding target: " + e)
        } b.freeze(); a instanceof R && (a.dc() && a.bc(), E && !rn && a.wk(a, function (a, c) {
            if (c instanceof W && (c.type === W.Auto || c.type ===
                W.Spot || c.type === W.Graduated) && 1 >= c.elements.count && !(c instanceof R)) { var d = !1; if (1 === c.elements.count && (d = null !== c.itemArray, !d)) for (h = b.iterator; h.next();)if ("itemArray" === h.value.targetProperty) { d = !0; break } d || (Ga("Auto, Spot, or Graduated Panel should not have zero or one elements: " + c.toString() + " in " + a.toString()), rn = !0) }
        }))
    } t.Cy = function () { var a = this.copy(); hn(a, function (a) { a instanceof W && (a.Sh = null, a.kb = null); var b = a.eb; null !== b && (a.eb = null, b.each(function (b) { a.bind(b.copy()) })) }); return a };
    t.Fa = function (a) {
        var b = this.Sh; if (null !== b) for (void 0 === a && (a = ""), b = b.iterator; b.next();) {
            var c = b.value, d = c.sourceProperty; if ("" === a || "" === d || d === a) if (d = c.targetProperty, null !== c.converter || "" !== d) {
                d = this.data; var e = c.sourceName; if (null !== e) d = "" === e ? this : "/" === e ? this : "." === e ? this : ".." === e ? this : this.bb(e); else { var f = this.diagram; null !== f && c.isToModel && (d = f.model.modelData) } if (null === d) E && Ga("Binding error: missing GraphObject named " + e + " in " + this.toString()); else {
                    f = this; var g = c.aj; if (-1 !== g) {
                        if (f =
                            this.Vs(g), null === f) continue
                    } else null !== c.Sd && (f = c.Sd); "/" === e ? d = f.part : "." === e ? d = f : ".." === e && (d = f.panel); e = c.Dp; if (0 !== e) { if (!(f instanceof W)) continue; 1 === e ? f = f.getColumnDefinition(c.Rl) : 2 === e && (f = f.getRowDefinition(c.Rl)) } void 0 !== f && c.dw(f, d)
                }
            }
        }
    };
    function sn(a, b) { a = a.Z.j; for (var c = a.length, d = b.length, e = 0, f = null; e < c && !(f = a[e], f instanceof W && null !== f.data);)e++ , f = a[e]; if (c - e !== d) return !0; if (null === f) return 0 < d; for (var g = 0; e < c && g < d;) { f = a[e]; if (!(f instanceof W) || f.data !== b[g]) return !0; e++; g++ } return !1 }
    function ln(a) { if (a.type === W.Spot || a.type === W.Auto) return Math.min(a.Z.length, 1); if (a.type === W.Link) { a = a.Z; for (var b = a.length, c = 0; c < b; c++) { var d = a.O(c); if (!(d instanceof Hg && d.isPanelMain)) break } return c } return a.type === W.Table && 0 < a.Z.length && (a = a.Z.O(0), a.isPanelMain && a instanceof W && (a.type === W.TableRow || a.type === W.TableColumn)) ? 1 : 0 } t.st = function () { for (var a = ln(this); this.Z.length > a;)this.zc(this.Z.length - 1, !1); a = this.itemArray; if (null !== a) for (var b = a.length, c = 0; c < b; c++)tn(this, a[c], c) };
    t.mx = function (a) { if (void 0 === a || null === a || null === this.Gd) return null; z(a, "object", W, "findItemPanelForData"); return this.Gd.K(a) };
    function tn(a, b, c) {
        if (!(void 0 === b || null === b || 0 > c)) {
            var d = un(a, b), e = a.itemTemplateMap, f = null; null !== e && (f = e.K(d)); null === f && (vn || (vn = !0, Ga('No item template Panel found for category "' + d + '" on ' + a), Ga("  Using default item template."), d = new W, e = new Kh, e.bind(new Ti("text", "", Wa)), d.add(e), wn = d), f = wn); d = f; null !== d && (mh(d), d = d.copy(), 0 !== (d.I & 16777216) && (e = a.Ki(), null !== e && pn(e, !0)), "object" === typeof b && (null === a.Gd && (a.Gd = new Ub), a.Gd.add(b, d)), e = c + ln(a), a.Lb(e, d), d.kb = b, xn(a, e, c), d.kb = null, d.data =
                b)
        }
    } function xn(a, b, c) { for (a = a.Z; b < a.length;) { var d = a.O(b); if (d instanceof W) { var e = b, f = c; d.type === W.TableRow ? d.row = e : d.type === W.TableColumn && (d.column = e); d.itemIndex = f } b++; c++ } } function un(a, b) { if (null === b) return ""; a = a.kl; if ("function" === typeof a) a = a(b); else if ("string" === typeof a && "object" === typeof b) { if ("" === a) return ""; a = yn(b, a) } else return ""; if (void 0 === a) return ""; if ("string" === typeof a) return a; v("Panel.getCategoryForItemData found a non-string category for " + b + ": " + a); return "" }
    function on(a, b, c) { var d = b.enabledChanged; null !== d && d(b, c); if (b instanceof W) { b = b.Z.j; d = b.length; for (var e = 0; e < d; e++) { var f = b[e]; c && f instanceof W && !f.isEnabled || on(a, f, c) } } } function zn(a, b) { Sl.add(a, b) }
    na.Object.defineProperties(W.prototype, {
        type: { configurable: !0, get: function () { return this.wa }, set: function (a) { var b = this.wa; b !== a && (this.wa = a, this.wa === W.Grid ? this.isAtomic = !0 : this.wa === W.Table && bn(this), this.v(), this.g("type", b, a)) } }, elements: { configurable: !0, get: function () { return this.Z.iterator } }, naturalBounds: { configurable: !0, get: function () { return this.rc } }, padding: {
            configurable: !0, get: function () { return this.gb }, set: function (a) {
                "number" ===
                typeof a ? (0 > a && Ca(a, ">= 0", W, "padding"), a = new Hc(a)) : (w(a, Hc, W, "padding"), 0 > a.left && Ca(a.left, ">= 0", W, "padding:value.left"), 0 > a.right && Ca(a.right, ">= 0", W, "padding:value.right"), 0 > a.top && Ca(a.top, ">= 0", W, "padding:value.top"), 0 > a.bottom && Ca(a.bottom, ">= 0", W, "padding:value.bottom")); var b = this.gb; b.A(a) || (this.gb = a = a.J(), this.v(), this.g("padding", b, a))
            }
        }, defaultAlignment: {
            configurable: !0, get: function () { return this.rn }, set: function (a) {
                var b = this.rn; b.A(a) || (E && w(a, M, W, "defaultAlignment"),
                    this.rn = a = a.J(), this.v(), this.g("defaultAlignment", b, a))
            }
        }, defaultStretch: { configurable: !0, get: function () { return this.Gf }, set: function (a) { var b = this.Gf; b !== a && (tb(a, N, W, "defaultStretch"), this.Gf = a, this.v(), this.g("defaultStretch", b, a)) } }, defaultSeparatorPadding: {
            configurable: !0, get: function () { return void 0 === this.hj ? Zc : this.hj }, set: function (a) {
                if (void 0 !== this.hj) {
                    "number" === typeof a ? a = new Hc(a) : E && w(a, Hc, W, "defaultSeparatorPadding"); var b = this.hj; b.A(a) || (this.hj = a = a.J(),
                        this.v(), this.g("defaultSeparatorPadding", b, a))
                }
            }
        }, defaultRowSeparatorStroke: { configurable: !0, get: function () { return void 0 === this.Xh ? null : this.Xh }, set: function (a) { var b = this.Xh; b !== a && (null === a || "string" === typeof a || a instanceof zl) && (a instanceof zl && a.freeze(), this.Xh = a, this.S(), this.g("defaultRowSeparatorStroke", b, a)) } }, defaultRowSeparatorStrokeWidth: {
            configurable: !0, get: function () { return void 0 === this.Jg ? 1 : this.Jg }, set: function (a) {
                if (void 0 !== this.Jg) {
                    var b = this.Jg;
                    b !== a && isFinite(a) && 0 <= a && (this.Jg = a, this.v(), this.g("defaultRowSeparatorStrokeWidth", b, a))
                }
            }
        }, defaultRowSeparatorDashArray: {
            configurable: !0, get: function () { return void 0 === this.Wh ? null : this.Wh }, set: function (a) {
                if (void 0 !== this.Wh) {
                    var b = this.Wh; if (b !== a) {
                    null === a || Array.isArray(a) || Ba(a, "Array", W, "defaultRowSeparatorDashArray:value"); if (null !== a) {
                        for (var c = a.length, d = 0, e = 0; e < c; e++) {
                            var f = a[e]; "number" === typeof f && 0 <= f && isFinite(f) || v("defaultRowSeparatorDashArray value " + f + " at index " +
                                e + " must be a positive number or zero."); d += f
                        } if (0 === d) { if (null === b) return; a = null }
                    } this.Wh = a; this.S(); this.g("defaultRowSeparatorDashArray", b, a)
                    }
                }
            }
        }, defaultColumnSeparatorStroke: { configurable: !0, get: function () { return void 0 === this.Hg ? null : this.Hg }, set: function (a) { if (void 0 !== this.Hg) { var b = this.Hg; b !== a && (null === a || "string" === typeof a || a instanceof zl) && (a instanceof zl && a.freeze(), this.Hg = a, this.S(), this.g("defaultColumnSeparatorStroke", b, a)) } } }, defaultColumnSeparatorStrokeWidth: {
            configurable: !0,
            enumerable: !0, get: function () { return void 0 === this.Ig ? 1 : this.Ig }, set: function (a) { if (void 0 !== this.Ig) { var b = this.Ig; b !== a && isFinite(a) && 0 <= a && (this.Ig = a, this.v(), this.g("defaultColumnSeparatorStrokeWidth", b, a)) } }
        }, defaultColumnSeparatorDashArray: {
            configurable: !0, get: function () { return void 0 === this.Vh ? null : this.Vh }, set: function (a) {
                if (void 0 !== this.Vh) {
                    var b = this.Vh; if (b !== a) {
                    null === a || Array.isArray(a) || Ba(a, "Array", W, "defaultColumnSeparatorDashArray:value"); if (null !== a) {
                        for (var c = a.length,
                            d = 0, e = 0; e < c; e++) { var f = a[e]; "number" === typeof f && 0 <= f && isFinite(f) || v("defaultColumnSeparatorDashArray value " + f + " at index " + e + " must be a positive number or zero."); d += f } if (0 === d) { if (null === b) return; a = null }
                    } this.Vh = a; this.S(); this.g("defaultColumnSeparatorDashArray", b, a)
                    }
                }
            }
        }, viewboxStretch: { configurable: !0, get: function () { return this.Mp }, set: function (a) { var b = this.Mp; b !== a && (tb(a, N, W, "viewboxStretch"), this.Mp = a, this.v(), this.g("viewboxStretch", b, a)) } }, gridCellSize: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Pn }, set: function (a) { var b = this.Pn; if (!b.A(a)) { w(a, Zb, W, "gridCellSize"); a.o() && 0 !== a.width && 0 !== a.height || v("Invalid Panel.gridCellSize: " + a); this.Pn = a.J(); var c = this.diagram; null !== c && this === c.grid && zj(c); this.S(); this.g("gridCellSize", b, a) } }
        }, gridOrigin: {
            configurable: !0, get: function () { return this.Qn }, set: function (a) {
                var b = this.Qn; if (!b.A(a)) {
                    w(a, J, W, "gridOrigin"); a.o() || v("Invalid Panel.gridOrigin: " + a); this.Qn = a.J(); var c = this.diagram; null !==
                        c && this === c.grid && zj(c); this.S(); this.g("gridOrigin", b, a)
                }
            }
        }, graduatedMin: { configurable: !0, get: function () { return this.Mn }, set: function (a) { B(a, W, "graduatedMin"); var b = this.Mn; b !== a && (this.Mn = a, this.v(), this.g("graduatedMin", b, a), kl(this) && (a = this.part, null !== a && ll(this, a, "graduatedRange"))) } }, graduatedMax: {
            configurable: !0, get: function () { return this.Ln }, set: function (a) {
                B(a, W, "graduatedMax"); var b = this.Ln; b !== a && (this.Ln = a, this.v(), this.g("graduatedMax", b, a), kl(this) && (a =
                    this.part, null !== a && ll(this, a, "graduatedRange")))
            }
        }, graduatedRange: { configurable: !0, get: function () { return this.graduatedMax - this.graduatedMin } }, graduatedTickUnit: { configurable: !0, get: function () { return this.On }, set: function (a) { B(a, W, "graduatedTickUnit"); var b = this.On; b !== a && 0 < a && (this.On = a, this.v(), this.g("graduatedTickUnit", b, a)) } }, graduatedTickBase: {
            configurable: !0, get: function () { return this.Nn }, set: function (a) {
                B(a, W, "graduatedTickBase"); var b = this.Nn; b !==
                    a && (this.Nn = a, this.v(), this.g("graduatedTickBase", b, a))
            }
        }, yh: { configurable: !0, get: function () { return 0 !== (this.I & 8388608) }, set: function (a) { 0 !== (this.I & 8388608) !== a && (this.I ^= 8388608) } }, rowCount: { configurable: !0, get: function () { return void 0 === this.tb ? 0 : this.tb.length } }, columnCount: { configurable: !0, get: function () { return void 0 === this.ob ? 0 : this.ob.length } }, rowSizing: {
            configurable: !0, get: function () { return void 0 === this.Jj ? cn : this.Jj }, set: function (a) {
                if (void 0 !==
                    this.Jj) { var b = this.Jj; b !== a && (E && a !== cn && a !== Nm && v("Panel.rowSizing must be RowColumnDefinition.ProportionalExtra or RowColumnDefinition.None, not: " + a), this.Jj = a, this.v(), this.g("rowSizing", b, a)) }
            }
        }, columnSizing: {
            configurable: !0, get: function () { return void 0 === this.fj ? cn : this.fj }, set: function (a) {
                if (void 0 !== this.fj) {
                    var b = this.fj; b !== a && (E && a !== cn && a !== Nm && v("Panel.columnSizing must be RowColumnDefinition.ProportionalExtra or RowColumnDefinition.None, not: " + a), this.fj = a, this.v(), this.g("columnSizing",
                        b, a))
                }
            }
        }, topIndex: { configurable: !0, get: function () { return void 0 === this.zi ? 0 : this.zi }, set: function (a) { if (void 0 !== this.zi) { var b = this.zi; b !== a && ((!isFinite(a) || 0 > a) && v("Panel.topIndex must be greater than zero and a real number, not: " + a), this.zi = a, this.v(), this.g("topIndex", b, a)) } } }, leftIndex: {
            configurable: !0, get: function () { return void 0 === this.ii ? 0 : this.ii }, set: function (a) {
                if (void 0 !== this.ii) {
                    var b = this.ii; b !== a && ((!isFinite(a) || 0 > a) && v("Panel.leftIndex must be greater than zero and a real number, not: " +
                        a), this.ii = a, this.v(), this.g("leftIndex", b, a))
                }
            }
        }, data: {
            configurable: !0, get: function () { return this.kb }, set: function (a) {
                var b = this.kb; if (b !== a) {
                    var c = this instanceof R && !(this instanceof Cf); c && z(a, "object", W, "data"); mh(this); this.kb = a; var d = this.diagram; null !== d && (c ? (c = d.partManager, this instanceof Q ? (null !== b && c.Gg.remove(b), null !== a && c.Gg.add(a, this)) : this instanceof R && (null !== b && c.Oe.remove(b), null !== a && c.Oe.add(a, this))) : (c = this.panel, null !== c && null !== c.Gd && (null !== b && c.Gd.remove(b),
                        null !== a && c.Gd.add(a, this)))); this.g("data", b, a); null !== d && d.undoManager.isUndoingRedoing || null !== a && this.Fa()
                }
            }
        }, itemIndex: { configurable: !0, get: function () { return this.co }, set: function (a) { var b = this.co; b !== a && (this.co = a, this.g("itemIndex", b, a)) } }, itemArray: {
            configurable: !0, get: function () { return this.gi }, set: function (a) {
                var b = this.gi; if (b !== a || null !== a && sn(this, a)) {
                E && null !== a && !Ka(a) && v("Panel.itemArray must be an Array-like object or null, not: " + a); var c = this.diagram;
                    b !== a && (null !== c && null !== b && Wj(c.partManager, this), this.gi = a, null !== c && null !== a && Sj(c.partManager, this)); this.g("itemArray", b, a); null !== c && c.undoManager.isUndoingRedoing || this.st()
                }
            }
        }, itemTemplate: {
            configurable: !0, get: function () { return null === this.le ? null : this.le.K("") }, set: function (a) {
                if (null === this.le) { if (null === a) return; this.le = new Ub } var b = this.le.K(""); b !== a && (w(a, W, W, "itemTemplate"), (a instanceof R || a.isPanelMain) && v("Panel.itemTemplate must not be a Part or be Panel.isPanelMain: " +
                    a), this.le.add("", a), this.g("itemTemplate", b, a), a = this.diagram, null !== a && a.undoManager.isUndoingRedoing || this.st())
            }
        }, itemTemplateMap: {
            configurable: !0, get: function () { return this.le }, set: function (a) {
                var b = this.le; if (b !== a) {
                    w(a, Ub, W, "itemTemplateMap"); for (var c = a.iterator; c.next();) { var d = c.value; E && (d instanceof R || d.isPanelMain) && v("Template in Panel.itemTemplateMap must not be a Part or be Panel.isPanelMain: " + d) } this.le = a; this.g("itemTemplateMap", b, a); a = this.diagram; null !== a && a.undoManager.isUndoingRedoing ||
                        this.st()
                }
            }
        }, itemCategoryProperty: { configurable: !0, get: function () { return this.kl }, set: function (a) { var b = this.kl; b !== a && ("string" !== typeof a && "function" !== typeof a && Ba(a, "string or function", W, "itemCategoryProperty"), this.kl = a, this.g("itemCategoryProperty", b, a)) } }, isAtomic: { configurable: !0, get: function () { return 0 !== (this.I & 1048576) }, set: function (a) { var b = 0 !== (this.I & 1048576); b !== a && (z(a, "boolean", W, "isAtomic"), this.I ^= 1048576, this.g("isAtomic", b, a)) } }, isClipping: {
            configurable: !0,
            enumerable: !0, get: function () { return 0 !== (this.I & 2097152) }, set: function (a) { var b = 0 !== (this.I & 2097152); b !== a && (z(a, "boolean", W, "isClipping"), this.I ^= 2097152, this.v(), this.g("isClipping", b, a)) }
        }, isOpposite: { configurable: !0, get: function () { return 0 !== (this.I & 33554432) }, set: function (a) { var b = 0 !== (this.I & 33554432); b !== a && (z(a, "boolean", W, "isOpposite"), this.I ^= 33554432, this.v(), this.g("isOpposite", b, a)) } }, isEnabled: {
            configurable: !0, get: function () { return 0 !== (this.I & 4194304) }, set: function (a) {
                var b =
                    0 !== (this.I & 4194304); if (b !== a) { z(a, "boolean", W, "isEnabled"); var c = null === this.panel || this.panel.ug(); this.I ^= 4194304; this.g("isEnabled", b, a); b = this.diagram; null !== b && b.undoManager.isUndoingRedoing || c && on(this, this, a) }
            }
        }, alignmentFocusName: { configurable: !0, get: function () { return this.Bg }, set: function (a) { var b = this.Bg; b !== a && (E && z(a, "string", W, "alignmentFocusName"), this.Bg = a, this.v(), this.g("alignmentFocusName", b, a)) } }
    });
    na.Object.defineProperties(W, {
        Position: { configurable: !0, get: function () { return Sl.K("Position") } }, Horizontal: { configurable: !0, get: function () { return Sl.K("Horizontal") } }, Vertical: { configurable: !0, get: function () { return Sl.K("Vertical") } }, Spot: { configurable: !0, get: function () { return Sl.K("Spot") } }, Auto: { configurable: !0, get: function () { return Sl.K("Auto") } }, Table: { configurable: !0, get: function () { return Sl.K("Table") } }, Viewbox: {
            configurable: !0,
            enumerable: !0, get: function () { return Sl.K("Viewbox") }
        }, TableRow: { configurable: !0, get: function () { return Sl.K("TableRow") } }, TableColumn: { configurable: !0, get: function () { return Sl.K("TableColumn") } }, Link: { configurable: !0, get: function () { return Sl.K("Link") } }, Grid: { configurable: !0, get: function () { return Sl.K("Grid") } }, Graduated: { configurable: !0, get: function () { return Sl.K("Graduated") } }
    }); W.prototype.findItemPanelForData = W.prototype.mx;
    W.prototype.rebuildItemElements = W.prototype.st; W.prototype.updateTargetBindings = W.prototype.Fa; W.prototype.copyTemplate = W.prototype.Cy; W.prototype.graduatedValueForPoint = W.prototype.sz; W.prototype.graduatedPointForValue = W.prototype.rz; W.prototype.findColumnForLocalX = W.prototype.Sy; W.prototype.findRowForLocalY = W.prototype.$y; W.prototype.removeColumnDefinition = W.prototype.Fv; W.prototype.removeRowDefinition = W.prototype.Hv; W.prototype.removeAt = W.prototype.nb; W.prototype.remove = W.prototype.remove;
    W.prototype.insertAt = W.prototype.Lb; W.prototype.elt = W.prototype.O; W.prototype.add = W.prototype.add; W.prototype.findObject = W.prototype.bb; W.prototype.findInVisualTree = W.prototype.bm; W.prototype.walkVisualTreeFrom = W.prototype.wk; W.prototype.findMainElement = W.prototype.Bb; var rn = !1, vn = !1, wn = null, Sl = new Ub; W.className = "Panel"; W.definePanelLayout = zn; zn("Position", new Dm); zn("Vertical", new Gm); zn("Auto", new Im); zn("Link", new Sm); zn("Grid", new Rm);
    function fk() { qb(this); this.cg = null; this.Lr = !0; this.Ua = 0; this.Sc = NaN; this.Zg = 0; this.Yg = Infinity; this.xb = Qd; this.ua = this.ma = 0; this.eb = null; this.wp = An; this.ye = al; this.rp = this.gg = null; this.sp = NaN; this.jb = this.Lj = null; this.mn = !1 }
    fk.prototype.copy = function () { var a = new fk; a.Lr = this.Lr; a.Ua = this.Ua; a.Sc = this.Sc; a.Zg = this.Zg; a.Yg = this.Yg; a.xb = this.xb; a.ma = this.ma; a.ua = this.ua; a.ye = this.ye; a.wp = this.wp; null === this.gg ? a.gg = null : a.gg = this.gg.J(); a.rp = this.rp; a.sp = this.sp; a.Lj = null; null !== this.Lj && (a.separatorDashArray = Ma(this.separatorDashArray)); a.jb = this.jb; a.mn = this.mn; a.eb = this.eb; return a }; t = fk.prototype;
    t.Zl = function (a) {
        w(a, fk, fk, "copyFrom:pd"); a.isRow ? this.height = a.height : this.width = a.width; this.minimum = a.minimum; this.maximum = a.maximum; this.alignment = a.alignment; this.stretch = a.stretch; this.sizing = a.sizing; this.gg = null === a.separatorPadding ? null : a.separatorPadding.J(); this.separatorStroke = a.separatorStroke; this.separatorStrokeWidth = a.separatorStrokeWidth; this.Lj = null; a.separatorDashArray && (this.Lj = Ma(a.separatorDashArray)); this.background = a.background; this.coversSeparators = a.coversSeparators; this.eb =
            a.eb
    }; t.hb = function (a) { a.classType === fk ? this.sizing = a : Fa(this, a) }; t.toString = function () { return "RowColumnDefinition " + (this.isRow ? "(Row " : "(Column ") + this.index + ") #" + Jb(this) }; t.Wi = function (a) { this.cg = a };
    t.Tu = function () {
        var a = 0, b = 0, c = this.cg, d = this.isRow; if (null !== c && c.type === W.Table) for (var e = d ? c.tb.length : c.ob.length, f = 0; f < e; f++) { var g = d ? c.tb[f] : c.ob[f]; if (void 0 !== g) { b = g.index; break } } this.index !== b && (b = this.separatorStroke, null === b && null !== c && (b = this.isRow ? c.defaultRowSeparatorStroke : c.defaultColumnSeparatorStroke), null !== b && (a = this.separatorStrokeWidth, isNaN(a) && (null !== c ? a = this.isRow ? c.defaultRowSeparatorStrokeWidth : c.defaultColumnSeparatorStrokeWidth : a = 0))); b = this.gg; if (null === b) if (null !== c) b =
            c.defaultSeparatorPadding; else return a; return a + (this.isRow ? b.top : b.left)
    };
    t.vc = function () {
        var a = 0, b = this.cg, c = 0, d = this.isRow; if (null !== b && b.type === W.Table) for (var e = d ? b.tb.length : b.ob.length, f = 0; f < e; f++) { var g = d ? b.tb[f] : b.ob[f]; if (void 0 !== g) { c = g.index; break } } this.index !== c && (c = this.separatorStroke, null === c && null !== b && (c = d ? b.defaultRowSeparatorStroke : b.defaultColumnSeparatorStroke), null !== c && (a = this.separatorStrokeWidth, isNaN(a) && (null !== b ? a = d ? b.defaultRowSeparatorStrokeWidth : b.defaultColumnSeparatorStrokeWidth : a = 0))); d = this.gg; if (null === d) if (null !== b) d = b.defaultSeparatorPadding;
        else return a; return a + (this.isRow ? d.top + d.bottom : d.left + d.right)
    }; t.zb = function (a, b, c) { var d = this.cg; if (null !== d && (d.cb(of, a, this, b, c, void 0, void 0), null !== this.eb && (b = d.diagram, null !== b && !b.skipsModelSourceBindings && (d = d.Ki(), null !== d && (b = d.data, null !== b))))) for (c = this.eb.iterator; c.next();)c.value.Eq(this, b, a, d) }; function Mm(a) { if (a.sizing === An) { var b = a.cg; return a.isRow ? b.rowSizing : b.columnSizing } return a.sizing }
    t.bind = function (a) { a.Sd = this; var b = this.panel; if (null !== b) { var c = b.Ki(); null !== c && Ol(c) && v("Cannot add a Binding to a RowColumnDefinition that is already frozen: " + a + " on " + b) } null === this.eb && (this.eb = new F); this.eb.add(a) };
    na.Object.defineProperties(fk.prototype, {
        panel: { configurable: !0, get: function () { return this.cg } }, isRow: { configurable: !0, get: function () { return this.Lr }, set: function (a) { this.Lr = a } }, index: { configurable: !0, get: function () { return this.Ua }, set: function (a) { this.Ua = a } }, height: {
            configurable: !0, get: function () { return this.Sc }, set: function (a) {
                var b = this.Sc; b !== a && (E && z(a, "number", fk, "height"), 0 > a && Ca(a, ">= 0", fk, "height"), this.Sc = a, this.actual = this.ma, null !==
                    this.panel && this.panel.v(), this.zb("height", b, a))
            }
        }, width: { configurable: !0, get: function () { return this.Sc }, set: function (a) { var b = this.Sc; b !== a && (E && z(a, "number", fk, "width"), 0 > a && Ca(a, ">= 0", fk, "width"), this.Sc = a, this.actual = this.ma, null !== this.panel && this.panel.v(), this.zb("width", b, a)) } }, minimum: {
            configurable: !0, get: function () { return this.Zg }, set: function (a) {
                var b = this.Zg; b !== a && (E && z(a, "number", fk, "minimum"), (0 > a || !isFinite(a)) && Ca(a, ">= 0", fk, "minimum"), this.Zg = a, this.actual =
                    this.ma, null !== this.panel && this.panel.v(), this.zb("minimum", b, a))
            }
        }, maximum: { configurable: !0, get: function () { return this.Yg }, set: function (a) { var b = this.Yg; b !== a && (E && z(a, "number", fk, "maximum"), 0 > a && Ca(a, ">= 0", fk, "maximum"), this.Yg = a, this.actual = this.ma, null !== this.panel && this.panel.v(), this.zb("maximum", b, a)) } }, alignment: {
            configurable: !0, get: function () { return this.xb }, set: function (a) {
                var b = this.xb; b.A(a) || (E && w(a, M, fk, "alignment"), this.xb = a.J(), null !== this.panel && this.panel.v(),
                    this.zb("alignment", b, a))
            }
        }, stretch: { configurable: !0, get: function () { return this.ye }, set: function (a) { var b = this.ye; b !== a && (E && tb(a, N, fk, "stretch"), this.ye = a, null !== this.panel && this.panel.v(), this.zb("stretch", b, a)) } }, separatorPadding: {
            configurable: !0, get: function () { return this.gg }, set: function (a) {
                "number" === typeof a ? a = new Hc(a) : null !== a && E && w(a, Hc, fk, "separatorPadding"); var b = this.gg; null !== a && null !== b && b.A(a) || (null !== a && (a = a.J()), this.gg = a, null !== this.panel && this.panel.v(),
                    this.zb("separatorPadding", b, a))
            }
        }, separatorStroke: { configurable: !0, get: function () { return this.rp }, set: function (a) { var b = this.rp; b !== a && (null !== a && Wl(a, "RowColumnDefinition.separatorStroke"), a instanceof zl && a.freeze(), this.rp = a, null !== this.panel && this.panel.v(), this.zb("separatorStroke", b, a)) } }, separatorStrokeWidth: {
            configurable: !0, get: function () { return this.sp }, set: function (a) {
                var b = this.sp; b !== a && (this.sp = a, null !== this.panel && this.panel.v(), this.zb("separatorStrokeWidth",
                    b, a))
            }
        }, separatorDashArray: {
            configurable: !0, get: function () { return this.Lj }, set: function (a) {
                var b = this.Lj; if (b !== a) {
                null === a || Array.isArray(a) || Ba(a, "Array", fk, "separatorDashArray:value"); if (null !== a) { for (var c = a.length, d = 0, e = 0; e < c; e++) { var f = a[e]; "number" === typeof f && 0 <= f && isFinite(f) || v("separatorDashArray value " + f + " at index " + e + " must be a positive number or zero."); d += f } if (0 === d) { if (null === b) return; a = null } } this.Lj = a; null !== this.panel && this.panel.S(); this.zb("separatorDashArray",
                    b, a)
                }
            }
        }, background: { configurable: !0, get: function () { return this.jb }, set: function (a) { var b = this.jb; b !== a && (null !== a && Wl(a, "RowColumnDefinition.background"), a instanceof zl && a.freeze(), this.jb = a, null !== this.panel && this.panel.S(), this.zb("background", b, a)) } }, coversSeparators: { configurable: !0, get: function () { return this.mn }, set: function (a) { var b = this.mn; b !== a && (z(a, "boolean", fk, "coversSeparators"), this.mn = a, null !== this.panel && this.panel.S(), this.zb("coversSeparators", b, a)) } },
        sizing: { configurable: !0, get: function () { return this.wp }, set: function (a) { var b = this.wp; b !== a && (E && tb(a, fk, fk, "sizing"), this.wp = a, null !== this.panel && this.panel.v(), this.zb("sizing", b, a)) } }, actual: { configurable: !0, get: function () { return this.ma }, set: function (a) { this.ma = isNaN(this.Sc) ? Math.max(Math.min(this.Yg, a), this.Zg) : Math.max(Math.min(this.Yg, this.Sc), this.Zg) } }, total: {
            configurable: !0, get: function () { return this.ma + this.vc() }, set: function (a) {
            this.ma = isNaN(this.Sc) ?
                Math.max(Math.min(this.Yg, a), this.Zg) : Math.max(Math.min(this.Yg, this.Sc), this.Zg); this.ma = Math.max(0, this.ma - this.vc())
            }
        }, position: { configurable: !0, get: function () { return this.ua }, set: function (a) { this.ua = a } }
    }); fk.prototype.bind = fk.prototype.bind; fk.prototype.computeEffectiveSpacing = fk.prototype.vc; fk.prototype.computeEffectiveSpacingTop = fk.prototype.Tu; var An = new D(fk, "Default", 0), Nm = new D(fk, "None", 1), cn = new D(fk, "ProportionalExtra", 2); fk.className = "RowColumnDefinition"; fk.Default = An;
    fk.None = Nm; fk.ProportionalExtra = cn; function Hg() { N.call(this); this.Rd = this.sa = null; this.Yk = "None"; this.Kn = al; this.Ic = this.Zk = "black"; this.ih = 1; this.Ml = "butt"; this.Nl = "miter"; this.Nj = 10; this.gh = null; this.hh = 0; this.ff = this.ef = Qd; this.So = this.Ro = NaN; this.Vn = !1; this.Uo = null; this.bl = this.Tl = "None"; this.Ed = 1; this.Dd = 0; this.Bd = 1; this.Cd = null } ma(Hg, N);
    Hg.prototype.cloneProtected = function (a) { N.prototype.cloneProtected.call(this, a); a.sa = this.sa; a.Yk = this.Yk; a.Kn = this.Kn; a.Rd = this.Rd; a.Zk = this.Zk; a.Ic = this.Ic; a.ih = this.ih; a.Ml = this.Ml; a.Nl = this.Nl; a.Nj = this.Nj; null !== this.gh && (a.gh = Ma(this.gh)); a.hh = this.hh; a.ef = this.ef.J(); a.ff = this.ff.J(); a.Ro = this.Ro; a.So = this.So; a.Vn = this.Vn; a.Uo = this.Uo; a.Tl = this.Tl; a.bl = this.bl; a.Ed = this.Ed; a.Dd = this.Dd; a.Bd = this.Bd; a.Cd = this.Cd }; t = Hg.prototype;
    t.hb = function (a) { a === nh || a === ph || a === dl || a === al ? this.geometryStretch = a : N.prototype.hb.call(this, a) }; t.toString = function () { return "Shape(" + ("None" !== this.figure ? this.figure : "None" !== this.toArrow ? this.toArrow : this.fromArrow) + ")#" + Jb(this) };
    function Bn(a, b, c, d) {
        var e = c.length; if (!(4 > e)) {
            var f = d.measuredBounds, g = Math.max(1, f.width); f = f.height; for (var h = c[0], k = c[1], l, m, n, p, q, r, u = 0, x = Qa(), y = 2; y < e; y += 2)l = c[y], m = c[y + 1], n = l - h, h = m - k, 0 === n && (n = .001), p = h / n, q = Math.atan2(h, n), r = Math.sqrt(n * n + h * h), x.push([n, q, p, r]), u += r, h = l, k = m; h = c[0]; k = c[1]; n = d.measuredBounds.width; d instanceof Hg && (n -= d.strokeWidth); 1 > n && (n = 1); e = c = n; l = g / 2; m = 0 === l ? !1 : !0; y = 0; r = x[y]; n = r[0]; q = r[1]; p = r[2]; r = r[3]; for (var A = 0; .1 <= u;) {
            0 === A && (m ? (e = c, e -= l, u -= l, m = !1) : e = c, 0 === e && (e = 1));
                if (e > u) { Ta(x); return } e > r ? (A = e - r, e = r) : A = 0; var C = Math.sqrt(e * e / (1 + p * p)); 0 > n && (C = -C); h += C; k += p * C; a.translate(h, k); a.rotate(q); a.translate(-(g / 2), -(f / 2)); 0 === A && d.Gi(a, b); a.translate(g / 2, f / 2); a.rotate(-q); a.translate(-h, -k); u -= e; r -= e; if (0 !== A) { y++; if (y === x.length) { Ta(x); return } r = x[y]; n = r[0]; q = r[1]; p = r[2]; r = r[3]; e = A }
            } Ta(x)
        }
    }
    t.Gi = function (a, b) {
        var c = this.Ic, d = this.Zk; if (null !== c || null !== d) {
            var e = this.actualBounds, f = this.naturalBounds; null !== d && yi(this, a, d, !0, !1, f, e); null !== c && yi(this, a, c, !1, !1, f, e); e = this.part; f = this.ih; 0 === f && null !== e && (f = e instanceof Cf && e.type === W.Link && "Selection" === e.category && e.adornedObject instanceof Hg && e.adornedPart.Bb() === e.adornedObject ? e.adornedObject.strokeWidth : 0); a.lineWidth = f; a.lineJoin = this.Nl; a.lineCap = this.Ml; a.miterLimit = this.Nj; var g = !1; e && b.Ge("drawShadows") && (g = e.isShadowed); var h =
                !0; null !== c && null === d && (h = !1); e = !1; var k = this.strokeDashArray; null !== k && (e = !0, a.Us(k, this.hh)); var l = this.sa; if (null !== l) {
                    if (l.type === pe) a.beginPath(), a.moveTo(l.startX, l.startY), a.lineTo(l.endX, l.endY), null !== d && a.Vd(d), 0 !== f && null !== c && a.$i(); else if (l.type === xe) {
                        var m = l.startX, n = l.startY, p = l.endX, q = l.endY; k = Math.min(m, p); l = Math.min(n, q); m = Math.abs(p - m); n = Math.abs(q - n); null !== d && (a.beginPath(), a.rect(k, l, m, n), a.Vd(d)); null !== c && (p = d = c = 0, h && g && (c = a.shadowOffsetX, d = a.shadowOffsetY, p = a.shadowBlur,
                            a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0), 0 !== f && (a.beginPath(), a.rect(k, l, m, n), a.$i()), h && g && (a.shadowOffsetX = c, a.shadowOffsetY = d, a.shadowBlur = p))
                    } else if (l.type === ye) n = l.startX, k = l.startY, p = l.endX, q = l.endY, l = Math.abs(p - n) / 2, m = Math.abs(q - k) / 2, n = Math.min(n, p) + l, k = Math.min(k, q) + m, a.beginPath(), a.moveTo(n, k - m), a.bezierCurveTo(n + K.Ag * l, k - m, n + l, k - K.Ag * m, n + l, k), a.bezierCurveTo(n + l, k + K.Ag * m, n + K.Ag * l, k + m, n, k + m), a.bezierCurveTo(n - K.Ag * l, k + m, n - l, k + K.Ag * m, n - l, k), a.bezierCurveTo(n - l, k - K.Ag * m, n - K.Ag *
                        l, k - m, n, k - m), a.closePath(), null !== d && a.Vd(d), 0 !== f && null !== c && (h && g ? (f = a.shadowOffsetX, g = a.shadowOffsetY, c = a.shadowBlur, a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0, a.$i(), a.shadowOffsetX = f, a.shadowOffsetY = g, a.shadowBlur = c) : a.$i()); else if (l.type === ne) for (k = l.figures, l = k.length, m = 0; m < l; m++) {
                            n = k.j[m]; a.beginPath(); a.moveTo(n.startX, n.startY); p = n.segments.j; q = p.length; for (var r = null, u = 0; u < q; u++) {
                                var x = p[u]; switch (x.type) {
                                    case Ne: a.moveTo(x.endX, x.endY); break; case ve: a.lineTo(x.endX, x.endY); break;
                                    case Oe: a.bezierCurveTo(x.point1X, x.point1Y, x.point2X, x.point2Y, x.endX, x.endY); break; case Pe: a.quadraticCurveTo(x.point1X, x.point1Y, x.endX, x.endY); break; case Qe: if (x.radiusX === x.radiusY) { var y = Math.PI / 180; a.arc(x.point1X, x.point1Y, x.radiusX, x.startAngle * y, (x.startAngle + x.sweepAngle) * y, 0 > x.sweepAngle, null !== r ? r.endX : n.startX, null !== r ? r.endY : n.startY) } else if (r = Se(x, n), y = r.length, 0 === y) a.lineTo(x.centerX, x.centerY); else for (var A = 0; A < y; A++) {
                                        var C = r[A]; 0 === A && a.lineTo(C[0], C[1]); a.bezierCurveTo(C[2],
                                            C[3], C[4], C[5], C[6], C[7])
                                    } break; case Re: A = y = 0; if (null !== r && r.type === Qe) { r = Se(r, n); C = r.length; if (0 === C) { a.lineTo(x.centerX, x.centerY); break } r = r[C - 1] || null; null !== r && (y = r[6], A = r[7]) } else y = null !== r ? r.endX : n.startX, A = null !== r ? r.endY : n.startY; r = Te(x, n, y, A); y = r.length; if (0 === y) { a.lineTo(x.centerX, x.centerY); break } for (A = 0; A < y; A++)C = r[A], a.bezierCurveTo(C[2], C[3], C[4], C[5], C[6], C[7]); break; default: v("Segment not of valid type: " + x.type)
                                }x.isClosed && a.closePath(); r = x
                            } g ? (u = q = p = 0, n.isShadowed ? (!0 === n.isFilled &&
                                null !== d ? (a.Vd(d), h = !0) : h = !1, 0 !== f && null !== c && (h && (p = a.shadowOffsetX, q = a.shadowOffsetY, u = a.shadowBlur, a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0), a.$i(), h && (a.shadowOffsetX = p, a.shadowOffsetY = q, a.shadowBlur = u))) : (h && (p = a.shadowOffsetX, q = a.shadowOffsetY, u = a.shadowBlur, a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0), !0 === n.isFilled && null !== d && a.Vd(d), 0 !== f && null !== c && a.$i(), h && (a.shadowOffsetX = p, a.shadowOffsetY = q, a.shadowBlur = u))) : (!0 === n.isFilled && null !== d && a.Vd(d), 0 !== f && null !== c && a.$i())
                        } e &&
                            a.Ss(); if (null !== this.pathPattern) {
                                e = this.pathPattern; e.measure(Infinity, Infinity); f = e.measuredBounds; e.arrange(0, 0, f.width, f.height); g = this.geometry; a.save(); a.beginPath(); f = Qa(); if (g.type === pe) f.push(g.startX), f.push(g.startY), f.push(g.endX), f.push(g.endY), Bn(a, b, f, e); else if (g.type === ne) for (g = g.figures.iterator; g.next();) {
                                    c = g.value; f.length = 0; f.push(c.startX); f.push(c.startY); d = c.startX; h = c.startY; k = d; l = h; m = c.segments.j; n = m.length; for (p = 0; p < n; p++) {
                                        q = m[p]; switch (q.type) {
                                            case Ne: Bn(a, b, f, e); f.length =
                                                0; f.push(q.endX); f.push(q.endY); d = q.endX; h = q.endY; k = d; l = h; break; case ve: f.push(q.endX); f.push(q.endY); d = q.endX; h = q.endY; break; case Oe: K.Ce(d, h, q.point1X, q.point1Y, q.point2X, q.point2Y, q.endX, q.endY, .5, f); d = q.endX; h = q.endY; break; case Pe: K.tq(d, h, q.point1X, q.point1Y, q.endX, q.endY, .5, f); d = q.endX; h = q.endY; break; case Qe: u = Se(q, c); x = u.length; if (0 === x) { f.push(q.centerX); f.push(q.centerY); d = q.centerX; h = q.centerY; break } for (r = 0; r < x; r++)y = u[r], K.Ce(d, h, y[2], y[3], y[4], y[5], y[6], y[7], .5, f), d = y[6], h = y[7]; break;
                                            case Re: u = Te(q, c, d, h); x = u.length; if (0 === x) { f.push(q.centerX); f.push(q.centerY); d = q.centerX; h = q.centerY; break } for (r = 0; r < x; r++)y = u[r], K.Ce(d, h, y[2], y[3], y[4], y[5], y[6], y[7], .5, f), d = y[6], h = y[7]; break; default: v("Segment not of valid type: " + q.type)
                                        }q.isClosed && (f.push(k), f.push(l), Bn(a, b, f, e))
                                    } Bn(a, b, f, e)
                                } else if (g.type === xe) f.push(g.startX), f.push(g.startY), f.push(g.endX), f.push(g.startY), f.push(g.endX), f.push(g.endY), f.push(g.startX), f.push(g.endY), f.push(g.startX), f.push(g.startY), Bn(a, b, f, e); else if (g.type ===
                                    ye) { h = new Xe; h.startX = g.endX; h.startY = (g.startY + g.endY) / 2; d = new Ye(Qe); d.startAngle = 0; d.sweepAngle = 360; d.centerX = (g.startX + g.endX) / 2; d.centerY = (g.startY + g.endY) / 2; d.radiusX = Math.abs(g.startX - g.endX) / 2; d.radiusY = Math.abs(g.startY - g.endY) / 2; h.add(d); g = Se(d, h); c = g.length; if (0 === c) f.push(d.centerX), f.push(d.centerY); else for (d = h.startX, h = h.startY, k = 0; k < c; k++)l = g[k], K.Ce(d, h, l[2], l[3], l[4], l[5], l[6], l[7], .5, f), d = l[6], h = l[7]; Bn(a, b, f, e) } Ta(f); a.restore(); a.Uc(!1)
                            }
                }
        }
    };
    t.oa = function (a, b) { void 0 === b && (b = new J); if (a instanceof M) { a.Nb() && v("getDocumentPoint Spot must be a real, specific Spot, not: " + a.toString()); var c = this.naturalBounds, d = this.strokeWidth; b.h(a.x * (c.width + d) - d / 2 + c.x + a.offsetX, a.y * (c.height + d) - d / 2 + c.y + a.offsetY) } else b.set(a); this.td.va(b); return b };
    t.eq = function (a) { void 0 === a && (a = new L); var b = this.naturalBounds, c = this.td; b = L.allocAt(b.x, b.y, b.width, b.height); var d = this.strokeWidth; b.Xc(d / 2, d / 2); d = J.allocAt(b.x, b.y).transform(c); a.h(d.x, d.y, 0, 0); d.h(b.right, b.y).transform(c); Mc(a, d.x, d.y, 0, 0); d.h(b.right, b.bottom).transform(c); Mc(a, d.x, d.y, 0, 0); d.h(b.x, b.bottom).transform(c); Mc(a, d.x, d.y, 0, 0); L.free(b); J.free(d); return a };
    t.wh = function (a, b) {
        var c = this.geometry; if (null === c || null === this.fill && null === this.stroke) return !1; var d = c.bounds, e = this.strokeWidth / 2; c.type !== pe || b || (e += 2); var f = L.alloc(); f.assign(d); f.Xc(e + 2, e + 2); if (!f.ea(a)) return L.free(f), !1; d = e + 1E-4; if (c.type === pe) { if (null === this.stroke) return !1; d = (c.endX - c.startX) * (a.x - c.startX) + (c.endY - c.startY) * (a.y - c.startY); if (0 > (c.startX - c.endX) * (a.x - c.endX) + (c.startY - c.endY) * (a.y - c.endY) || 0 > d) return !1; L.free(f); return K.Vb(c.startX, c.startY, c.endX, c.endY, e, a.x, a.y) } if (c.type ===
            xe) { b = c.startX; var g = c.startY, h = c.endX; c = c.endY; f.x = Math.min(b, h); f.y = Math.min(g, c); f.width = Math.abs(h - b); f.height = Math.abs(c - g); if (null === this.fill) { f.Xc(-d, -d); if (f.ea(a)) return L.free(f), !1; f.Xc(d, d) } null !== this.stroke && f.Xc(e, e); a = f.ea(a); L.free(f); return a } if (c.type === ye) {
                g = c.startX; e = c.startY; h = c.endX; var k = c.endY; c = Math.min(g, h); b = Math.min(e, k); g = Math.abs(h - g) / 2; e = Math.abs(k - e) / 2; c = a.x - (c + g); b = a.y - (b + e); if (null === this.fill) {
                    g -= d; e -= d; if (0 >= g || 0 >= e || 1 >= c * c / (g * g) + b * b / (e * e)) return L.free(f), !1;
                    g += d; e += d
                } null !== this.stroke && (g += d, e += d); L.free(f); return 0 >= g || 0 >= e ? !1 : 1 >= c * c / (g * g) + b * b / (e * e)
            } if (c.type === ne) return L.free(f), null === this.fill ? Ve(c, a.x, a.y, e) : c.ea(a, e, 1 < this.strokeWidth, b); v("Unknown Geometry type: " + c.type); return !1
    };
    t.lm = function (a, b, c, d) {
        var e = this.desiredSize, f = this.ih; a = Math.max(a, 0); b = Math.max(b, 0); if (null !== this.Rd) var g = this.geometry.bounds; else { var h = this.figure, k = Gn[h]; if (void 0 === k) { var l = K.be[h]; "string" === typeof l && (l = K.be[l]); "function" === typeof l ? (k = l(null, 100, 100), Gn[h] = k) : v("Unsupported Figure: " + h) } g = k.bounds } h = g.width; k = g.height; l = g.width; var m = g.height; switch (ql(this, !0)) {
            case nh: d = c = 0; break; case oe: l = Math.max(a - f, 0); m = Math.max(b - f, 0); break; case bl: l = Math.max(a - f, 0); d = 0; break; case cl: c = 0, m =
                Math.max(b - f, 0)
        }isFinite(e.width) && (l = e.width); isFinite(e.height) && (m = e.height); e = this.maxSize; g = this.minSize; c = Math.max(c - f, g.width); d = Math.max(d - f, g.height); l = Math.min(e.width, l); m = Math.min(e.height, m); l = isFinite(l) ? Math.max(c, l) : Math.max(h, c); m = isFinite(m) ? Math.max(d, m) : Math.max(k, d); c = oh(this); switch (c) { case nh: break; case oe: h = l; k = m; break; case ph: c = Math.min(l / h, m / k); isFinite(c) || (c = 1); h *= c; k *= c; break; default: v(c + " is not a valid geometryStretch.") }null !== this.Rd ? (h = Math.max(h, .01), k = Math.max(k,
            .01), g = null !== this.Rd ? this.Rd : this.sa, e = h, d = k, c = g.copy(), g = g.bounds, e /= g.width, d /= g.height, isFinite(e) || (e = 1), isFinite(d) || (d = 1), 1 === e && 1 === d || c.scale(e, d), E && c.freeze(), this.sa = c) : null !== this.sa && K.da(this.sa.il, a - f) && K.da(this.sa.gl, b - f) || (this.sa = Hg.makeGeometry(this, h, k)); g = this.sa.bounds; Infinity === a || Infinity === b ? nl(this, g.x - f / 2, g.y - f / 2, 0 === a && 0 === h ? 0 : g.width + f, 0 === b && 0 === k ? 0 : g.height + f) : nl(this, -(f / 2), -(f / 2), l + f, m + f)
    };
    function oh(a) { var b = a.geometryStretch; return null !== a.Rd ? b === al ? oe : b : b === al ? Gn[a.figure].defaultStretch : b } t.uh = function (a, b, c, d) { sl(this, a, b, c, d) }; t.Wc = function (a, b, c) { return this.fk(a.x, a.y, b.x, b.y, c) };
    t.fk = function (a, b, c, d, e) {
        var f = this.transform, g = 1 / (f.m11 * f.m22 - f.m12 * f.m21), h = f.m22 * g, k = -f.m12 * g, l = -f.m21 * g, m = f.m11 * g, n = g * (f.m21 * f.dy - f.m22 * f.dx), p = g * (f.m12 * f.dx - f.m11 * f.dy); f = a * h + b * l + n; g = a * k + b * m + p; h = c * h + d * l + n; k = c * k + d * m + p; n = this.ih / 2; l = this.sa; null === l && (this.measure(Infinity, Infinity), l = this.sa); p = l.bounds; m = !1; if (l.type === pe) if (1.5 >= this.strokeWidth) m = K.Ie(l.startX, l.startY, l.endX, l.endY, f, g, h, k, e); else {
        l.startX === l.endX ? (d = n, m = 0) : (b = (l.endY - l.startY) / (l.endX - l.startX), m = n / Math.sqrt(1 + b * b), d = m *
            b); b = Qa(); a = new J; K.Ie(l.startX + d, l.startY + m, l.endX + d, l.endY + m, f, g, h, k, a) && b.push(a); a = new J; K.Ie(l.startX - d, l.startY - m, l.endX - d, l.endY - m, f, g, h, k, a) && b.push(a); a = new J; K.Ie(l.startX + d, l.startY + m, l.startX - d, l.startY - m, f, g, h, k, a) && b.push(a); a = new J; K.Ie(l.endX + d, l.endY + m, l.endX - d, l.endY - m, f, g, h, k, a) && b.push(a); h = b.length; if (0 === h) return Ta(b), !1; m = !0; k = Infinity; for (d = 0; d < h; d++)a = b[d], c = (a.x - f) * (a.x - f) + (a.y - g) * (a.y - g), c < k && (k = c, e.x = a.x, e.y = a.y); Ta(b)
        } else if (l.type === xe) m = K.Wc(p.x - n, p.y - n, p.x + p.width +
            n, p.y + p.height + n, f, g, h, k, e); else if (l.type === ye) {
                b = L.allocAt(p.x, p.y, p.width, p.height).Xc(n, n); a: if (0 === b.width) m = K.Ie(b.x, b.y, b.x, b.y + b.height, f, g, h, k, e); else if (0 === b.height) m = K.Ie(b.x, b.y, b.x + b.width, b.y, f, g, h, k, e); else {
                    a = b.width / 2; l = b.height / 2; d = b.x + a; m = b.y + l; c = 9999; f !== h && (c = (g - k) / (f - h)); if (9999 > Math.abs(c)) {
                        k = g - m - c * (f - d); if (0 > a * a * c * c + l * l - k * k) { e.x = NaN; e.y = NaN; m = !1; break a } n = Math.sqrt(a * a * c * c + l * l - k * k); h = (-(a * a * c * k) + a * l * n) / (l * l + a * a * c * c) + d; a = (-(a * a * c * k) - a * l * n) / (l * l + a * a * c * c) + d; l = c * (h - d) + k + m; k = c *
                            (a - d) + k + m; Math.abs((f - h) * (f - h)) + Math.abs((g - l) * (g - l)) < Math.abs((f - a) * (f - a)) + Math.abs((g - k) * (g - k)) ? (e.x = h, e.y = l) : (e.x = a, e.y = k)
                    } else { h = l * l; k = f - d; h -= h / (a * a) * k * k; if (0 > h) { e.x = NaN; e.y = NaN; m = !1; break a } k = Math.sqrt(h); h = m + k; k = m - k; Math.abs(h - g) < Math.abs(k - g) ? (e.x = f, e.y = h) : (e.x = f, e.y = k) } m = !0
                } L.free(b)
            } else if (l.type === ne) {
                p = J.alloc(); var q = h - f; var r = k - g; var u = q * q + r * r; e.x = h; e.y = k; for (var x = 0; x < l.figures.count; x++) {
                    var y = l.figures.j[x], A = y.segments; q = y.startX; r = y.startY; for (var C = q, G = r, H = 0; H < A.count; H++) {
                        var O =
                            A.j[H], S = O.type; var T = O.endX; var ea = O.endY; var Z = !1; switch (S) {
                                case Ne: C = T; G = ea; break; case ve: Z = Hn(q, r, T, ea, f, g, h, k, p); break; case Oe: Z = K.Tp(q, r, O.point1X, O.point1Y, O.point2X, O.point2Y, T, ea, f, g, h, k, .6, p); break; case Pe: Z = K.Tp(q, r, (q + 2 * O.point1X) / 3, (r + 2 * O.point1Y) / 3, (2 * O.point1X + T) / 3, (2 * O.point1X + T) / 3, T, ea, f, g, h, k, .6, p); break; case Qe: case Re: S = O.type === Qe ? Se(O, y) : Te(O, y, q, r); var va = S.length; if (0 === va) { Z = Hn(q, r, O.centerX, O.centerY, f, g, h, k, p); break } ea = null; for (T = 0; T < va; T++) {
                                    ea = S[T]; if (0 === T && Hn(q, r, ea[0],
                                        ea[1], f, g, h, k, p)) { var za = In(f, g, p, u, e); za < u && (u = za, m = !0) } K.Tp(ea[0], ea[1], ea[2], ea[3], ea[4], ea[5], ea[6], ea[7], f, g, h, k, .6, p) && (za = In(f, g, p, u, e), za < u && (u = za, m = !0))
                                } T = ea[6]; ea = ea[7]; break; default: v("Unknown Segment type: " + S)
                            }q = T; r = ea; Z && (Z = In(f, g, p, u, e), Z < u && (u = Z, m = !0)); O.isClosed && (T = C, ea = G, Hn(q, r, T, ea, f, g, h, k, p) && (O = In(f, g, p, u, e), O < u && (u = O, m = !0)))
                    }
                } f = c - a; g = d - b; h = Math.sqrt(f * f + g * g); 0 !== h && (f /= h, g /= h); e.x -= f * n; e.y -= g * n; J.free(p)
            } else v("Unknown Geometry type: " + l.type); if (!m) return !1; this.transform.va(e);
        return !0
    }; function In(a, b, c, d, e) { a = c.x - a; b = c.y - b; b = a * a + b * b; return b < d ? (e.x = c.x, e.y = c.y, b) : d } function Hn(a, b, c, d, e, f, g, h, k) { var l = !1, m = (e - g) * (b - d) - (f - h) * (a - c); if (0 === m) return !1; k.x = ((e * h - f * g) * (a - c) - (e - g) * (a * d - b * c)) / m; k.y = ((e * h - f * g) * (b - d) - (f - h) * (a * d - b * c)) / m; (a > c ? a - c : c - a) < (b > d ? b - d : d - b) ? (a = b < d ? b : d, b = b < d ? d : b, (k.y > a || K.da(k.y, a)) && (k.y < b || K.da(k.y, b)) && (l = !0)) : (b = a < c ? a : c, a = a < c ? c : a, (k.x > b || K.da(k.x, b)) && (k.x < a || K.da(k.x, a)) && (l = !0)); return l }
    t.vh = function (a, b) { if (void 0 === b) return a.pf(this.actualBounds); var c = this.sa; null === c && (this.measure(Infinity, Infinity), c = this.sa); c = c.bounds; var d = this.strokeWidth / 2, e = !1, f = J.alloc(); f.h(c.x - d, c.y - d); a.ea(b.va(f)) && (f.h(c.x - d, c.bottom + d), a.ea(b.va(f)) && (f.h(c.right + d, c.bottom + d), a.ea(b.va(f)) && (f.h(c.right + d, c.y - d), a.ea(b.va(f)) && (e = !0)))); J.free(f); return e };
    t.Kc = function (a, b) {
        if (this.vh(a, b) || void 0 === b && (b = this.transform, a.pf(this.actualBounds))) return !0; var c = $b.alloc(); c.set(b); c.gt(); var d = a.left, e = a.right, f = a.top; a = a.bottom; var g = J.alloc(); g.h(d, f); c.va(g); if (this.wh(g, !0)) return J.free(g), !0; g.h(e, f); c.va(g); if (this.wh(g, !0)) return J.free(g), !0; g.h(d, a); c.va(g); if (this.wh(g, !0)) return J.free(g), !0; g.h(e, a); c.va(g); if (this.wh(g, !0)) return J.free(g), !0; var h = J.alloc(), k = J.alloc(); c.set(b); c.uv(this.transform); c.gt(); h.x = e; h.y = f; h.transform(c); g.x =
            d; g.y = f; g.transform(c); b = !1; Jn(this, g, h, k) ? b = !0 : (g.x = e, g.y = a, g.transform(c), Jn(this, g, h, k) ? b = !0 : (h.x = d, h.y = a, h.transform(c), Jn(this, g, h, k) ? b = !0 : (g.x = d, g.y = f, g.transform(c), Jn(this, g, h, k) && (b = !0)))); J.free(g); $b.free(c); J.free(h); J.free(k); return b
    }; function Jn(a, b, c, d) { if (!a.Wc(b, c, d)) return !1; a = b.x; b = b.y; var e = c.x, f = c.y; c = d.x; d = d.y; if (a === e) return b < f ? (a = b, b = f) : a = f, d >= a && d <= b; a < e ? (d = a, a = e) : d = e; return c >= d && c <= a }
    t.nx = function (a, b, c) {
        function d(a, b) { for (var c = a.length, d = 0; d < c; d += 2)if (b.ed(a[d], a[d + 1]) > e) return !0; return !1 } if (c && null !== this.fill && this.wh(a, !0)) return !0; var e = a.Ee(b), f = e; 1.5 < this.strokeWidth && (e = this.strokeWidth / 2 + Math.sqrt(e), e *= e); b = this.sa; if (null === b && (this.measure(Infinity, Infinity), b = this.sa, null === b)) return !1; if (!c) { var g = b.bounds, h = g.x, k = g.y, l = g.x + g.width; g = g.y + g.height; if (dc(a.x, a.y, h, k) <= e && dc(a.x, a.y, l, k) <= e && dc(a.x, a.y, h, g) <= e && dc(a.x, a.y, l, g) <= e) return !0 } h = b.startX; k = b.startY; l =
            b.endX; g = b.endY; if (b.type === pe) { if (c = cc(a.x, a.y, h, k, l, g), b = (h - l) * (a.x - l) + (k - g) * (a.y - g), c <= (0 <= (l - h) * (a.x - h) + (g - k) * (a.y - k) && 0 <= b ? e : f)) return !0 } else {
                if (b.type === xe) return b = !1, c && (b = cc(a.x, a.y, h, k, h, g) <= e || cc(a.x, a.y, h, k, l, k) <= e || cc(a.x, a.y, l, k, l, g) <= e || cc(a.x, a.y, h, g, l, g) <= e), b; if (b.type === ye) {
                    b = a.x - (h + l) / 2; f = a.y - (k + g) / 2; var m = Math.abs(l - h) / 2, n = Math.abs(g - k) / 2; if (0 === m || 0 === n) return cc(a.x, a.y, h, k, l, g) <= e ? !0 : !1; if (c) { if (a = K.Iy(m, n, b, f), a * a <= e) return !0 } else return dc(b, f, -m, 0) >= e || dc(b, f, 0, -n) >= e ||
                        dc(b, f, 0, n) >= e || dc(b, f, m, 0) >= e ? !1 : !0
                } else if (b.type === ne) {
                    l = b.bounds; f = l.x; h = l.y; k = l.x + l.width; l = l.y + l.height; if (a.x > k && a.x < f && a.y > l && a.y < h && cc(a.x, a.y, f, h, f, l) > e && cc(a.x, a.y, f, h, k, h) > e && cc(a.x, a.y, k, l, f, l) > e && cc(a.x, a.y, k, l, k, h) > e) return !1; f = Math.sqrt(e); if (c) { if (null === this.fill ? Ve(b, a.x, a.y, f) : b.ea(a, f, !0)) return !0 } else {
                        c = b.figures; for (b = 0; b < c.count; b++) {
                            f = c.j[b]; g = f.startX; m = f.startY; if (a.ed(g, m) > e) return !1; h = f.segments.j; k = h.length; for (l = 0; l < k; l++)switch (n = h[l], n.type) {
                                case Ne: case ve: g = n.endX;
                                    m = n.endY; if (a.ed(g, m) > e) return !1; break; case Oe: var p = Qa(); K.Ce(g, m, n.point1X, n.point1Y, n.point2X, n.point2Y, n.endX, n.endY, .8, p); g = d(p, a); Ta(p); if (g) return !1; g = n.endX; m = n.endY; if (a.ed(g, m) > e) return !1; break; case Pe: p = Qa(); K.tq(g, m, n.point1X, n.point1Y, n.endX, n.endY, .8, p); g = d(p, a); Ta(p); if (g) return !1; g = n.endX; m = n.endY; if (a.ed(g, m) > e) return !1; break; case Qe: case Re: p = n.type === Qe ? Se(n, f) : Te(n, f, g, m); var q = p.length; if (0 === q) { g = n.centerX; m = n.centerY; if (a.ed(g, m) > e) return !1; break } n = null; for (var r = Qa(), u = 0; u <
                                        q; u++)if (n = p[u], r.length = 0, K.Ce(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], .8, r), d(r, a)) return Ta(r), !1; Ta(r); null !== n && (g = n[6], m = n[7]); break; default: v("Unknown Segment type: " + n.type)
                            }
                        } return !0
                    }
                }
            } return !1
    }; t.cc = function () { this.sa = null }; function Kn(a) { var b = a.diagram; null !== b && b.undoManager.isUndoingRedoing || (a.segmentOrientation = Ln, "None" !== a.Tl ? (a.segmentIndex = -1, a.alignmentFocus = Xd) : "None" !== a.bl && (a.segmentIndex = 0, a.alignmentFocus = new M(1 - Xd.x, Xd.y))) }
    Hg.makeGeometry = function (a, b, c) {
        if ("None" !== a.toArrow) var d = Mn[a.toArrow]; else "None" !== a.fromArrow ? d = Mn[a.fromArrow] : (d = K.be[a.figure], "string" === typeof d && (d = K.be[d]), void 0 === d && v("Unknown Shape.figure: " + a.figure), d = d(a, b, c), d.il = b, d.gl = c); if (null === d) { var e = K.be.Rectangle; "function" === typeof e && (d = e(a, b, c)) } E && (d.bounds.width > b + 1E-5 || d.bounds.height > c + 1E-5) && v("Geometry made with figure" + a.figure + "has bounds that are too large for its given size. See documentation for Shape.defineFigureGenerator.");
        return d
    }; function Nn(a) { var b = Mn[a]; if (void 0 === b) { var c = a.toLowerCase(); if ("none" === c) return "None"; b = Mn[c]; if (void 0 === b) { var d = null, e; for (e in K.Fm) if (e.toLowerCase() === c) { d = e; break } if (null !== d) return a = ze(K.Fm[d], !1), Mn[d] = a, c !== d && (Mn[c] = d), d } } return "string" === typeof b ? b : b instanceof me ? a : null }
    na.Object.defineProperties(Hg.prototype, {
        geometry: { configurable: !0, get: function () { return null !== this.sa ? this.sa : this.Rd }, set: function (a) { var b = this.sa; if (b !== a) { null !== a ? (E && w(a, me, Hg, "geometry"), this.Rd = this.sa = a.freeze()) : this.Rd = this.sa = null; var c = this.part; null !== c && (c.Xg = NaN); this.v(); this.g("geometry", b, a); kl(this) && (a = this.part, null !== a && ll(this, a, "geometryString")) } } }, geometryString: {
            configurable: !0, get: function () { return null === this.geometry ? "" : this.geometry.toString() },
            set: function (a) { a = ze(a); var b = a.normalize(); this.geometry = a; this.position = a = J.allocAt(-b.x, -b.y); J.free(a) }
        }, isGeometryPositioned: { configurable: !0, get: function () { return this.Vn }, set: function (a) { E && z(a, "boolean", Hg, "isGeometryPositioned"); var b = this.Vn; b !== a && (this.Vn = a, this.v(), this.g("isGeometryPositioned", b, a)) } }, fill: {
            configurable: !0, get: function () { return this.Zk }, set: function (a) {
                var b = this.Zk; b !== a && (null !== a && Wl(a, "Shape.fill"), a instanceof zl && a.freeze(), this.Zk =
                    a, this.S(), this.g("fill", b, a))
            }
        }, stroke: { configurable: !0, get: function () { return this.Ic }, set: function (a) { var b = this.Ic; b !== a && (null !== a && Wl(a, "Shape.stroke"), a instanceof zl && a.freeze(), this.Ic = a, this.S(), this.g("stroke", b, a)) } }, strokeWidth: { configurable: !0, get: function () { return this.ih }, set: function (a) { var b = this.ih; if (b !== a) if (E && B(a, Hg, "strokeWidth"), 0 <= a) { this.ih = a; this.v(); var c = this.part; null !== c && (c.Xg = NaN); this.g("strokeWidth", b, a) } else Ca(a, "value >= 0", Hg, "strokeWidth:value") } },
        strokeCap: { configurable: !0, get: function () { return this.Ml }, set: function (a) { var b = this.Ml; b !== a && ("string" !== typeof a || "butt" !== a && "round" !== a && "square" !== a ? Ca(a, '"butt", "round", or "square"', Hg, "strokeCap") : (this.Ml = a, this.S(), this.g("strokeCap", b, a))) } }, strokeJoin: {
            configurable: !0, get: function () { return this.Nl }, set: function (a) {
                var b = this.Nl; b !== a && ("string" !== typeof a || "miter" !== a && "bevel" !== a && "round" !== a ? Ca(a, '"miter", "bevel", or "round"', Hg, "strokeJoin") : (this.Nl =
                    a, this.S(), this.g("strokeJoin", b, a)))
            }
        }, strokeMiterLimit: { configurable: !0, get: function () { return this.Nj }, set: function (a) { var b = this.Nj; if (b !== a) if (E && B(a, Hg, "strokeMiterLimit"), 1 <= a) { this.Nj = a; this.S(); var c = this.part; null !== c && (c.Xg = NaN); this.g("strokeMiterLimit", b, a) } else E && Ca(a, "value >= 1", Hg, "strokeWidth:value") } }, strokeDashArray: {
            configurable: !0, get: function () { return this.gh }, set: function (a) {
                var b = this.gh; if (b !== a) {
                null === a || Array.isArray(a) || Ba(a, "Array", Hg, "strokeDashArray:value");
                    if (null !== a) { for (var c = a.length, d = 0, e = 0; e < c; e++) { var f = a[e]; (!E || "number" === typeof f) && 0 <= f && isFinite(f) || v("strokeDashArray:value " + f + " at index " + e + " must be a positive number or zero."); d += f } if (0 === d) { if (null === b) return; a = null } } this.gh = a; this.S(); this.g("strokeDashArray", b, a)
                }
            }
        }, strokeDashOffset: { configurable: !0, get: function () { return this.hh }, set: function (a) { var b = this.hh; b !== a && (E && B(a, Hg, "strokeDashOffset"), 0 <= a && (this.hh = a, this.S(), this.g("strokeDashOffset", b, a))) } }, figure: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Yk }, set: function (a) { var b = this.Yk; if (b !== a) { E && z(a, "string", Hg, "figure"); var c = K.be[a]; "function" === typeof c ? c = a : (c = K.be[a.toLowerCase()]) || v("Unknown Shape.figure: " + a); b !== c && (a = this.part, null !== a && (a.Xg = NaN), this.Yk = c, this.Rd = null, this.cc(), this.v(), this.g("figure", b, c)) } }
        }, toArrow: {
            configurable: !0, get: function () { return this.Tl }, set: function (a) {
                var b = this.Tl; !0 === a ? a = "Standard" : !1 === a && (a = ""); if (b !== a) {
                    E && z(a, "string", Hg, "toArrow"); var c = Nn(a);
                    null === c ? v("Unknown Shape.toArrow: " + a) : b !== c && (this.Tl = c, this.Rd = null, this.cc(), this.v(), Kn(this), this.g("toArrow", b, c))
                }
            }
        }, fromArrow: { configurable: !0, get: function () { return this.bl }, set: function (a) { var b = this.bl; !0 === a ? a = "Standard" : !1 === a && (a = ""); if (b !== a) { E && z(a, "string", Hg, "fromArrow"); var c = Nn(a); null === c ? v("Unknown Shape.fromArrow: " + a) : b !== c && (this.bl = c, this.Rd = null, this.cc(), this.v(), Kn(this), this.g("fromArrow", b, c)) } } }, spot1: {
            configurable: !0, get: function () { return this.ef },
            set: function (a) { w(a, M, Hg, "spot1"); var b = this.ef; b.A(a) || (this.ef = a = a.J(), this.v(), this.g("spot1", b, a)) }
        }, spot2: { configurable: !0, get: function () { return this.ff }, set: function (a) { w(a, M, Hg, "spot2"); var b = this.ff; b.A(a) || (this.ff = a = a.J(), this.v(), this.g("spot2", b, a)) } }, parameter1: { configurable: !0, get: function () { return this.Ro }, set: function (a) { var b = this.Ro; b !== a && (this.Ro = a, this.cc(), this.v(), this.g("parameter1", b, a)) } }, parameter2: {
            configurable: !0, get: function () { return this.So },
            set: function (a) { var b = this.So; b !== a && (this.So = a, this.cc(), this.v(), this.g("parameter2", b, a)) }
        }, naturalBounds: { configurable: !0, get: function () { if (null !== this.sa) return this.rc.assign(this.sa.bounds), this.rc; var a = this.desiredSize; return new L(0, 0, a.width, a.height) } }, pathPattern: { configurable: !0, get: function () { return this.Uo }, set: function (a) { var b = this.Uo; b !== a && (E && null !== a && w(a, N, Hg, "pathPattern"), this.Uo = a, this.S(), this.g("pathPattern", b, a)) } }, geometryStretch: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Kn }, set: function (a) { var b = this.Kn; b !== a && (tb(a, N, Hg, "geometryStretch"), this.Kn = a, this.g("geometryStretch", b, a)) }
        }, interval: { configurable: !0, get: function () { return this.Ed }, set: function (a) { var b = this.Ed; E && B(a, Hg, "interval"); a = Math.floor(a); if (b !== a && 0 <= a) { this.Ed = a; var c = this.diagram; null !== c && this.panel === c.grid && zj(c); this.v(); c = this.panel; null !== c && (c.Pg = null); this.g("interval", b, a) } } }, graduatedStart: {
            configurable: !0, get: function () { return this.Dd },
            set: function (a) { var b = this.Dd; E && B(a, Hg, "graduatedStart"); b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Dd = a, this.v(), this.g("graduatedStart", b, a)) }
        }, graduatedEnd: { configurable: !0, get: function () { return this.Bd }, set: function (a) { var b = this.Bd; E && B(a, Hg, "graduatedEnd"); b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Bd = a, this.v(), this.g("graduatedEnd", b, a)) } }, graduatedSkip: {
            configurable: !0, get: function () { return this.Cd }, set: function (a) {
                var b = this.Cd; b !== a && (null !== a && z(a, "function", Hg, "graduatedSkip"),
                    this.Cd = a, this.v(), this.g("graduatedSkip", b, a))
            }
        }
    }); Hg.prototype.intersectsRect = Hg.prototype.Kc; Hg.prototype.containedInRect = Hg.prototype.vh; Hg.prototype.getNearestIntersectionPoint = Hg.prototype.Wc; Hg.prototype.getDocumentBounds = Hg.prototype.eq; Hg.prototype.getDocumentPoint = Hg.prototype.oa; var Mn = new xb, Gn = new xb; Hg.className = "Shape"; Hg.getFigureGenerators = function () { var a = new Ub, b; for (b in K.be) b !== b.toLowerCase() && a.add(b, K.be[b]); a.freeze(); return a };
    Hg.defineFigureGenerator = function (a, b) { z(a, "string", Hg, "defineFigureGenerator:name"); "string" === typeof b ? !E || "" !== b && K.be[b] || v("Shape.defineFigureGenerator synonym must not be empty or None or not a defined figure name: " + b) : z(b, "function", Hg, "defineFigureGenerator:func"); var c = a.toLowerCase(); !E || "" !== a && a !== c || v("Shape.defineFigureGenerator name must not be empty or all-lower-case: " + a); var d = K.be; d[a] = b; d[c] = a };
    Hg.getArrowheadGeometries = function () { var a = new Ub; for (d in K.Fm) if (void 0 === Mn[d]) { var b = ze(K.Fm[d], !1); Mn[d] = b; b = d.toLowerCase(); b !== d && (Mn[b] = d) } for (var c in Mn) if (c !== c.toLowerCase()) { var d = Mn[c]; d instanceof me && a.add(c, d) } a.freeze(); return a };
    Hg.defineArrowheadGeometry = function (a, b) { z(a, "string", Hg, "defineArrowheadGeometry:name"); "string" === typeof b ? (z(b, "string", Hg, "defineArrowheadGeometry:pathstr"), b = ze(b, !1)) : w(b, me, Hg, "defineArrowheadGeometry:pathstr"); var c = a.toLowerCase(); (E && "" === a || "none" === c || a === c) && v("Shape.defineArrowheadGeometry name must not be empty or None or all-lower-case: " + a); var d = Mn; d[a] = b; d[c] = a };
    function Kh() { N.call(this); On || (Pn(), On = !0); this.Rb = ""; this.Ic = "black"; this.he = "13px sans-serif"; this.xi = "start"; this.Ad = nh; this.Ci = Td; this.rj = !0; this.ei = this.fi = !1; this.ag = Qn; this.mg = Rn; this.Wr = this.pc = 0; this.mu = this.nu = null; this.pd = new an; this.En = !1; this.Ec = this.an = this.Ep = this.yi = this.Fp = null; this.df = this.cf = 0; this.pe = Infinity; this.nl = 0; this.Ed = 1; this.Dd = 0; this.Bd = 1; this.Cd = this.mj = null } ma(Kh, N);
    Kh.prototype.cloneProtected = function (a) { N.prototype.cloneProtected.call(this, a); a.Rb = this.Rb; a.Ic = this.Ic; a.he = this.he; a.xi = this.xi; a.Ad = this.Ad; a.Ci = this.Ci; a.rj = this.rj; a.fi = this.fi; a.ei = this.ei; a.ag = this.ag; a.mg = this.mg; a.pc = this.pc; a.Wr = this.Wr; a.nu = this.nu; a.mu = this.mu; a.pd.Zl(this.pd); a.En = this.En; a.Fp = this.Fp; a.yi = this.yi; a.Ep = this.Ep; a.an = this.an; a.Ec = this.Ec; a.cf = this.cf; a.df = this.df; a.pe = this.pe; a.nl = this.nl; a.Ed = this.Ed; a.Dd = this.Dd; a.Bd = this.Bd; a.mj = this.mj; a.Cd = this.Cd };
    function $m(a, b) {
    a.I = b.I | 6144; a.mb = b.opacity; a.jb = b.background; a.fc = b.areaBackground; a.Qc = b.desiredSize.J(); a.Sf = b.minSize.J(); a.Rf = b.maxSize.J(); a.Qf = b.Qf.copy(); a.Da = b.scale; a.Bc = b.angle; a.ye = b.stretch; a.Wg = b.margin.J(); a.xb = b.alignment.J(); a.Bk = b.alignmentFocus.J(); a.Cl = b.segmentFraction; a.Dl = b.segmentOffset.J(); a.El = b.segmentOrientation; null !== b.md && (a.md = b.md.copy()); a.Gl = b.shadowVisible; b instanceof Kh && (a.Rb = b.Rb, a.Ic = b.Ic, a.he = b.he, a.xi = b.xi, a.Ad = b.Ad, a.Ci = b.Ci, a.rj = b.rj, a.fi = b.fi, a.ei = b.ei,
        a.ag = b.ag, a.mg = b.mg, a.pd.Kf = null, a.cf = b.cf, a.df = b.df, a.pe = b.pe, a.nl = b.nl, a.Ed = b.Ed, a.Dd = b.Dd, a.Bd = b.Bd, a.mj = b.mj, a.Cd = b.Cd)
    } t = Kh.prototype; t.hb = function (a) { a.classType === Kh ? this.wrap = a : N.prototype.hb.call(this, a) }; t.toString = function () { return 22 < this.Rb.length ? 'TextBlock("' + this.Rb.substring(0, 20) + '"...)' : 'TextBlock("' + this.Rb + '")' }; t.v = function () { N.prototype.v.call(this); this.mu = this.nu = null };
    function Sn(a) { On || (Pn(), On = !0); if (null === Tn) return !0; var b = Tn.font; if (a === b || "10px sans-serif" === a) return !0; Tn.font = "10px sans-serif"; Tn.font = a; var c = Tn.font; if ("10px sans-serif" !== c) return Tn.font = b, !0; Tn.font = "19px serif"; var d = Tn.font; Tn.font = a; c = Tn.font; Tn.font = b; return c !== d }
    t.Gi = function (a, b) {
        if (null !== this.Ic && 0 !== this.Rb.length && null !== this.he) {
            var c = this.naturalBounds, d = this.actualBounds, e = c.width, f = c.height, g = Un(this), h = a.textAlign = this.xi, k = b.Xn; "start" === h ? h = k ? "right" : "left" : "end" === h && (h = k ? "left" : "right"); k = this.fi; var l = this.ei; yi(this, a, this.Ic, !0, !1, c, d); (k || l) && yi(this, a, this.Ic, !1, !1, c, d); d = 0; c = !1; var m = J.allocAt(0, 0); this.td.va(m); var n = J.allocAt(0, g); this.td.va(n); var p = m.Ee(n); J.free(m); J.free(n); m = b.scale; 8 > p * m * m && (c = !0); b.$c !== a && (c = !1); !1 === b.Ge("textGreeking") &&
                (c = !1); b = this.cf; p = this.df; switch (this.flip) { case fl: a.translate(e, 0); a.scale(-1, 1); break; case el: a.translate(0, f); a.scale(1, -1); break; case gl: a.translate(e, f), a.scale(-1, -1) }m = this.pc; n = (b + g + p) * m; f > n && (d = this.Ci, d = d.y * f - d.y * n + d.offsetY); n = this.pd; for (var q = 0; q < m; q++) {
                    var r = n.Yc[q]; r > e && (r = e); d += b; var u = n.Cc[q], x = a, y = d, A = h, C = 0; if (c) "left" === A ? C = 0 : "right" === A ? C = e - r : "center" === A && (C = (e - r) / 2), x.fillRect(0 + C, y + .25 * g, r, 1); else {
                        "left" === A ? C = 0 : "right" === A ? C = e : "center" === A && (C = e / 2); var G = null !== Vn ? Vn(this,
                            g) : .75 * g; x.fillText(u, 0 + C, y + G); u = g / 20 | 0; 0 === u && (u = 1); "right" === A ? C -= r : "center" === A && (C -= r / 2); k && (A = null !== Wn ? Wn(this, g) : .8 * g, x.beginPath(), x.lineWidth = u, x.moveTo(0 + C, y + A), x.lineTo(0 + C + r, y + A), x.stroke()); l && (x.beginPath(), x.lineWidth = u, y = y + g - g / 2.2 | 0, 0 !== u % 2 && (y += .5), x.moveTo(0 + C, y), x.lineTo(0 + C + r, y), x.stroke())
                    } d += g + p
                } switch (this.flip) { case fl: a.scale(-1, 1); a.translate(-e, 0); break; case el: a.scale(1, -1); a.translate(0, -f); break; case gl: a.scale(-1, -1), a.translate(-e, -f) }
        }
    };
    t.lm = function (a, b, c, d) {
    this.nl = a; var e = this.he; null !== Tn && Xn !== e && (Xn = Tn.font = e); e = this.pd; e.reset(); var f; if (isNaN(this.desiredSize.width)) { var g = this.Rb.replace(/\r\n/g, "\n").replace(/\r/g, "\n"); if (0 === g.length) g = 0; else if (this.isMultiline) { for (var h = f = 0, k = !1; !k;) { var l = g.indexOf("\n", h); -1 === l && (l = g.length, k = !0); f = Math.max(f, Yn(g.substr(h, l - h).trim())); h = l + 1 } g = f } else f = g.indexOf("\n", 0), 0 <= f && (g = g.substr(0, f)), g = Yn(g); g = Math.min(g, a / this.scale); g = Math.max(8, g) } else g = this.desiredSize.width; null !==
        this.panel && (g = Math.min(g, this.panel.maxSize.width)); f = Zn(this, g, e); isNaN(this.desiredSize.height) ? f = Math.min(f, b / this.scale) : f = this.desiredSize.height; h = f; if (0 !== e.Gc && 1 !== e.Cc.length && this.ag === $n && (b = this.he, b = this.ag === $n ? ao(b) : 0, k = this.cf + this.df, k = Math.max(0, Un(this) + k), h = Math.min(this.maxLines - 1, Math.max(Math.floor(h / k + .01) - 1, 0)), !(h + 1 >= e.Cc.length))) {
            k = e.Cc[h]; for (b = Math.max(1, a - b); Yn(k) > b && 1 < k.length;)k = k.substr(0, k.length - 1); k += bo; b = Yn(k); e.Cc[h] = k; e.Cc = e.Cc.slice(0, h + 1); e.Yc[h] = b; e.Yc =
                e.Yc.slice(0, h + 1); e.lg = e.Cc.length; e.Gc = Math.max(e.Gc, b); this.pc = e.lg
        } if (this.wrap === co || isNaN(this.desiredSize.width)) g = isNaN(a) ? e.Gc : Math.min(a, e.Gc), isNaN(this.desiredSize.width) && (g = Math.max(8, g)); g = Math.max(c, g); f = Math.max(d, f); Cc(this.rc, g, f); nl(this, 0, 0, g, f)
    }; t.uh = function (a, b, c, d) { sl(this, a, b, c, d) };
    function eo(a, b, c, d, e) {
        b = b.trim(); var f = 0; var g = a.he; var h = a.cf + a.df; h = Math.max(0, Un(a) + h); var k = a.ag === $n ? ao(g) : 0; if (a.pc >= a.pe) null !== e && e.h(0, h); else {
            var l = b; if (a.mg === fo) if (c.lg = 1, g = Yn(b), 0 === k || g <= d) c.Gc = Math.max(c.Gc, g), c.Yc.push(c.Gc), c.Cc.push(b), null !== e && e.h(g, h); else {
                f = go(a, l); l = l.substr(f.length); b = go(a, l); for (g = Yn(f + b); 0 < b.length && g <= d;)f += b, l = l.substr(b.length), b = go(a, l), g = Yn((f + b).trim()); f += b.trim(); for (d = Math.max(1, d - k); Yn(f) > d && 1 < f.length;)f = f.substr(0, f.length - 1); f += bo; b = Yn(f);
                c.Yc.push(b); c.Gc = b; c.Cc.push(f); null !== e && e.h(b, h)
            } else {
                k = 0; 0 === l.length && (k = 1, c.Yc.push(0), c.Cc.push(l)); for (; 0 < l.length;) {
                    var m = go(a, l); for (l = l.substr(m.length); Yn(m) > d;) { var n = 1; g = Yn(m.substr(0, n)); for (b = 0; g <= d;)n++ , b = g, g = Yn(m.substr(0, n)); 1 === n ? (c.Yc[a.pc + k] = g, f = Math.max(f, g)) : (c.Yc[a.pc + k] = b, f = Math.max(f, b)); n--; 1 > n && (n = 1); c.Cc[a.pc + k] = m.substr(0, n); k++; m = m.substr(n); if (a.pc + k > a.pe) break } b = go(a, l); for (g = Yn(m + b); 0 < b.length && g <= d;)m += b, l = l.substr(b.length), b = go(a, l), g = Yn((m + b).trim()); m = m.trim();
                    if ("" !== m && ("\u00ad" === m[m.length - 1] && (m = m.substring(0, m.length - 1) + "\u2010"), 0 === b.length ? (c.Yc.push(g), f = Math.max(f, g)) : (b = Yn(m), c.Yc.push(b), f = Math.max(f, b)), c.Cc.push(m), k++ , a.pc + k > a.pe)) break
                } c.lg = Math.min(a.pe, k); c.Gc = Math.max(c.Gc, f); null !== e && e.h(c.Gc, h * c.lg)
            }
        }
    } function go(a, b) { if (a.mg === ho) return b.substr(0, 1); a = b.length; for (var c = 0, d = io; c < a && !d.test(b.charAt(c));)c++; for (; c < a && d.test(b.charAt(c));)c++; return c >= a ? b : b.substr(0, c) }
    function Yn(a) { return null === Tn ? 8 * a.length : Tn.measureText(a).width } function Un(a) { if (null !== a.pd.Kf) return a.pd.Kf; var b = a.he; if (null === Tn) { var c = 16; return a.pd.Kf = c } void 0 !== jo[b] && 5E3 > ko ? c = jo[b] : (c = 1.3 * Tn.measureText("M").width, jo[b] = c, ko++); return a.pd.Kf = c } function ao(a) { if (null === Tn) return 6; if (void 0 !== lo[a] && 5E3 > mo) var b = lo[a]; else b = Tn.measureText(bo).width, lo[a] = b, mo++; return b }
    function Zn(a, b, c) { var d = a.Rb.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), e = a.cf + a.df; e = Math.max(0, Un(a) + e); if (0 === d.length) return c.Gc = 0, a.pc = 1, e; if (!a.isMultiline) { var f = d.indexOf("\n", 0); 0 <= f && (d = d.substr(0, f)) } f = 0; for (var g = a.pc = 0, h, k = !1; !k;) { h = d.indexOf("\n", g); -1 === h && (h = d.length, k = !0); if (g <= h) { g = d.substr(g, h - g); if (a.mg !== fo) { c.lg = 0; var l = Zb.alloc(); eo(a, g, c, b, l); f += l.height; Zb.free(l); a.pc += c.lg } else eo(a, g, c, b, null), f += e, a.pc++; a.pc === a.pe && (k = !0) } g = h + 1 } return a.Wr = f }
    function Pn() { io = /[ \u200b\u00ad]/; jo = new xb; lo = new xb; Tn = Ih ? (new Jk(null)).context : null }
    na.Object.defineProperties(Kh.prototype, {
        font: { configurable: !0, get: function () { return this.he }, set: function (a) { var b = this.he; b !== a && (E && (z(a, "string", Kh, "font"), Sn(a) || v('Not a valid font: "' + a + '"')), this.he = a, this.pd.Kf = null, this.v(), this.g("font", b, a)) } }, text: { configurable: !0, get: function () { return this.Rb }, set: function (a) { var b = this.Rb; null !== a && void 0 !== a ? a = a.toString() : a = ""; b !== a && (this.Rb = a, this.v(), this.g("text", b, a)) } }, textAlign: {
            configurable: !0, get: function () { return this.xi },
            set: function (a) { var b = this.xi; b !== a && (E && z(a, "string", Kh, "textAlign"), "start" === a || "end" === a || "left" === a || "right" === a || "center" === a ? (this.xi = a, this.S(), this.g("textAlign", b, a)) : E && Ca(a, '"start", "end", "left", "right", or "center"', Kh, "textAlign")) }
        }, flip: { configurable: !0, get: function () { return this.Ad }, set: function (a) { var b = this.Ad; b !== a && (tb(a, N, Kh, "flip"), this.Ad = a, this.S(), this.g("flip", b, a)) } }, verticalAlignment: {
            configurable: !0, get: function () { return this.Ci }, set: function (a) {
                var b =
                    this.Ci; b.A(a) || (E && (w(a, M, Kh, "verticalAlignment"), a.Nb() && v("TextBlock.verticalAlignment for " + this + " must be a real Spot, not:" + a)), this.Ci = a = a.J(), Il(this), this.g("verticalAlignment", b, a))
            }
        }, naturalBounds: { configurable: !0, get: function () { if (!this.rc.o()) { var a = Zb.alloc(); eo(this, this.Rb, this.pd, 999999, a); var b = a.width; Zb.free(a); a = Zn(this, b, this.pd); var c = this.desiredSize; isNaN(c.width) || (b = c.width); isNaN(c.height) || (a = c.height); Cc(this.rc, b, a) } return this.rc } }, isMultiline: {
            configurable: !0,
            enumerable: !0, get: function () { return this.rj }, set: function (a) { var b = this.rj; b !== a && (E && z(a, "boolean", Kh, "isMultiline"), this.rj = a, this.v(), this.g("isMultiline", b, a)) }
        }, isUnderline: { configurable: !0, get: function () { return this.fi }, set: function (a) { var b = this.fi; b !== a && (E && z(a, "boolean", Kh, "isUnderline"), this.fi = a, this.S(), this.g("isUnderline", b, a)) } }, isStrikethrough: {
            configurable: !0, get: function () { return this.ei }, set: function (a) {
                var b = this.ei; b !== a && (E && z(a, "boolean", Kh, "isStrikethrough"),
                    this.ei = a, this.S(), this.g("isStrikethrough", b, a))
            }
        }, wrap: { configurable: !0, get: function () { return this.mg }, set: function (a) { var b = this.mg; b !== a && (E && tb(a, Kh, Kh, "wrap"), this.mg = a, this.v(), this.g("wrap", b, a)) } }, overflow: { configurable: !0, get: function () { return this.ag }, set: function (a) { var b = this.ag; b !== a && (E && tb(a, Kh, Kh, "overflow"), this.ag = a, this.v(), this.g("overflow", b, a)) } }, stroke: {
            configurable: !0, get: function () { return this.Ic }, set: function (a) {
                var b = this.Ic; b !==
                    a && (null !== a && Wl(a, "TextBlock.stroke"), a instanceof zl && a.freeze(), this.Ic = a, this.S(), this.g("stroke", b, a))
            }
        }, lineCount: { configurable: !0, get: function () { return this.pc } }, editable: { configurable: !0, get: function () { return this.En }, set: function (a) { var b = this.En; b !== a && (E && z(a, "boolean", Kh, "editable"), this.En = a, this.g("editable", b, a)) } }, textEditor: {
            configurable: !0, get: function () { return this.Fp }, set: function (a) {
                var b = this.Fp; b !== a && (!E || a instanceof Hf || v("TextBlock.textEditor must be an HTMLInfo."),
                    this.Fp = a, this.g("textEditor", b, a))
            }
        }, errorFunction: { configurable: !0, get: function () { return this.Ec }, set: function (a) { var b = this.Ec; b !== a && (null !== a && z(a, "function", Kh, "errorFunction"), this.Ec = a, this.g("errorFunction", b, a)) } }, interval: { configurable: !0, get: function () { return this.Ed }, set: function (a) { var b = this.Ed; E && B(a, Kh, "interval"); a = Math.floor(a); if (b !== a && 0 <= a) { this.Ed = a; this.v(); var c = this.panel; null !== c && (c.Pg = null); this.g("interval", b, a) } } }, graduatedStart: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Dd }, set: function (a) { var b = this.Dd; E && B(a, Kh, "graduatedStart"); b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Dd = a, this.v(), this.g("graduatedStart", b, a)) }
        }, graduatedEnd: { configurable: !0, get: function () { return this.Bd }, set: function (a) { var b = this.Bd; E && B(a, Kh, "graduatedEnd"); b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Bd = a, this.v(), this.g("graduatedEnd", b, a)) } }, graduatedFunction: {
            configurable: !0, get: function () { return this.mj }, set: function (a) {
                var b = this.mj; b !==
                    a && (null !== a && z(a, "function", Kh, "graduatedFunction"), this.mj = a, this.v(), this.g("graduatedFunction", b, a))
            }
        }, graduatedSkip: { configurable: !0, get: function () { return this.Cd }, set: function (a) { var b = this.Cd; b !== a && (null !== a && z(a, "function", Kh, "graduatedSkip"), this.Cd = a, this.v(), this.g("graduatedSkip", b, a)) } }, textValidation: {
            configurable: !0, get: function () { return this.yi }, set: function (a) {
                var b = this.yi; b !== a && (null !== a && z(a, "function", Kh, "textValidation"), this.yi = a, this.g("textValidation",
                    b, a))
            }
        }, textEdited: { configurable: !0, get: function () { return this.Ep }, set: function (a) { var b = this.Ep; b !== a && (null !== a && z(a, "function", Kh, "textEdited"), this.Ep = a, this.g("textEdited", b, a)) } }, spacingAbove: { configurable: !0, get: function () { return this.cf }, set: function (a) { var b = this.cf; b !== a && (E && z(a, "number", Kh, "spacingAbove"), this.cf = a, this.g("spacingAbove", b, a)) } }, spacingBelow: {
            configurable: !0, get: function () { return this.df }, set: function (a) {
                var b = this.df; b !== a && (E &&
                    z(a, "number", Kh, "spacingBelow"), this.df = a, this.g("spacingBelow", b, a))
            }
        }, maxLines: { configurable: !0, get: function () { return this.pe }, set: function (a) { var b = this.pe; b !== a && (E && z(a, "number", Kh, "maxLines"), a = Math.floor(a), 0 >= a && Ca(a, "> 0", Kh, "maxLines"), this.pe = a, this.g("maxLines", b, a), this.v()) } }, metrics: { configurable: !0, get: function () { return this.pd } }, choices: {
            configurable: !0, get: function () { return this.an }, set: function (a) {
                var b = this.an; b !== a && (E && null !== a && !Array.isArray(a) &&
                    Ba(a, "Array", Kh, "choices:value"), this.an = a, this.g("choices", b, a))
            }
        }
    }); var Vn = null, Wn = null, fo = new D(Kh, "None", 0), co = new D(Kh, "WrapFit", 1), Rn = new D(Kh, "WrapDesiredSize", 2), ho = new D(Kh, "WrapBreakAll", 3), Qn = new D(Kh, "OverflowClip", 0), $n = new D(Kh, "OverflowEllipsis", 1), io = null, jo = null, ko = 0, lo = null, mo = 0, bo = "...", Xn = "", Tn = null, On = !1; Kh.className = "TextBlock"; Kh.getEllipsis = function () { return bo }; Kh.setEllipsis = function (a) { bo = a; lo = new xb; mo = 0 }; Kh.getBaseline = function () { return Vn };
    Kh.setBaseline = function (a) { Vn = a; a = ab(); for (var b = a.length, c = 0; c < b; c++)a[c].vf() }; Kh.getUnderline = function () { return Wn }; Kh.setUnderline = function (a) { Wn = a; a = ab(); for (var b = a.length, c = 0; c < b; c++)a[c].vf() }; Kh.isValidFont = Sn; Kh.None = fo; Kh.WrapFit = co; Kh.WrapDesiredSize = Rn; Kh.WrapBreakAll = ho; Kh.OverflowClip = Qn; Kh.OverflowEllipsis = $n; function an() { this.Gc = this.lg = 0; this.Yc = []; this.Cc = []; this.Kf = null } an.prototype.reset = function () { this.Gc = this.lg = 0; this.Kf = null; this.Yc = []; this.Cc = [] };
    an.prototype.Zl = function (a) { this.lg = a.lg; this.Kf = a.Kf; this.Gc = a.Gc; this.Yc = Ma(a.Yc); this.Cc = Ma(a.Cc) }; na.Object.defineProperties(an.prototype, { arrSize: { configurable: !0, get: function () { return this.Yc } }, arrText: { configurable: !0, get: function () { return this.Cc } }, maxLineWidth: { configurable: !0, get: function () { return this.Gc } }, fontHeight: { configurable: !0, get: function () { return this.Kf } } }); an.className = "TextBlockMetrics";
    function lk() { N.call(this); this.Lg = null; this.yp = ""; this.fh = Uc; this.el = oe; this.gf = this.Ec = null; this.dl = qd; this.Ad = nh; this.Pl = null; this.gu = !1; this.$k = !0; this.rl = !1; this.Hl = null } ma(lk, N); lk.prototype.cloneProtected = function (a) { N.prototype.cloneProtected.call(this, a); a.element = this.Lg; a.yp = this.yp; a.fh = this.fh.J(); a.el = this.el; a.Ad = this.Ad; a.Ec = this.Ec; a.gf = this.gf; a.dl = this.dl.J(); a.$k = this.$k; a.Hl = this.Hl }; t = lk.prototype;
    t.hb = function (a) { a === nh || a === ph || a === dl ? this.imageStretch = a : N.prototype.hb.call(this, a) }; t.toString = function () { return "Picture(" + this.source + ")#" + Jb(this) }; function tk(a) { void 0 === a && (a = ""); z(a, "string", lk, "clearCache:url"); "" !== a ? no[a] && (delete no[a], oo--) : (no = new xb, oo = 0) } function po(a, b) { a.Jr = !0; a.cl = !1; for (var c, d = ab(), e = d.length, f = 0; f < e; f++) { var g = d[f], h = g.Gj.K(a.src); if (null !== h) for (var k = h.length, l = 0; l < k; l++)c = h[l], g.ru.add(c), g.ec(), void 0 === a.xu && (a.xu = b, null !== c.gf && c.gf(c, b)) } }
    function qo(a, b) { a.cl = b; for (var c, d = ab(), e = d.length, f = 0; f < e; f++)if (c = d[f].Gj.K(a.src), null !== c) { for (var g = c.length, h = Qa(), k = 0; k < g; k++)h.push(c[k]); for (k = 0; k < g; k++)c = h[k], null !== c.Ec && c.Ec(c, b); Ta(h) } } t.Uz = function () { if ("" !== this.source) { tk(this.source); var a = this.source; this.source = ""; this.source = a } }; t.vf = function () { this.S() };
    t.Gi = function (a, b) {
        var c = this.Lg; if (null !== c) {
            var d = c.src; null !== d && "" !== d || v('Element has no source ("src") attribute: ' + c); if (!(c.cl instanceof Event)) {
                d = this.naturalBounds; var e = 0, f = 0, g = this.gu, h = g ? +c.width : c.naturalWidth; g = g ? +c.height : c.naturalHeight; void 0 === h && c.videoWidth && (h = c.videoWidth); void 0 === g && c.videoHeight && (g = c.videoHeight); h = h || d.width; g = g || d.height; if (0 !== h && 0 !== g) {
                    var k = h, l = g; this.sourceRect.o() && (e = this.fh.x, f = this.fh.y, h = this.fh.width, g = this.fh.height); var m = h, n = g, p = this.el,
                        q = this.dl; switch (p) {
                            case nh: if (this.sourceRect.o()) break; m >= d.width && (e = e + q.offsetX + (m * q.x - d.width * q.x)); n >= d.height && (f = f + q.offsetY + (n * q.y - d.height * q.y)); h = Math.min(d.width, m); g = Math.min(d.height, n); break; case oe: m = d.width; n = d.height; break; case ph: case dl: p === ph ? (p = Math.min(d.height / n, d.width / m), m *= p, n *= p) : p === dl && (p = Math.max(d.height / n, d.width / m), m *= p, n *= p, m >= d.width && (e = (e + q.offsetX + (m * q.x - d.width * q.x) / m) * h), n >= d.height && (f = (f + q.offsetY + (n * q.y - d.height * q.y) / n) * g), h *= 1 / (m / d.width), g *= 1 / (n / d.height),
                                m = d.width, n = d.height)
                        }p = this.Fe() * b.scale; var r = h * g / (m * p * n * p), u = c.__goCache; p = null; var x = ro; if (c.Jr && void 0 !== u && r > x * x) for (null === u.Ei && (so(u, 4, k, l, c), so(u, 16, k, l, c)), k = u.Ei, l = k.length, p = k[0], x = 0; x < l; x++)if (k[x].ratio * k[x].ratio < r) p = k[x]; else break; if (!b.Bn) { if (null === this.Pl) if (null === this.Lg) this.Pl = !1; else { k = (new Jk(null)).context; k.drawImage(this.Lg, 0, 0); try { k.getImageData(0, 0, 1, 1).data[3] && (this.Pl = !1), this.Pl = !1 } catch (y) { this.Pl = !0 } } if (this.Pl) return } k = 0; m < d.width && (k = q.offsetX + (d.width * q.x -
                            m * q.x)); l = 0; n < d.height && (l = q.offsetY + (d.height * q.y - n * q.y)); switch (this.flip) { case fl: a.translate(Math.min(d.width, m), 0); a.scale(-1, 1); break; case el: a.translate(0, Math.min(d.height, n)); a.scale(1, -1); break; case gl: a.translate(Math.min(d.width, m), Math.min(d.height, n)), a.scale(-1, -1) }if (b.Ge("pictureRatioOptimization") && !b.qj && void 0 !== u && null !== p && 1 !== p.ratio) {
                                a.save(); b = p.ratio; try {
                                    a.drawImage(p.source, e / b, f / b, Math.min(p.source.width, h / b), Math.min(p.source.height, g / b), k, l, Math.min(d.width, m), Math.min(d.height,
                                        n))
                                } catch (y) { E && this.$k && Ga(y.toString()), this.$k = !1 } a.restore()
                            } else try { a.drawImage(c, e, f, h, g, k, l, Math.min(d.width, m), Math.min(d.height, n)) } catch (y) { E && this.$k && Ga(y.toString()), this.$k = !1 } switch (this.flip) { case fl: a.scale(-1, 1); a.translate(-Math.min(d.width, m), 0); break; case el: a.scale(1, -1); a.translate(0, -Math.min(d.height, n)); break; case gl: a.scale(-1, -1), a.translate(-Math.min(d.width, m), -Math.min(d.height, n)) }
                }
            }
        }
    };
    t.lm = function (a, b, c, d) {
        var e = this.desiredSize, f = ql(this, !0), g = this.Lg, h = this.gu; if (h || !this.rl && g && g.complete) this.rl = !0; null === g && (isFinite(e.width) || (a = 0), isFinite(e.height) || (b = 0)); isFinite(e.width) || f === oe || f === bl ? (isFinite(a) || (a = this.sourceRect.o() ? this.sourceRect.width : h ? +g.width : g.naturalWidth), c = 0) : null !== g && !1 !== this.rl && (a = this.sourceRect.o() ? this.sourceRect.width : h ? +g.width : g.naturalWidth); isFinite(e.height) || f === oe || f === cl ? (isFinite(b) || (b = this.sourceRect.o() ? this.sourceRect.height : h ?
            +g.height : g.naturalHeight), d = 0) : null !== g && !1 !== this.rl && (b = this.sourceRect.o() ? this.sourceRect.height : h ? +g.height : g.naturalHeight); isFinite(e.width) && (a = e.width); isFinite(e.height) && (b = e.height); e = this.maxSize; f = this.minSize; c = Math.max(c, f.width); d = Math.max(d, f.height); a = Math.min(e.width, a); b = Math.min(e.height, b); a = Math.max(c, a); b = Math.max(d, b); null === g || g.complete || (isFinite(a) || (a = 0), isFinite(b) || (b = 0)); Cc(this.rc, a, b); nl(this, 0, 0, a, b)
    }; t.uh = function (a, b, c, d) { sl(this, a, b, c, d) };
    na.Object.defineProperties(lk.prototype, {
        element: {
            configurable: !0, get: function () { return this.Lg }, set: function (a) {
                var b = this.Lg; if (b !== a) {
                null === a || a instanceof HTMLImageElement || a instanceof HTMLVideoElement || a instanceof HTMLCanvasElement || v("Picture.element must be an instance of Image, Canvas, or Video, not: " + a); this.gu = a instanceof HTMLCanvasElement; this.Lg = a; if (null !== a) if (a instanceof HTMLCanvasElement || !0 === a.complete) a.cl instanceof Event && null !== this.Ec && this.Ec(this, a.cl),
                    !0 === a.Jr && null !== this.gf && this.gf(this, a.xu), a.Jr = !0, this.desiredSize.o() || (yj(this, !1), this.v()); else { var c = this; a.Dw || (a.addEventListener("load", function (b) { po(a, b); c.desiredSize.o() || (yj(c, !1), c.v()) }), a.addEventListener("error", function (b) { qo(a, b) }), a.Dw = !0) } this.g("element", b, a); this.S()
                }
            }
        }, source: {
            configurable: !0, get: function () { return this.yp }, set: function (a) {
                var b = this.yp; if (b !== a) {
                    z(a, "string", lk, "source"); this.yp = a; var c = no, d = this.diagram, e = null; if (void 0 !== c[a]) e = c[a]; else {
                    30 <
                        oo && (tk(), c = no); e = xa("img"); var f = this; e.addEventListener("load", function (a) { po(e, a); f.desiredSize.o() || (yj(f, !1), f.v()) }); e.addEventListener("error", function (a) { qo(e, a) }); e.Dw = !0; var g = this.Hl; null !== g && (e.crossOrigin = g(this)); e.src = a; c[a] = e; oo++
                    } null !== d && pk(d, this); this.element = e; null !== d && kk(d, this); void 0 === e.__goCache && (e.__goCache = new to); this.v(); this.S(); this.g("source", b, a)
                }
            }
        }, sourceCrossOrigin: {
            configurable: !0, get: function () { return this.Hl }, set: function (a) {
                if (this.Hl !== a &&
                    (null !== a && z(a, "function", lk, "sourceCrossOrigin"), this.Hl = a, null !== this.element)) { var b = this.element.src; null === a && "string" === typeof b ? this.element.crossOrigin = null : null !== a && (this.element.crossOrigin = a(this)); this.element.src = b }
            }
        }, sourceRect: { configurable: !0, get: function () { return this.fh }, set: function (a) { var b = this.fh; b.A(a) || (w(a, L, lk, "sourceRect"), this.fh = a = a.J(), this.S(), this.g("sourceRect", b, a)) } }, imageStretch: {
            configurable: !0, get: function () { return this.el }, set: function (a) {
                var b =
                    this.el; b !== a && (tb(a, N, lk, "imageStretch"), this.el = a, this.S(), this.g("imageStretch", b, a))
            }
        }, flip: { configurable: !0, get: function () { return this.Ad }, set: function (a) { var b = this.Ad; b !== a && (tb(a, N, lk, "flip"), this.Ad = a, this.S(), this.g("flip", b, a)) } }, imageAlignment: { configurable: !0, get: function () { return this.dl }, set: function (a) { w(a, M, lk, "imageAlignment"); var b = this.dl; b.A(a) || (this.dl = a = a.J(), this.v(), this.g("imageAlignment", b, a)) } }, errorFunction: {
            configurable: !0, get: function () { return this.Ec },
            set: function (a) { var b = this.Ec; b !== a && (null !== a && z(a, "function", lk, "errorFunction"), this.Ec = a, this.g("errorFunction", b, a)) }
        }, successFunction: { configurable: !0, get: function () { return this.gf }, set: function (a) { var b = this.gf; b !== a && (null !== a && z(a, "function", lk, "successFunction"), this.gf = a, this.g("successFunction", b, a)) } }, naturalBounds: { configurable: !0, get: function () { return this.rc } }
    }); lk.prototype.redraw = lk.prototype.vf; lk.prototype.reloadSource = lk.prototype.Uz;
    var no = null, oo = 0, ro = 4; lk.className = "Picture"; no = new xb; lk.clearCache = tk; function to() { this.Ei = null } function so(a, b, c, d, e) { null === a.Ei && (a.Ei = []); var f = new Jk(null), g = f.context, h = 1 / b; f.width = c / b; f.height = d / b; b = new uo(f.Ha, b); c = 1; 0 < a.Ei.length && (c = a.Ei[a.Ei.length - 1], e = c.source, c = c.ratio); g.setTransform(h * c, 0, 0, h * c, 0, 0); g.drawImage(e, 0, 0); a.Ei.push(b) } to.className = "PictureCacheArray"; function uo(a, b) { this.source = a; this.ratio = b } uo.className = "PictureCacheInstance";
    function vo() { this.Zs = new me; this.gc = null } t = vo.prototype; t.reset = function (a) { null !== a ? (a.ja(), this.Zs = a, a.figures.clear()) : this.Zs = new me; this.gc = null }; function Be(a, b, c, d, e) { a.gc = new Xe; a.gc.startX = b; a.gc.startY = c; a.gc.isFilled = d; a.Zs.figures.add(a.gc); void 0 !== e && (a.gc.isShadowed = e) } function Je(a) { var b = a.gc.segments.length; 0 < b && a.gc.segments.O(b - 1).close() } t.Aq = function (a) { this.gc.isShadowed = a }; t.moveTo = function (a, b, c) { void 0 === c && (c = !1); var d = new Ye(Ne); d.endX = a; d.endY = b; c && d.close(); this.gc.segments.add(d) };
    t.lineTo = function (a, b, c) { void 0 === c && (c = !1); var d = new Ye(ve); d.endX = a; d.endY = b; c && d.close(); this.gc.segments.add(d) }; function Ce(a, b, c, d, e, f, g) { var h; void 0 === h && (h = !1); var k = new Ye(Oe); k.point1X = b; k.point1Y = c; k.point2X = d; k.point2Y = e; k.endX = f; k.endY = g; h && k.close(); a.gc.segments.add(k) } function He(a, b, c, d, e) { var f; void 0 === f && (f = !1); var g = new Ye(Pe); g.point1X = b; g.point1Y = c; g.endX = d; g.endY = e; f && g.close(); a.gc.segments.add(g) }
    t.arcTo = function (a, b, c, d, e, f, g) { void 0 === f && (f = 0); void 0 === g && (g = !1); var h = new Ye(Qe); h.startAngle = a; h.sweepAngle = b; h.centerX = c; h.centerY = d; h.radiusX = e; h.radiusY = 0 !== f ? f : e; g && h.close(); this.gc.segments.add(h) }; function Ie(a, b, c, d, e, f, g, h) { var k; void 0 === k && (k = !1); b = new Ye(Re, g, h, b, c, d, e, f); k && b.close(); a.gc.segments.add(b) } function Ae(a) { var b = Ke; if (null !== b) return Ke = null, b.reset(a), b; b = new vo; b.reset(a); return b } var Ke = null; vo.className = "StreamGeometryContext";
    function wo(a, b) { var c = a.toLowerCase(), d = K.be; d[a] = b; d[c] = a } wo("Rectangle", function (a, b, c) { a = new me(xe); a.startX = 0; a.startY = 0; a.endX = b; a.endY = c; return a }); wo("Square", function (a, b, c) { a = new me(xe); a.startX = 0; a.startY = 0; a.endX = b; a.endY = c; a.defaultStretch = ph; return a });
    wo("RoundedRectangle", function (a, b, c) { var d = a ? a.parameter1 : NaN; if (isNaN(d) || 0 >= d) d = 5; d = Math.min(d, b / 3); d = Math.min(d, c / 3); a = d * K.Ag; b = (new me).add((new Xe(d, 0, !0)).add(new Ye(ve, b - d, 0)).add(new Ye(Oe, b, d, b - a, 0, b, a)).add(new Ye(ve, b, c - d)).add(new Ye(Oe, b - d, c, b, c - a, b - a, c)).add(new Ye(ve, d, c)).add(new Ye(Oe, 0, c - d, a, c, 0, c - a)).add(new Ye(ve, 0, d)).add((new Ye(Oe, d, 0, 0, a, a, 0)).close())); 1 < a && (b.spot1 = new M(0, 0, a, a), b.spot2 = new M(1, 1, -a, -a)); return b }); wo("Border", "RoundedRectangle");
    wo("Ellipse", function (a, b, c) { a = new me(ye); a.startX = 0; a.startY = 0; a.endX = b; a.endY = c; a.spot1 = ee; a.spot2 = fe; return a }); wo("Circle", function (a, b, c) { a = new me(ye); a.startX = 0; a.startY = 0; a.endX = b; a.endY = c; a.spot1 = ee; a.spot2 = fe; a.defaultStretch = ph; return a }); wo("TriangleRight", function (a, b, c) { return (new me).add((new Xe(0, 0)).add(new Ye(ve, b, .5 * c)).add((new Ye(ve, 0, c)).close())).Cm(0, .25, .5, .75) });
    wo("TriangleDown", function (a, b, c) { return (new me).add((new Xe(0, 0)).add(new Ye(ve, b, 0)).add((new Ye(ve, .5 * b, c)).close())).Cm(.25, 0, .75, .5) }); wo("TriangleLeft", function (a, b, c) { return (new me).add((new Xe(b, c)).add(new Ye(ve, 0, .5 * c)).add((new Ye(ve, b, 0)).close())).Cm(.5, .25, 1, .75) }); wo("TriangleUp", function (a, b, c) { return (new me).add((new Xe(b, c)).add(new Ye(ve, 0, c)).add((new Ye(ve, .5 * b, 0)).close())).Cm(.25, .5, .75, 1) }); wo("Triangle", "TriangleUp");
    wo("Diamond", function (a, b, c) { return (new me).add((new Xe(.5 * b, 0)).add(new Ye(ve, 0, .5 * c)).add(new Ye(ve, .5 * b, c)).add((new Ye(ve, b, .5 * c)).close())).Cm(.25, .25, .75, .75) }); wo("LineH", function (a, b, c) { a = new me(pe); a.startX = 0; a.startY = c / 2; a.endX = b; a.endY = c / 2; return a }); wo("LineV", function (a, b, c) { a = new me(pe); a.startX = b / 2; a.startY = 0; a.endX = b / 2; a.endY = c; return a }); wo("None", "Rectangle"); wo("BarH", "Rectangle"); wo("BarV", "Rectangle"); wo("MinusLine", "LineH");
    wo("PlusLine", function (a, b, c) { return (new me).add((new Xe(0, c / 2, !1)).add(new Ye(ve, b, c / 2)).add(new Ye(Ne, b / 2, 0)).add(new Ye(ve, b / 2, c))) }); wo("XLine", function (a, b, c) { return (new me).add((new Xe(0, c, !1)).add(new Ye(ve, b, 0)).add(new Ye(Ne, 0, 0)).add(new Ye(ve, b, c))) });
    K.Fm = {
        "": "", Standard: "F1 m 0,0 l 8,4 -8,4 2,-4 z", Backward: "F1 m 8,0 l -2,4 2,4 -8,-4 z", Triangle: "F1 m 0,0 l 8,4.62 -8,4.62 z", BackwardTriangle: "F1 m 8,4 l 0,4 -8,-4 8,-4 0,4 z", Boomerang: "F1 m 0,0 l 8,4 -8,4 4,-4 -4,-4 z", BackwardBoomerang: "F1 m 8,0 l -8,4 8,4 -4,-4 4,-4 z", SidewaysV: "m 0,0 l 8,4 -8,4 0,-1 6,-3 -6,-3 0,-1 z", BackwardV: "m 8,0 l -8,4 8,4 0,-1 -6,-3 6,-3 0,-1 z", OpenTriangle: "m 0,0 l 8,4 -8,4", BackwardOpenTriangle: "m 8,0 l -8,4 8,4", OpenTriangleLine: "m 0,0 l 8,4 -8,4 m 8.5,0 l 0,-8",
        BackwardOpenTriangleLine: "m 8,0 l  -8,4 8,4 m -8.5,0 l 0,-8", OpenTriangleTop: "m 0,0 l 8,4 m 0,4", BackwardOpenTriangleTop: "m 8,0 l -8,4 m 0,4", OpenTriangleBottom: "m 0,8 l 8,-4", BackwardOpenTriangleBottom: "m 0,4 l 8,4", HalfTriangleTop: "F1 m 0,0 l 0,4 8,0 z m 0,8", BackwardHalfTriangleTop: "F1 m 8,0 l 0,4 -8,0 z m 0,8", HalfTriangleBottom: "F1 m 0,4 l 0,4 8,-4 z", BackwardHalfTriangleBottom: "F1 m 8,4 l 0,4 -8,-4 z", ForwardSemiCircle: "m 4,0 b 270 180 0 4 4", BackwardSemiCircle: "m 4,8 b 90 180 0 -4 4", Feather: "m 0,0 l 3,4 -3,4",
        BackwardFeather: "m 3,0 l -3,4 3,4", DoubleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4", BackwardDoubleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4", TripleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4 m 3,-8 l 3,4 -3,4", BackwardTripleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4 m 3,-8 l -3,4 3,4", ForwardSlash: "m 0,8 l 5,-8", BackSlash: "m 0,0 l 5,8", DoubleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8", DoubleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8", TripleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8 m -2,8 l 4,-8",
        TripleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8 m -2,-8 l 4,8", Fork: "m 0,4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4", BackwardFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4", LineFork: "m 0,0 l 0,8 m 0,-4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4", BackwardLineFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4 m 8,-8 l 0,8", CircleFork: "F1 m 6,4 b 0 360 -3 0 3 z m 0,0 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4", BackwardCircleFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 6,0 b 0 360 -3 0 3", CircleLineFork: "F1 m 6,4 b 0 360 -3 0 3 z m 1,-4 l 0,8 m 0,-4 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4",
        BackwardCircleLineFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 0,-4 l 0,8 m 7,-4 b 0 360 -3 0 3", Circle: "F1 m 8,4 b 0 360 -4 0 4 z", Block: "F1 m 0,0 l 0,8 8,0 0,-8 z", StretchedDiamond: "F1 m 0,3 l 5,-3 5,3 -5,3 -5,-3 z", Diamond: "F1 m 0,4 l 4,-4 4,4 -4,4 -4,-4 z", Chevron: "F1 m 0,0 l 5,0 3,4 -3,4 -5,0 3,-4 -3,-4 z", StretchedChevron: "F1 m 0,0 l 8,0 3,4 -3,4 -8,0 3,-4 -3,-4 z", NormalArrow: "F1 m 0,2 l 4,0 0,-2 4,4 -4,4 0,-2 -4,0 z", X: "m 0,0 l 8,8 m 0,-8 l -8,8", TailedNormalArrow: "F1 m 0,0 l 2,0 1,2 3,0 0,-2 2,4 -2,4 0,-2 -3,0 -1,2 -2,0 1,-4 -1,-4 z",
        DoubleTriangle: "F1 m 0,0 l 4,4 -4,4 0,-8 z  m 4,0 l 4,4 -4,4 0,-8 z", BigEndArrow: "F1 m 0,0 l 5,2 0,-2 3,4 -3,4 0,-2 -5,2 0,-8 z", ConcaveTailArrow: "F1 m 0,2 h 4 v -2 l 4,4 -4,4 v -2 h -4 l 2,-2 -2,-2 z", RoundedTriangle: "F1 m 0,1 a 1,1 0 0 1 1,-1 l 7,3 a 0.5,1 0 0 1 0,2 l -7,3 a 1,1 0 0 1 -1,-1 l 0,-6 z", SimpleArrow: "F1 m 1,2 l -1,-2 2,0 1,2 -1,2 -2,0 1,-2 5,0 0,-2 2,2 -2,2 0,-2 z", AccelerationArrow: "F1 m 0,0 l 0,8 0.2,0 0,-8 -0.2,0 z m 2,0 l 0,8 1,0 0,-8 -1,0 z m 3,0 l 2,0 2,4 -2,4 -2,0 0,-8 z", BoxArrow: "F1 m 0,0 l 4,0 0,2 2,0 0,-2 2,4 -2,4 0,-2 -2,0 0,2 -4,0 0,-8 z",
        TriangleLine: "F1 m 8,4 l -8,-4 0,8 8,-4 z m 0.5,4 l 0,-8", CircleEndedArrow: "F1 m 10,4 l -2,-3 0,2 -2,0 0,2 2,0 0,2 2,-3 z m -4,0 b 0 360 -3 0 3 z", DynamicWidthArrow: "F1 m 0,3 l 2,0 2,-1 2,-2 2,4 -2,4 -2,-2 -2,-1 -2,0 0,-2 z", EquilibriumArrow: "m 0,3 l 8,0 -3,-3 m 3,5 l -8,0 3,3", FastForward: "F1 m 0,0 l 3.5,4 0,-4 3.5,4 0,-4 1,0 0,8 -1,0 0,-4 -3.5,4 0,-4 -3.5,4 0,-8 z", Kite: "F1 m 0,4 l 2,-4 6,4 -6,4 -2,-4 z", HalfArrowTop: "F1 m 0,0 l 4,4 4,0 -8,-4 z m 0,8", HalfArrowBottom: "F1 m 0,8 l 4,-4 4,0 -8,4 z",
        OpposingDirectionDoubleArrow: "F1 m 0,4 l 2,-4 0,2 4,0 0,-2 2,4 -2,4 0,-2 -4,0 0,2 -2,-4 z", PartialDoubleTriangle: "F1 m 0,0 4,3 0,-3 4,4 -4,4 0,-3 -4,3 0,-8 z", LineCircle: "F1 m 0,0 l 0,8 m 7 -4 b 0 360 -3 0 3 z", DoubleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z", TripleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z", CircleLine: "F1 m 6 4 b 0 360 -3 0 3 z m 1,-4 l 0,8", DiamondCircle: "F1 m 8,4 l -4,4 -4,-4 4,-4 4,4 m 8,0 b 0 360 -4 0 4 z", PlusCircle: "F1 m 8,4 b 0 360 -4 0 4 l -8 0 z m -4 -4 l 0 8",
        OpenRightTriangleTop: "m 8,0 l 0,4 -8,0 m 0,4", OpenRightTriangleBottom: "m 8,8 l 0,-4 -8,0", Line: "m 0,0 l 0,8", DoubleLine: "m 0,0 l 0,8 m 2,0 l 0,-8", TripleLine: "m 0,0 l 0,8 m 2,0 l 0,-8 m 2,0 l 0,8", PentagonArrow: "F1 m 8,4 l -4,-4 -4,0 0,8 4,0 4,-4 z"
    };
    function R(a) { W.call(this, a); this.F = 2408959; this.Ug = this.Bf = ""; this.cp = this.$o = this.op = this.fo = null; this.qp = ""; this.zf = this.Rn = this.pp = this.dh = null; this.bp = ""; this.ap = xc; this.Rb = this.ep = ""; this.hi = this.dn = this.Th = null; this.oe = (new J(NaN, NaN)).freeze(); this.mo = ""; this.Ye = null; this.no = fd; this.fp = Qd; this.vo = hc; this.oo = ic; this.An = null; this.ho = 127; this.vi = jc; this.Mj = "gray"; this.Qd = 4; this.Gw = -1; this.Pp = NaN; this.Zx = new L; this.zj = null; this.Xg = NaN } ma(R, W);
    R.prototype.cloneProtected = function (a) { W.prototype.cloneProtected.call(this, a); a.F = this.F & -4097 | 49152; a.Bf = this.Bf; a.Ug = this.Ug; a.fo = this.fo; a.op = this.op; a.$o = this.$o; a.cp = this.cp; a.qp = this.qp; a.pp = this.pp; a.Rn = this.Rn; a.zf = null; a.bp = this.bp; a.ap = this.ap.J(); a.ep = this.ep; a.fp = this.fp.J(); a.Rb = this.Rb; a.dn = this.dn; a.oe.assign(this.oe); a.mo = this.mo; a.no = this.no.J(); a.vo = this.vo.J(); a.oo = this.oo.J(); a.An = this.An; a.ho = this.ho; a.vi = this.vi.J(); a.Mj = this.Mj; a.Qd = this.Qd; a.Pp = this.Pp };
    R.prototype.qf = function (a) { W.prototype.qf.call(this, a); a.zh(); a.dh = null; a.Ye = null; a.zj = null }; R.prototype.toString = function () { var a = Va(this.constructor) + "#" + Jb(this); null !== this.data && (a += "(" + Wa(this.data) + ")"); return a }; R.prototype.sk = function (a, b, c, d, e, f, g) { var h = this.diagram; null !== h && (a === qf && "elements" === b ? e instanceof W ? Qj(e, function (a) { Sj(h.partManager, a); Rj(h, a) }) : kk(h, e) : a === rf && "elements" === b && (e instanceof W ? Qj(e, function (a) { Wj(h.partManager, a); Vj(h, a) }) : pk(h, e)), h.cb(a, b, c, d, e, f, g)) };
    R.prototype.Fa = function (a) { W.prototype.Fa.call(this, a); if (null !== this.data) { a = this.Z.j; for (var b = a.length, c = 0; c < b; c++) { var d = a[c]; d instanceof W && Qj(d, function (a) { null !== a.data && a.Fa() }) } } }; R.prototype.updateRelationshipsFromData = function () { null !== this.data && this.diagram.partManager.updateRelationshipsFromData(this) }; R.prototype.dk = function (a) { E && z(a, "string", R, "findAdornment:category"); var b = this.zf; return null === b ? null : b.K(a) };
    R.prototype.qh = function (a, b) { if (null !== b) { E && (z(a, "string", R, "addAdornment:category"), w(b, Cf, R, "addAdornment:ad")); var c = null, d = this.zf; null !== d && (c = d.K(a)); if (c !== b) { if (null !== c) { var e = c.diagram; null !== e && e.remove(c) } null === d && (this.zf = d = new Ub); b.Bf !== a && (b.category = a); d.add(a, b); a = this.diagram; null !== a && (a.add(b), a = b.adornedObject, null !== a && (a = a.Ki(), null !== a && (b.data = a.data))) } } };
    R.prototype.wf = function (a) { E && z(a, "string", R, "removeAdornment:category"); var b = this.zf; if (null !== b) { var c = b.K(a); if (null !== c) { var d = c.diagram; null !== d && d.remove(c) } b.remove(a); 0 === b.count && (this.zf = null) } }; R.prototype.Wj = function () { var a = this.zf; if (null !== a) { var b = Qa(); for (a = a.iterator; a.next();)b.push(a.key); a = b.length; for (var c = 0; c < a; c++)this.wf(b[c]); Ta(b) } };
    R.prototype.updateAdornments = function () {
        var a = this.diagram; if (null !== a) {
            for (var b = this.adornments; b.next();) { var c = b.value; c.v(); c.placeholder && c.placeholder.v() } a: {
                if (this.isSelected && this.selectionAdorned && (b = this.selectionObject, null !== b && this.actualBounds.o() && this.isVisible() && b.uf() && b.actualBounds.o())) {
                    c = this.dk("Selection"); if (null === c) {
                        c = this.selectionAdornmentTemplate; null === c && (c = this.Ah() ? a.linkSelectionAdornmentTemplate : this instanceof xg ? a.groupSelectionAdornmentTemplate : a.nodeSelectionAdornmentTemplate);
                        if (!(c instanceof Cf)) break a; mh(c); c = c.copy(); null !== c && (this.Ah() && this.selectionObject === this.path && (c.type = W.Link), c.adornedObject = b)
                    } if (null !== c) { if (null !== c.placeholder) { var d = b.Fe(), e = 0; b instanceof Hg && (e = b.strokeWidth); var f = Zb.alloc(); f.h((b.naturalBounds.width + e) * d, (b.naturalBounds.height + e) * d); Zb.free(f) } c.type === W.Link ? c.v() : (b = J.alloc(), J.free(b)); this.qh("Selection", c); break a }
                } this.wf("Selection")
            } xo(this, a); for (b = this.adornments; b.next();)b.value.Fa()
        }
    };
    R.prototype.Mb = function () { var a = this.diagram; null !== a && (dj(a), 0 !== (this.F & 16384) !== !0 && (wi(this, !0), a.ec())) }; function vi(a) { 0 !== (a.F & 16384) !== !1 && (a.updateAdornments(), wi(a, !1)) } function xo(a, b) { b.toolManager.mouseDownTools.each(function (b) { b.isEnabled && b.updateAdornments(a) }); b.toolManager.updateAdornments(a) } function yo(a) { if (!1 === Fj(a)) { zo(a, !0); a.jl(); var b = a.diagram; null !== b && (b.Fd.add(a), b.ec()) } }
    function Ao(a) { a.F |= 2097152; if (!1 !== Fj(a)) { var b = a.position, c = a.location; c.o() && b.o() || Bo(a, b, c); c = a.wb; var d = L.alloc().assign(c); c.ja(); c.x = b.x; c.y = b.y; c.freeze(); a.qt(d, c); L.free(d); zo(a, !1) } } R.prototype.move = function (a, b) { !0 === b ? this.location = a : this.position = a }; R.prototype.moveTo = function (a, b, c) { a = J.allocAt(a, b); this.move(a, c); J.free(a) };
    R.prototype.isVisible = function () { if (!this.visible) return !1; var a = this.layer; if (null !== a && !a.visible) return !1; a = this.diagram; if (null !== a && li(a.animationManager, this)) return !0; a = this.containingGroup; return null === a || a.isSubGraphExpanded && a.isVisible() ? !0 : !1 }; t = R.prototype; t.Ob = function (a) { var b = this.diagram; a ? (this.C(4), this.Mb(), null !== b && b.Fd.add(this)) : (this.C(8), this.Wj()); this.zh(); null !== b && (b.Ya(), b.S()) };
    t.bb = function (a) { if (this.name === a) return this; var b = this.zj; null === b && (this.zj = b = new Ub); if (null !== b.K(a)) return b.K(a); var c = W.prototype.bb.call(this, a); if (null !== c) return b.set(a, c), c; b.set(a, null); return null }; t.rf = function (a, b, c) { void 0 === c && (c = new J); b = b.Nb() ? qd : b; var d = a.naturalBounds; c.h(d.width * b.x + b.offsetX, d.height * b.y + b.offsetY); if (null === a || a === this) return c; a.transform.va(c); for (a = a.panel; null !== a && a !== this;)a.transform.va(c), a = a.panel; this.Qf.va(c); c.offset(-this.qc.x, -this.qc.y); return c };
    t.eq = function (a) { void 0 === a && (a = new L); return a.assign(this.actualBounds) }; t.bc = function () { !0 === Dj(this) && (this instanceof xg && this.memberParts.each(function (a) { a.bc() }), this.measure(Infinity, Infinity)); this.arrange() };
    function Oj(a, b) { var c = a.Zx; isNaN(a.Xg) && (a.Xg = mn(a)); var d = a.Xg; var e = 2 * d; if (!a.isShadowed) return c.h(b.x - 1 - d, b.y - 1 - d, b.width + 2 + e, b.height + 2 + e), c; d = b.x; e = b.y; var f = b.width; b = b.height; var g = a.shadowBlur; a = a.shadowOffset; f += g; b += g; d -= g / 2; e -= g / 2; 0 < a.x ? f += a.x : (d += a.x, f -= a.x); 0 < a.y ? b += a.y : (e += a.y, b -= a.y); c.h(d - 1, e - 1, f + 2, b + 2); return c }
    R.prototype.arrange = function () { if (!1 === Ej(this)) Ao(this); else { var a = this.wb, b = L.alloc(); b.assign(a); a.ja(); var c = Dg(this); this.uh(0, 0, this.qc.width, this.qc.height); var d = this.position; Bo(this, d, this.location); a.x = d.x; a.y = d.y; a.freeze(); this.qt(b, a); rl(this, !1); b.A(a) ? this.kd(c) : !this.dc() || K.B(b.width, a.width) && K.B(b.height, a.height) || 0 <= this.Gw && this.C(16); L.free(b); zo(this, !1) } }; t = R.prototype;
    t.qt = function (a, b) { var c = this.diagram; if (null !== c) { var d = !1; if (!1 === c.Rg && a.o()) { var e = L.alloc(); e.assign(c.documentBounds); e.Vv(c.padding); a.x > e.x && a.y > e.y && a.right < e.right && a.bottom < e.bottom && b.x > e.x && b.y > e.y && b.right < e.right && b.bottom < e.bottom && (d = !0); L.free(e) } 0 !== (this.F & 65536) !== !0 && a.A(b) || Tj(this, d, c); c.S(); Fc(a, b) || (this instanceof V && !c.undoManager.isUndoingRedoing && this.gd(), this.zh()) } };
    t.Rv = function (a, b) { if (this.Ah() || !a.o()) return !1; var c = this.diagram; if (null !== c && (Co(this, c, a, b), !0 === c.undoManager.isUndoingRedoing)) return !0; this.ua = a; this.F &= -2097153; c = this.oe; c.o() && (this.oe = new J(c.x + (a.x - b.x), c.y + (a.y - b.y)), this.g("location", c, this.oe)); !1 === Fj(this) && !1 === Ej(this) && (yo(this), Ao(this)); return !0 }; function Co(a, b, c, d) { null === b || a instanceof Cf || (b = b.animationManager, b.oi && b.sh(a, "position", d.copy(), c.copy(), !1)) }
    t.Bt = function (a, b) { var c = this.oe, d = this.ua; Fj(this) || Ej(this) ? c.h(NaN, NaN) : c.h(c.x + a - d.x, c.y + b - d.y); d.h(a, b); yo(this) }; t.Sv = function () { this.F &= -2097153; yo(this) };
    function Bo(a, b, c) {
        var d = J.alloc(), e = a.locationSpot, f = a.locationObject; e.Nb() && v("determineOffset: Part's locationSpot must be real: " + e.toString()); var g = f.naturalBounds, h = f instanceof Hg ? f.strokeWidth : 0; d.uk(0, 0, g.width + h, g.height + h, e); if (f !== a) for (d.offset(-h / 2, -h / 2), f.transform.va(d), e = f.panel; null !== e && e !== a;)e.transform.va(d), e = e.panel; a.Qf.va(d); d.offset(-a.qc.x, -a.qc.y); e = a.diagram; f = c.o(); g = b.o(); f && g ? 0 !== (a.F & 2097152) ? Do(a, b, c, e, d) : Eo(a, b, c, e, d) : f ? Do(a, b, c, e, d) : g && Eo(a, b, c, e, d); a.F |= 2097152;
        J.free(d); a.jl()
    } function Do(a, b, c, d, e) { var f = b.x, g = b.y; b.h(c.x - e.x, c.y - e.y); null !== d && (c = d.animationManager, (e = c.isAnimating) || !c.oi || a instanceof Cf || c.sh(a, "position", new J(f, g), b, !1), e || b.x === f && b.y === g || (c = d.skipsUndoManager, d.skipsUndoManager = !0, a.g("position", new J(f, g), b), d.skipsUndoManager = c)) } function Eo(a, b, c, d, e) { var f = c.copy(); c.h(b.x + e.x, b.y + e.y); c.A(f) || null === d || (b = d.skipsUndoManager, d.skipsUndoManager = !0, a.g("location", f, c), d.skipsUndoManager = b) }
    function Tj(a, b, c) { tl(a, !1); a instanceof V && Ek(c, a); a.layer.isTemporary || b || c.Ya(); b = a.wb; var d = c.viewportBounds; d.o() ? Dg(a) ? (Lc(b, d, 10) || a.kd(!1), a.updateAdornments()) : b.Kc(d) ? (a.kd(!0), a.updateAdornments()) : a.Mb() : c.di = !0 } t.Ui = function () { return !0 }; t.dc = function () { return !0 }; t.Ah = function () { return !1 }; t.vg = function () { return !0 };
    function Fo(a, b, c, d) {
    b.constructor === a.constructor || Go || (Go = !0, Ga('Should not change the class of the Part when changing category from "' + c + '" to "' + d + '"'), Ga("  Old class: " + Va(a.constructor) + ", new class: " + Va(b.constructor) + ", part: " + a.toString())); a.Wj(); var e = a.data; c = a.layerName; var f = a.isSelected, g = a.isHighlighted, h = !0, k = !0, l = !1; a instanceof V && (h = a.isTreeLeaf, k = a.isTreeExpanded, l = a.wasTreeExpanded); b.qf(a); b.cloneProtected(a); a.Bf = d; a.v(); a.S(); b = a.diagram; d = !0; null !== b && (d = b.skipsUndoManager,
        b.skipsUndoManager = !0); a.kb = e; a.F = f ? a.F | 4096 : a.F & -4097; a.F = g ? a.F | 524288 : a.F & -524289; a instanceof V && (a.T = h ? a.T | 4 : a.T & -5, a.T = k ? a.T | 1 : a.T & -2, a.T = l ? a.T | 2 : a.T & -3); null !== e && a.Fa(); e = a.layerName; e !== c && (a.Ug = c, a.layerName = e); null !== b && (b.skipsUndoManager = d); a.dc() && a.C(64)
    } R.prototype.canCopy = function () { if (!this.copyable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowCopy) return !1; a = a.diagram; return null === a ? !0 : a.allowCopy ? !0 : !1 };
    R.prototype.canDelete = function () { if (!this.deletable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowDelete) return !1; a = a.diagram; return null === a ? !0 : a.allowDelete ? !0 : !1 }; R.prototype.canEdit = function () { if (!this.textEditable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowTextEdit) return !1; a = a.diagram; return null === a ? !0 : a.allowTextEdit ? !0 : !1 };
    R.prototype.canGroup = function () { if (!this.groupable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowGroup) return !1; a = a.diagram; return null === a ? !0 : a.allowGroup ? !0 : !1 }; R.prototype.canMove = function () { if (!this.movable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowMove) return !1; a = a.diagram; return null === a ? !0 : a.allowMove ? !0 : !1 };
    R.prototype.canReshape = function () { if (!this.reshapable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowReshape) return !1; a = a.diagram; return null === a ? !0 : a.allowReshape ? !0 : !1 }; R.prototype.canResize = function () { if (!this.resizable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowResize) return !1; a = a.diagram; return null === a ? !0 : a.allowResize ? !0 : !1 };
    R.prototype.canRotate = function () { if (!this.rotatable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowRotate) return !1; a = a.diagram; return null === a ? !0 : a.allowRotate ? !0 : !1 }; R.prototype.canSelect = function () { if (!this.selectable) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowSelect) return !1; a = a.diagram; return null === a ? !0 : a.allowSelect ? !0 : !1 }; function wi(a, b) { a.F = b ? a.F | 16384 : a.F & -16385 } function Fj(a) { return 0 !== (a.F & 32768) } function zo(a, b) { a.F = b ? a.F | 32768 : a.F & -32769 }
    function tl(a, b) { a.F = b ? a.F | 65536 : a.F & -65537 } function Dg(a) { return 0 !== (a.F & 131072) } t = R.prototype; t.kd = function (a) { this.F = a ? this.F | 131072 : this.F & -131073 }; function Ho(a, b) { a.F = b ? a.F | 1048576 : a.F & -1048577 } t.zh = function () { var a = this.containingGroup; null !== a && (a.v(), null !== a.placeholder && a.placeholder.v(), a.gd()) }; t.S = function () { var a = this.diagram; null !== a && !Ej(this) && !Fj(this) && this.isVisible() && this.wb.o() && a.S(Oj(this, this.wb)) };
    t.v = function () { W.prototype.v.call(this); var a = this.diagram; null !== a && (a.Fd.add(this), this instanceof V && null !== this.labeledLink && Il(this.labeledLink), a.ec(!0)) }; t.hq = function (a) { a || (a = this.Th, null !== a && Io(a, this)) }; t.iq = function (a) { a || (a = this.Th, null !== a && Jo(a, this)) }; t.bk = function () { var a = this.data; if (null !== a) { var b = this.diagram; null !== b && (b = b.model, null !== b && b.tm(a)) } }; t.az = function () { return Ko(this, this) };
    function Ko(a, b) { var c = b.containingGroup; return null !== c ? 1 + Ko(a, c) : b instanceof V && (b = b.labeledLink, null !== b) ? Ko(a, b) : 0 } t.dz = function () { return Lo(this, this) }; function Lo(a, b) { var c = b.containingGroup; return null !== c || b instanceof V && (c = b.labeledLink, null !== c) ? Lo(a, c) : b } t.Xd = function (a) { return a instanceof xg ? Mo(this, this, a) : !1 }; function Mo(a, b, c) { if (b === c || null === c) return !1; var d = b.containingGroup; return null === d || d !== c && !Mo(a, d, c) ? b instanceof V && (b = b.labeledLink, null !== b) ? Mo(a, b, c) : !1 : !0 }
    t.lx = function (a) { if (null === a) return null; E && w(a, R, R, "findCommonContainingGroup:other"); if (this === a) return this.containingGroup; for (var b = this; null !== b;) { b instanceof xg && Ho(b, !0); if (b instanceof V) { var c = b.labeledLink; null !== c && (b = c) } b = b.containingGroup } c = null; for (b = a; null !== b;) { if (0 !== (b.F & 1048576)) { c = b; break } b instanceof V && (a = b.labeledLink, null !== a && (b = a)); b = b.containingGroup } for (b = this; null !== b;)b instanceof xg && Ho(b, !1), b instanceof V && (a = b.labeledLink, null !== a && (b = a)), b = b.containingGroup; return c };
    R.prototype.canLayout = function () { if (!this.isLayoutPositioned || !this.isVisible()) return !1; var a = this.layer; return null !== a && a.isTemporary || this instanceof V && this.isLinkLabel ? !1 : !0 };
    R.prototype.C = function (a) { void 0 === a && (a = 16777215); if (this.isLayoutPositioned && 0 !== (a & this.layoutConditions)) { var b = this.layer; null !== b && b.isTemporary || this instanceof V && this.isLinkLabel ? b = !1 : (b = this.diagram, b = null !== b && b.undoManager.isUndoingRedoing ? !1 : !0) } else b = !1; if (b) if (b = this.Th, null !== b) { var c = b.layout; null !== c ? c.C() : b.C(a) } else a = this.diagram, null !== a && (a = a.layout, null !== a && a.C()) }; function Uj(a) { if (!a.isVisible()) return !1; a = a.layer; return null !== a && a.isTemporary ? !1 : !0 }
    function Yk(a, b, c, d, e, f) {
    void 0 === f && (f = null); if (!(a.contains(b) || null !== f && !f(b) || b instanceof Cf)) if (a.add(b), b instanceof V) { if (c && b instanceof xg) for (var g = b.memberParts; g.next();)Yk(a, g.value, c, d, e, f); if (!1 !== e) for (g = b.linksConnected; g.next();) { var h = g.value; if (!a.contains(h)) { var k = h.fromNode, l = h.toNode; k = null === k || a.contains(k); l = null === l || a.contains(l); (e ? k && l : k || l) && Yk(a, h, c, d, e, f) } } if (1 < d) for (b = b.hv(); b.next();)Yk(a, b.value, c, d - 1, e, f) } else if (b instanceof Q) for (b = b.labelNodes; b.next();)Yk(a,
        b.value, c, d, e, f)
    }
    na.Object.defineProperties(R.prototype, {
        key: { configurable: !0, get: function () { var a = this.diagram; if (null !== a) return a.model.ra(this.data) } }, adornments: { configurable: !0, get: function () { return null === this.zf ? Cb : this.zf.iteratorValues } }, layer: { configurable: !0, get: function () { return this.hi } }, diagram: { configurable: !0, get: function () { var a = this.hi; return null !== a ? a.diagram : null } }, layerName: {
            configurable: !0, get: function () { return this.Ug }, set: function (a) {
                var b =
                    this.Ug; if (b !== a) {
                        z(a, "string", R, "layerName"); var c = this.diagram; if (null === c || null !== c.cm(a) && !c.partManager.addsToTemporaryLayer) if (this.Ug = a, null !== c && c.Ya(), this.g("layerName", b, a), b = this.layer, null !== b && b.name !== a && (c = b.diagram, null !== c && (a = c.cm(a), null !== a && a !== b))) {
                            var d = b.zc(-1, this, !0); 0 <= d && c.cb(rf, "parts", b, this, null, d, !0); d = a.Ri(99999999, this, !0); b.visible !== a.visible && this.Ob(a.visible); 0 <= d && c.cb(qf, "parts", a, null, this, !0, d); d = this.layerChanged; if (null !== d) {
                                var e = c.fa; c.fa = !0; d(this,
                                    b, a); c.fa = e
                            }
                        }
                    }
            }
        }, layerChanged: { configurable: !0, get: function () { return this.fo }, set: function (a) { var b = this.fo; b !== a && (null !== a && z(a, "function", R, "layerChanged"), this.fo = a, this.g("layerChanged", b, a)) } }, zOrder: { configurable: !0, get: function () { return this.Pp }, set: function (a) { var b = this.Pp; if (b !== a) { z(a, "number", R, "zOrder"); this.Pp = a; var c = this.layer; null !== c && zi(c, -1, this); this.g("zOrder", b, a); a = this.diagram; null !== a && a.S() } } }, locationObject: {
            configurable: !0, get: function () {
                if (null ===
                    this.Ye) { var a = this.locationObjectName; "" !== a ? (a = this.bb(a), null !== a ? this.Ye = a : this.Ye = this) : this instanceof Cf ? this.type !== W.Link && null !== this.placeholder ? this.Ye = this.placeholder : this.Ye = this : this.Ye = this } return this.Ye.visible ? this.Ye : this
            }
        }, minLocation: { configurable: !0, get: function () { return this.vo }, set: function (a) { var b = this.vo; b.A(a) || (E && w(a, J, R, "minLocation"), this.vo = a = a.J(), this.g("minLocation", b, a)) } }, maxLocation: {
            configurable: !0, get: function () { return this.oo },
            set: function (a) { var b = this.oo; b.A(a) || (E && w(a, J, R, "maxLocation"), this.oo = a = a.J(), this.g("maxLocation", b, a)) }
        }, locationObjectName: { configurable: !0, get: function () { return this.mo }, set: function (a) { var b = this.mo; b !== a && (E && z(a, "string", R, "locationObjectName"), this.mo = a, this.Ye = null, this.v(), this.g("locationObjectName", b, a)) } }, locationSpot: {
            configurable: !0, get: function () { return this.no }, set: function (a) {
                var b = this.no; b.A(a) || (E && (w(a, M, R, "locationSpot"), a.Za() || v("Part.locationSpot must be a specific Spot value, not: " +
                    a)), this.no = a = a.J(), this.v(), this.g("locationSpot", b, a))
            }
        }, location: { configurable: !0, get: function () { return this.oe }, set: function (a) { E && w(a, J, R, "location"); var b = a.x, c = a.y, d = this.oe, e = d.x, f = d.y; (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) || (a = a.J(), b = a, this.Ah() ? b = !1 : (this.oe = b, this.F |= 2097152, !1 === Ej(this) && (yo(this), c = this.ua, c.o() && (e = c.copy(), c.h(c.x + (b.x - d.x), c.y + (b.y - d.y)), Co(this, this.diagram, c, e), this.g("position", e, c))), b = !0), b && this.g("location", d, a)) } }, category: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Bf }, set: function (a) {
                var b = this.Bf; if (b !== a) {
                    z(a, "string", R, "category"); var c = this.diagram, d = this.data, e = null; if (null !== c && null !== d && !(this instanceof Cf)) { var f = c.model.undoManager; f.isEnabled && !f.isUndoingRedoing && (e = this.clone(), e.Z.addAll(this.Z)) } this.Bf = a; this.g("category", b, a); null === c || null === d || this instanceof Cf ? this instanceof Cf && (e = this.adornedPart, null !== e && (a = e.zf, null !== a && a.remove(b), e.qh(this.category, this))) : (f = c.model, f.undoManager.isUndoingRedoing ||
                        (this.Ah() ? (c.partManager.setLinkCategoryForData(d, a), c = c.partManager.findLinkTemplateForCategory(a), null !== c && (mh(c), c = c.copy(), null !== c && Fo(this, c, b, a))) : (null !== f && f.zq(d, a), c = No(c.partManager, d, a), null !== c && (mh(c), c = c.copy(), null === c || c instanceof Q || (d = this.location.copy(), Fo(this, c, b, a), this.location.o() || (this.location = d)))), null !== e && (b = this.clone(), b.Z.addAll(this.Z), this.g("self", e, b))))
                }
            }
        }, self: {
            configurable: !0, get: function () { return this }, set: function (a) {
                Fo(this, a, this.category,
                    a.category)
            }
        }, copyable: { configurable: !0, get: function () { return 0 !== (this.F & 1) }, set: function (a) { var b = 0 !== (this.F & 1); b !== a && (E && z(a, "boolean", R, "copyable"), this.F ^= 1, this.g("copyable", b, a)) } }, deletable: { configurable: !0, get: function () { return 0 !== (this.F & 2) }, set: function (a) { var b = 0 !== (this.F & 2); b !== a && (E && z(a, "boolean", R, "deletable"), this.F ^= 2, this.g("deletable", b, a)) } }, textEditable: {
            configurable: !0, get: function () { return 0 !== (this.F & 4) }, set: function (a) {
                var b =
                    0 !== (this.F & 4); b !== a && (E && z(a, "boolean", R, "textEditable"), this.F ^= 4, this.g("textEditable", b, a), this.Mb())
            }
        }, groupable: { configurable: !0, get: function () { return 0 !== (this.F & 8) }, set: function (a) { var b = 0 !== (this.F & 8); b !== a && (E && z(a, "boolean", R, "groupable"), this.F ^= 8, this.g("groupable", b, a)) } }, movable: { configurable: !0, get: function () { return 0 !== (this.F & 16) }, set: function (a) { var b = 0 !== (this.F & 16); b !== a && (E && z(a, "boolean", R, "movable"), this.F ^= 16, this.g("movable", b, a)) } }, selectionAdorned: {
            configurable: !0,
            enumerable: !0, get: function () { return 0 !== (this.F & 32) }, set: function (a) { var b = 0 !== (this.F & 32); b !== a && (E && z(a, "boolean", R, "selectionAdorned"), this.F ^= 32, this.g("selectionAdorned", b, a), this.Mb()) }
        }, isInDocumentBounds: { configurable: !0, get: function () { return 0 !== (this.F & 64) }, set: function (a) { var b = 0 !== (this.F & 64); if (b !== a) { E && z(a, "boolean", R, "isInDocumentBounds"); this.F ^= 64; var c = this.diagram; null !== c && c.Ya(); this.g("isInDocumentBounds", b, a) } } }, isLayoutPositioned: {
            configurable: !0,
            get: function () { return 0 !== (this.F & 128) }, set: function (a) { var b = 0 !== (this.F & 128); b !== a && (E && z(a, "boolean", R, "isLayoutPositioned"), this.F ^= 128, this.g("isLayoutPositioned", b, a), this.C(a ? 4 : 8)) }
        }, selectable: { configurable: !0, get: function () { return 0 !== (this.F & 256) }, set: function (a) { var b = 0 !== (this.F & 256); b !== a && (E && z(a, "boolean", R, "selectable"), this.F ^= 256, this.g("selectable", b, a), this.Mb()) } }, reshapable: {
            configurable: !0, get: function () { return 0 !== (this.F & 512) }, set: function (a) {
                var b =
                    0 !== (this.F & 512); b !== a && (E && z(a, "boolean", R, "reshapable"), this.F ^= 512, this.g("reshapable", b, a), this.Mb())
            }
        }, resizable: { configurable: !0, get: function () { return 0 !== (this.F & 1024) }, set: function (a) { var b = 0 !== (this.F & 1024); b !== a && (E && z(a, "boolean", R, "resizable"), this.F ^= 1024, this.g("resizable", b, a), this.Mb()) } }, rotatable: {
            configurable: !0, get: function () { return 0 !== (this.F & 2048) }, set: function (a) {
                var b = 0 !== (this.F & 2048); b !== a && (E && z(a, "boolean", R, "rotatable"), this.F ^= 2048, this.g("rotatable",
                    b, a), this.Mb())
            }
        }, isSelected: {
            configurable: !0, get: function () { return 0 !== (this.F & 4096) }, set: function (a) {
                var b = 0 !== (this.F & 4096); if (b !== a) {
                    E && z(a, "boolean", R, "isSelected"); var c = this.diagram; if (!a || this.canSelect() && !(null !== c && c.selection.count >= c.maxSelectionCount)) {
                    this.F ^= 4096; var d = !1; if (null !== c) { d = c.skipsUndoManager; c.skipsUndoManager = !0; var e = c.selection; e.ja(); a ? e.add(this) : e.remove(this); e.freeze() } this.g("isSelected", b, a); this.Mb(); a = this.selectionChanged; null !== a && a(this);
                        null !== c && (c.ec(), c.skipsUndoManager = d)
                    }
                }
            }
        }, isHighlighted: { configurable: !0, get: function () { return 0 !== (this.F & 524288) }, set: function (a) { var b = 0 !== (this.F & 524288); if (b !== a) { E && z(a, "boolean", R, "isHighlighted"); this.F ^= 524288; var c = this.diagram; null !== c && (c = c.highlighteds, c.ja(), a ? c.add(this) : c.remove(this), c.freeze()); this.g("isHighlighted", b, a); this.S(); a = this.highlightedChanged; null !== a && a(this) } } }, isShadowed: {
            configurable: !0, get: function () { return 0 !== (this.F & 8192) }, set: function (a) {
                var b =
                    0 !== (this.F & 8192); b !== a && (E && z(a, "boolean", R, "isShadowed"), this.F ^= 8192, this.g("isShadowed", b, a), this.S())
            }
        }, isAnimated: { configurable: !0, get: function () { return 0 !== (this.F & 262144) }, set: function (a) { var b = 0 !== (this.F & 262144); b !== a && (E && z(a, "boolean", R, "isAnimated"), this.F ^= 262144, this.g("isAnimated", b, a)) } }, highlightedChanged: {
            configurable: !0, get: function () { return this.Rn }, set: function (a) {
                var b = this.Rn; b !== a && (null !== a && z(a, "function", R, "highlightedChanged"), this.Rn = a, this.g("highlightedChanged",
                    b, a))
            }
        }, selectionObjectName: { configurable: !0, get: function () { return this.qp }, set: function (a) { var b = this.qp; b !== a && (E && z(a, "string", R, "selectionObjectName"), this.qp = a, this.dh = null, this.g("selectionObjectName", b, a)) } }, selectionAdornmentTemplate: { configurable: !0, get: function () { return this.op }, set: function (a) { var b = this.op; b !== a && (E && w(a, Cf, R, "selectionAdornmentTemplate"), this.op = a, this.g("selectionAdornmentTemplate", b, a)) } }, selectionObject: {
            configurable: !0, get: function () {
                if (null ===
                    this.dh) { var a = this.selectionObjectName; null !== a && "" !== a ? (a = this.bb(a), null !== a ? this.dh = a : this.dh = this) : this instanceof Q ? (a = this.path, null !== a ? this.dh = a : this.dh = this) : this.dh = this } return this.dh
            }
        }, selectionChanged: { configurable: !0, get: function () { return this.pp }, set: function (a) { var b = this.pp; b !== a && (null !== a && z(a, "function", R, "selectionChanged"), this.pp = a, this.g("selectionChanged", b, a)) } }, resizeAdornmentTemplate: {
            configurable: !0, get: function () { return this.$o }, set: function (a) {
                var b =
                    this.$o; b !== a && (E && w(a, Cf, R, "resizeAdornmentTemplate"), this.$o = a, this.g("resizeAdornmentTemplate", b, a))
            }
        }, resizeObjectName: { configurable: !0, get: function () { return this.bp }, set: function (a) { var b = this.bp; b !== a && (E && z(a, "string", R, "resizeObjectName"), this.bp = a, this.g("resizeObjectName", b, a)) } }, resizeObject: { configurable: !0, get: function () { var a = this.resizeObjectName; return "" !== a && (a = this.bb(a), null !== a) ? a : this } }, resizeCellSize: {
            configurable: !0, get: function () { return this.ap },
            set: function (a) { var b = this.ap; b.A(a) || (E && w(a, Zb, R, "resizeCellSize"), this.ap = a = a.J(), this.g("resizeCellSize", b, a)) }
        }, rotateAdornmentTemplate: { configurable: !0, get: function () { return this.cp }, set: function (a) { var b = this.cp; b !== a && (E && w(a, Cf, R, "rotateAdornmentTemplate"), this.cp = a, this.g("rotateAdornmentTemplate", b, a)) } }, rotateObjectName: {
            configurable: !0, get: function () { return this.ep }, set: function (a) {
                var b = this.ep; b !== a && (E && z(a, "string", R, "rotateObjectName"), this.ep = a, this.g("rotateObjectName",
                    b, a))
            }
        }, rotateObject: { configurable: !0, get: function () { var a = this.rotateObjectName; return "" !== a && (a = this.bb(a), null !== a) ? a : this } }, rotationSpot: { configurable: !0, get: function () { return this.fp }, set: function (a) { var b = this.fp; b.A(a) || (E && (w(a, M, R, "rotationSpot"), a === Qd || a.Za() || v("Part.rotationSpot must be a specific Spot value or Spot.Default, not: " + a)), this.fp = a = a.J(), this.g("rotationSpot", b, a)) } }, text: {
            configurable: !0, get: function () { return this.Rb }, set: function (a) {
                var b =
                    this.Rb; b !== a && (E && z(a, "string", R, "text"), this.Rb = a, this.g("text", b, a))
            }
        }, containingGroup: {
            configurable: !0, get: function () { return this.Th }, set: function (a) {
                if (this.dc()) {
                    var b = this.Th; if (b !== a) {
                    E && null !== a && w(a, xg, R, "containingGroup"); null === a || this !== a && !a.Xd(this) || (this === a && v("Cannot make a Group a member of itself: " + this.toString()), v("Cannot make a Group indirectly contain itself: " + this.toString() + " already contains " + a.toString())); this.C(2); var c = this.diagram; null !== b ? Jo(b, this) :
                        this instanceof xg && null !== c && c.Ai.remove(this); this.Th = a; null !== a ? Io(a, this) : this instanceof xg && null !== c && c.Ai.add(this); this.C(1); if (null !== c) { var d = this.data, e = c.model; if (null !== d && e.Si()) { var f = e.ra(null !== a ? a.data : null); e.zt(d, f) } } d = this.containingGroupChanged; null !== d && (e = !0, null !== c && (e = c.fa, c.fa = !0), d(this, b, a), null !== c && (c.fa = e)); if (this instanceof xg) for (c = new I, Yk(c, this, !0, 0, !0), c = c.iterator; c.next();)if (d = c.value, d instanceof V) for (d = d.linksConnected; d.next();)Oo(d.value); if (this instanceof
                            V) { for (c = this.linksConnected; c.next();)Oo(c.value); c = this.labeledLink; null !== c && Oo(c) } this.g("containingGroup", b, a); null !== a && (b = a.layer, null !== b && zi(b, -1, a))
                    }
                } else v("cannot set the Part.containingGroup of a Link or Adornment")
            }
        }, containingGroupChanged: { configurable: !0, get: function () { return this.dn }, set: function (a) { var b = this.dn; b !== a && (null !== a && z(a, "function", R, "containingGroupChanged"), this.dn = a, this.g("containingGroupChanged", b, a)) } }, isTopLevel: {
            configurable: !0, get: function () {
                return null !==
                    this.containingGroup || this instanceof V && null !== this.labeledLink ? !1 : !0
            }
        }, layoutConditions: { configurable: !0, get: function () { return this.ho }, set: function (a) { var b = this.ho; b !== a && (E && z(a, "number", R, "layoutConditions"), this.ho = a, this.g("layoutConditions", b, a)) } }, dragComputation: { configurable: !0, get: function () { return this.An }, set: function (a) { var b = this.An; b !== a && (null !== a && z(a, "function", R, "dragComputation"), this.An = a, this.g("dragComputation", b, a)) } }, shadowOffset: {
            configurable: !0,
            enumerable: !0, get: function () { return this.vi }, set: function (a) { var b = this.vi; b.A(a) || (E && w(a, J, R, "shadowOffset"), this.vi = a = a.J(), this.S(), this.g("shadowOffset", b, a)) }
        }, shadowColor: { configurable: !0, get: function () { return this.Mj }, set: function (a) { var b = this.Mj; b !== a && (E && z(a, "string", R, "shadowColor"), this.Mj = a, this.S(), this.g("shadowColor", b, a)) } }, shadowBlur: {
            configurable: !0, get: function () { return this.Qd }, set: function (a) {
                var b = this.Qd; b !== a && (E && z(a, "number", R, "shadowBlur"),
                    this.Qd = a, this.S(), this.g("shadowBlur", b, a))
            }
        }
    }); R.prototype.invalidateLayout = R.prototype.C; R.prototype.findCommonContainingGroup = R.prototype.lx; R.prototype.isMemberOf = R.prototype.Xd; R.prototype.findTopLevelPart = R.prototype.dz; R.prototype.findSubGraphLevel = R.prototype.az; R.prototype.ensureBounds = R.prototype.bc; R.prototype.getDocumentBounds = R.prototype.eq; R.prototype.getRelativePoint = R.prototype.rf; R.prototype.findObject = R.prototype.bb; R.prototype.moveTo = R.prototype.moveTo;
    R.prototype.invalidateAdornments = R.prototype.Mb; R.prototype.clearAdornments = R.prototype.Wj; R.prototype.removeAdornment = R.prototype.wf; R.prototype.addAdornment = R.prototype.qh; R.prototype.findAdornment = R.prototype.dk; R.prototype.updateTargetBindings = R.prototype.Fa; var Go = !1; R.className = "Part"; R.LayoutNone = 0; R.LayoutAdded = 1; R.LayoutRemoved = 2; R.LayoutShown = 4; R.LayoutHidden = 8; R.LayoutNodeSized = 16; R.LayoutGroupLayout = 32; R.LayoutNodeReplaced = 64; R.LayoutStandard = 127; R.LayoutAll = 16777215;
    function Cf(a) { R.call(this, a); this.F &= -257; this.Ug = "Adornment"; this.ce = null; this.Jw = 0; this.Uw = !1; this.l = []; this.Pa = null } ma(Cf, R); Cf.prototype.toString = function () { var a = this.adornedPart; return "Adornment(" + this.category + ")" + (null !== a ? a.toString() : "") }; Cf.prototype.updateRelationshipsFromData = function () { };
    Cf.prototype.kk = function (a) { var b = this.adornedObject.part; if (b instanceof Q && this.adornedObject instanceof Hg) { var c = b.path; b.kk(a); a = c.geometry; b = this.Z.j; c = b.length; for (var d = 0; d < c; d++) { var e = b[d]; e.isPanelMain && e instanceof Hg && (e.sa = a) } } }; Cf.prototype.Ui = function () { var a = this.ce; if (null === a) return !0; a = a.part; return null === a || !Ej(a) }; Cf.prototype.dc = function () { return !1 };
    Cf.prototype.sk = function (a, b, c, d, e, f, g) {
        if (a === qf && "elements" === b) if (e instanceof lh) null === this.Pa ? this.Pa = e : E && this.Pa !== e && v("Cannot insert a second Placeholder into the visual tree of an Adornment."); else { if (e instanceof W) { var h = e.bm(function (a) { return a instanceof lh }); h instanceof lh && (null === this.Pa ? this.Pa = h : E && this.Pa !== h && v("Cannot insert a second Placeholder into the visual tree of an Adornment.")) } } else a === rf && "elements" === b && null !== this.Pa && (d === this.Pa ? this.Pa = null : d instanceof W &&
            this.Pa.tg(d) && (this.Pa = null)); R.prototype.sk.call(this, a, b, c, d, e, f, g)
    }; Cf.prototype.updateAdornments = function () { }; Cf.prototype.bk = function () { };
    na.Object.defineProperties(Cf.prototype, {
        placeholder: { configurable: !0, get: function () { return this.Pa } }, adornedObject: { configurable: !0, get: function () { return this.ce }, set: function (a) { E && null !== a && w(a, N, R, "adornedObject:value"); var b = this.adornedPart, c = null; null !== a && (c = a.part); null === b || null !== a && b === c || b.wf(this.category); this.ce = a; null !== c && c.qh(this.category, this) } }, adornedPart: { configurable: !0, get: function () { var a = this.ce; return null !== a ? a.part : null } }, containingGroup: {
            configurable: !0,
            enumerable: !0, get: function () { return null }
        }
    }); Cf.className = "Adornment"; function V(a) { R.call(this, a); this.T = 13; this.$a = new F; this.Jp = this.ll = this.ki = this.jo = this.io = null; this.Gk = cd; this.tc = this.Ne = null; this.Xo = Po; this.oh = !1 } ma(V, R); V.prototype.cloneProtected = function (a) { R.prototype.cloneProtected.call(this, a); a.T = this.T; a.T = this.T & -17; a.io = this.io; a.jo = this.jo; a.ki = this.ki; a.Jp = this.Jp; a.Gk = this.Gk.J(); a.Xo = this.Xo }; t = V.prototype;
    t.qf = function (a) { R.prototype.qf.call(this, a); a.gd(); a.Ne = this.Ne; a.tc = null }; function Qo(a, b) { null !== b && (null === a.Ne && (a.Ne = new I), a.Ne.add(b)) } function Ro(a, b, c, d) { if (null === b || null === a.Ne) return null; for (var e = a.Ne.iterator; e.next();) { var f = e.value; if (f.ot === a && f.vv === b && f.Cx === c && f.Ex === d || f.ot === b && f.vv === a && f.Cx === d && f.Ex === c) return f } return null } t.Az = function (a, b, c) { if (void 0 === b || null === b) b = ""; if (void 0 === c || null === c) c = ""; a = Ro(this, a, b, c); null !== a && a.gm() };
    t.sk = function (a, b, c, d, e, f, g) { a === qf && "elements" === b ? this.tc = null : a === rf && "elements" === b && (this.tc = null); R.prototype.sk.call(this, a, b, c, d, e, f, g) }; t.gd = function (a) { void 0 === a && (a = null); for (var b = this.linksConnected; b.next();) { var c = b.value; null !== a && a.contains(c) || (So(this, c.fromPort), So(this, c.toPort), c.Ta()) } }; function ul(a, b) { for (var c = a.linksConnected; c.next();) { var d = c.value; if (d.fromPort === b || d.toPort === b) So(a, d.fromPort), So(a, d.toPort), d.Ta() } }
    function So(a, b) { null !== b && (b = b.Wo, null !== b && b.gm(), a = a.containingGroup, null === a || a.isSubGraphExpanded || So(a, a.port)) } t.Ui = function () { return !0 }; V.prototype.getAvoidableRect = function (a) { a.set(this.actualBounds); a.Sp(this.Gk); return a }; V.prototype.findVisibleNode = function () { for (var a = this; null !== a && !a.isVisible();)a = a.containingGroup; return a };
    V.prototype.isVisible = function () {
        if (!R.prototype.isVisible.call(this)) return !1; var a = !0, b = Gi, c = this.diagram; if (null !== c) { if (li(c.animationManager, this)) return !0; a = c.isTreePathToChildren; b = c.treeCollapsePolicy } if (b === Gi) { if (a = this.rg(), null !== a && !a.isTreeExpanded) return !1 } else if (b === Mk) { if (a = a ? this.fv() : this.gv(), 0 < a.count && a.all(function (a) { return !a.isTreeExpanded })) return !1 } else if (b === Nk && (a = a ? this.fv() : this.gv(), 0 < a.count && a.any(function (a) { return !a.isTreeExpanded }))) return !1; a = this.labeledLink;
        return null !== a ? a.isVisible() : !0
    }; t = V.prototype; t.Ob = function (a) { R.prototype.Ob.call(this, a); for (var b = this.linksConnected; b.next();)b.value.Ob(a) }; t.dv = function (a) { void 0 === a && (a = null); if (null === a) return this.$a.iterator; E && z(a, "string", V, "findLinksConnected:pid"); var b = new Gb(this.$a), c = this; b.predicate = function (b) { return b.fromNode === c && b.fromPortId === a || b.toNode === c && b.toPortId === a }; return b };
    t.aq = function (a) { void 0 === a && (a = null); E && null !== a && z(a, "string", V, "findLinksOutOf:pid"); var b = new Gb(this.$a), c = this; b.predicate = function (b) { return b.fromNode !== c ? !1 : null === a ? !0 : b.fromPortId === a }; return b }; t.ud = function (a) { void 0 === a && (a = null); E && null !== a && z(a, "string", V, "findLinksInto:pid"); var b = new Gb(this.$a), c = this; b.predicate = function (b) { return b.toNode !== c ? !1 : null === a ? !0 : b.toPortId === a }; return b };
    t.ev = function (a) { void 0 === a && (a = null); E && null !== a && z(a, "string", V, "findNodesConnected:pid"); for (var b = null, c = null, d = this.$a.iterator; d.next();) { var e = d.value; if (e.fromNode === this) { if (null === a || e.fromPortId === a) e = e.toNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new I, b.add(c), b.add(e)) : c = e } else e.toNode !== this || null !== a && e.toPortId !== a || (e = e.fromNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new I, b.add(c), b.add(e)) : c = e) } return null !== b ? b.iterator : null !== c ? new Db(c) : Cb };
    t.gv = function (a) { void 0 === a && (a = null); E && null !== a && z(a, "string", V, "findNodesOutOf:pid"); for (var b = null, c = null, d = this.$a.iterator; d.next();) { var e = d.value; e.fromNode !== this || null !== a && e.fromPortId !== a || (e = e.toNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new I, b.add(c), b.add(e)) : c = e) } return null !== b ? b.iterator : null !== c ? new Db(c) : Cb };
    t.fv = function (a) { void 0 === a && (a = null); E && null !== a && z(a, "string", V, "findNodesInto:pid"); for (var b = null, c = null, d = this.$a.iterator; d.next();) { var e = d.value; e.toNode !== this || null !== a && e.toPortId !== a || (e = e.fromNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new I, b.add(c), b.add(e)) : c = e) } return null !== b ? b.iterator : null !== c ? new Db(c) : Cb };
    t.Wy = function (a, b, c) { void 0 === b && (b = null); void 0 === c && (c = null); E && (w(a, V, V, "findLinksBetween:othernode"), null !== b && z(b, "string", V, "findLinksBetween:pid"), null !== c && z(c, "string", V, "findLinksBetween:otherpid")); var d = new Gb(this.$a), e = this; d.predicate = function (d) { return (d.fromNode !== e || d.toNode !== a || null !== b && d.fromPortId !== b || null !== c && d.toPortId !== c) && (d.fromNode !== a || d.toNode !== e || null !== c && d.fromPortId !== c || null !== b && d.toPortId !== b) ? !1 : !0 }; return d };
    t.Xy = function (a, b, c) { void 0 === b && (b = null); void 0 === c && (c = null); E && (w(a, V, V, "findLinksTo:othernode"), null !== b && z(b, "string", V, "findLinksTo:pid"), null !== c && z(c, "string", V, "findLinksTo:otherpid")); var d = new Gb(this.$a), e = this; d.predicate = function (d) { return d.fromNode !== e || d.toNode !== a || null !== b && d.fromPortId !== b || null !== c && d.toPortId !== c ? !1 : !0 }; return d };
    function To(a, b, c) { So(a, c); var d = a.$a.contains(b); d || a.$a.add(b); if (!d || b.fromNode === b.toNode) { var e = a.linkConnected; if (null !== e) { var f = !0, g = a.diagram; null !== g && (f = g.fa, g.fa = !0); e(a, b, c); null !== g && (g.fa = f) } } !d && b.isTreeLink && (c = b.fromNode, b = b.toNode, null !== c && null !== b && c !== b && (d = !0, a = a.diagram, null !== a && (d = a.isTreePathToChildren), e = d ? b : c, f = d ? c : b, e.oh || (e.oh = f), !f.isTreeLeaf || null !== a && a.undoManager.isUndoingRedoing || (d ? c === f && (f.isTreeLeaf = !1) : b === f && (f.isTreeLeaf = !1)))) }
    function Uo(a, b, c) { So(a, c); var d = a.$a.remove(b), e = null; if (d || b.toNode === b.fromNode) { var f = a.linkDisconnected; e = a.diagram; if (null !== f) { var g = !0; null !== e && (g = e.fa, e.fa = !0); f(a, b, c); null !== e && (e.fa = g) } } d && b.isTreeLink && (c = !0, null !== e && (c = e.isTreePathToChildren), a = c ? b.toNode : b.fromNode, b = c ? b.fromNode : b.toNode, null !== a && (a.oh = !1), null === b || b.isTreeLeaf || (0 === b.$a.count ? (b.oh = null, null !== e && e.undoManager.isUndoingRedoing || (b.isTreeLeaf = !0)) : Lk(b))) }
    function Lk(a) { a.oh = !1; if (0 !== a.$a.count) { var b = !0, c = a.diagram; if (null === c || !c.undoManager.isUndoingRedoing) { null !== c && (b = c.isTreePathToChildren); for (c = a.$a.iterator; c.next();) { var d = c.value; if (d.isTreeLink) if (b) { if (d.fromNode === a) { a.isTreeLeaf = !1; return } } else if (d.toNode === a) { a.isTreeLeaf = !1; return } } a.isTreeLeaf = !0 } } } V.prototype.updateRelationshipsFromData = function () { var a = this.diagram; null !== a && a.partManager.updateRelationshipsFromData(this) }; t = V.prototype;
    t.hq = function (a) { R.prototype.hq.call(this, a); a || (Lk(this), a = this.ll, null !== a && Vo(a, this)) }; t.iq = function (a) { R.prototype.iq.call(this, a); a || (a = this.ll, null !== a && null !== a.bd && (a.bd.remove(this), a.v())) };
    t.bk = function () { if (0 < this.$a.count) { var a = this.diagram; if (null !== a) for (var b = null !== a.commandHandler ? a.commandHandler.deletesConnectedLinks : !0, c = this.$a.copy().iterator; c.next();) { var d = c.value; b ? a.remove(d) : (d.fromNode === this && (d.fromNode = null), d.toNode === this && (d.toNode = null)) } } this.labeledLink = null; R.prototype.bk.call(this) };
    t.Ys = function (a) { E && z(a, "string", V, "findPort:pid"); if (null === this.tc) { if ("" === a && !1 === this.yh) return this; Wo(this) } var b = this.tc.K(a); return null !== b || "" !== a && (b = this.tc.K(""), null !== b) ? b : this }; function Wo(a) { null === a.tc ? a.tc = new Ub : a.tc.clear(); a.wk(a, function (a, c) { Yl(a, c) }); 0 === a.tc.count && a.tc.add("", a) } function Yl(a, b) { var c = b.portId; null !== c && null !== a.tc && a.tc.add(c, b) }
    function Xl(a, b, c) { var d = b.portId; if (null !== d && (null !== a.tc && a.tc.remove(d), b = a.diagram, null !== b && c)) { c = null; for (a = a.dv(d); a.next();)d = a.value, null === c && (c = Qa()), c.push(d); if (null !== c) { for (a = 0; a < c.length; a++)b.remove(c[a]); Ta(c) } } }
    t.Cz = function (a) { if (null === a || a === this) return !1; var b = !0, c = this.diagram; null !== c && (b = c.isTreePathToChildren); c = this; if (b) for (; c !== a;) { b = null; for (var d = c.$a.iterator; d.next();) { var e = d.value; if (e.isTreeLink && (b = e.fromNode, b !== c && b !== this)) break } if (b === this || null === b || b === c) return !1; c = b } else for (; c !== a;) { b = null; for (d = c.$a.iterator; d.next() && (e = d.value, !e.isTreeLink || (b = e.toNode, b === c || b === this));); if (b === this || null === b || b === c) return !1; c = b } return !0 };
    t.hz = function () { var a = !0, b = this.diagram; null !== b && (a = b.isTreePathToChildren); b = this; if (a) for (; ;) { a = null; for (var c = b.$a.iterator; c.next();) { var d = c.value; if (d.isTreeLink && (a = d.fromNode, a !== b && a !== this)) break } if (a === this) return this; if (null === a || a === b) return b; b = a } else for (; ;) { a = null; for (c = b.$a.iterator; c.next() && (d = c.value, !d.isTreeLink || (a = d.toNode, a === b || a === this));); if (a === this) return this; if (null === a || a === b) return b; b = a } };
    t.Ty = function (a) { if (null === a) return null; E && w(a, V, V, "findCommonTreeParent:other"); if (this === a) return this; for (var b = this; null !== b;)Ho(b, !0), b = b.rg(); var c = null; for (b = a; null !== b;) { if (0 !== (b.F & 1048576)) { c = b; break } b = b.rg() } for (b = this; null !== b;)Ho(b, !1), b = b.rg(); return c };
    t.Li = function () { var a = !0, b = this.diagram; null !== b && (a = b.isTreePathToChildren); b = this.$a.iterator; if (a) for (; b.next();) { if (a = b.value, a.isTreeLink && a.fromNode !== this) return a } else for (; b.next();)if (a = b.value, a.isTreeLink && a.toNode !== this) return a; return null };
    t.rg = function () { var a = this.oh; if (null === a) return null; if (a instanceof V) return a; var b = !0; a = this.diagram; null !== a && (b = a.isTreePathToChildren); a = this.$a.iterator; if (b) for (; a.next();) { if (b = a.value, b.isTreeLink && (b = b.fromNode, b !== this)) return this.oh = b } else for (; a.next();)if (b = a.value, b.isTreeLink && (b = b.toNode, b !== this)) return this.oh = b; return this.oh = null }; t.fz = function () { function a(b, d) { if (null !== b) { d.add(b); var c = b.Li(); null !== c && (d.add(c), a(b.rg(), d)) } } var b = new I; a(this, b); return b };
    t.ez = function () { return Xo(this, this) }; function Xo(a, b) { b = b.rg(); return null === b ? 0 : 1 + Xo(a, b) } t.cq = function () { var a = !0, b = this.diagram; null !== b && (a = b.isTreePathToChildren); b = new Gb(this.$a); var c = this; b.predicate = a ? function (a) { return a.isTreeLink && a.fromNode === c ? !0 : !1 } : function (a) { return a.isTreeLink && a.toNode === c ? !0 : !1 }; return b };
    t.hv = function () { var a = !0, b = this.diagram; null !== b && (a = b.isTreePathToChildren); var c = b = null, d = this.$a.iterator; if (a) for (; d.next();)a = d.value, a.isTreeLink && a.fromNode === this && (a = a.toNode, null !== b ? b.add(a) : null !== c && c !== a ? (b = new F, b.add(c), b.add(a)) : c = a); else for (; d.next();)a = d.value, a.isTreeLink && a.toNode === this && (a = a.fromNode, null !== b ? b.add(a) : null !== c && c !== a ? (b = new F, b.add(c), b.add(a)) : c = a); return null !== b ? b.iterator : null !== c ? new Db(c) : Cb };
    t.gz = function (a) { void 0 === a && (a = Infinity); z(a, "number", V, "findTreeParts:level"); var b = new I; Yk(b, this, !1, a, !0); return b }; V.prototype.collapseTree = function (a) { void 0 === a && (a = 1); B(a, V, "collapseTree:level"); 1 > a && (a = 1); var b = this.diagram; if (null !== b && !b.He) { b.He = !0; var c = new I; c.add(this); Yo(this, c, b.isTreePathToChildren, a, b, this, b.treeCollapsePolicy === Gi); b.He = !1 } };
    function Yo(a, b, c, d, e, f, g) { if (1 < d) for (var h = c ? a.aq() : a.ud(); h.next();) { var k = h.value; k.isTreeLink && (k = k.bt(a), null === k || k === a || b.contains(k) || (b.add(k), Yo(k, b, c, d - 1, e, f, g))) } else Zo(a, b, c, e, f, g) }
    function Zo(a, b, c, d, e, f) { for (var g = e === a ? !0 : a.isTreeExpanded, h = c ? a.aq() : a.ud(); h.next();) { var k = h.value; if (k.isTreeLink && (k = k.bt(a), null !== k && k !== a)) { var l = b.contains(k); l || b.add(k); g && (f && d.Qp(k, e), k.zh(), k.Ob(!1)); k.isTreeExpanded && (k.wasTreeExpanded = k.isTreeExpanded, l || Zo(k, b, c, d, e, f)) } } a.isTreeExpanded = !1 }
    V.prototype.expandTree = function (a) { void 0 === a && (a = 2); B(a, V, "expandTree:level"); 2 > a && (a = 2); var b = this.diagram; if (null !== b && !b.He) { b.He = !0; var c = new I; c.add(this); $o(this, c, b.isTreePathToChildren, a, b, this, b.treeCollapsePolicy === Gi); b.He = !1 } };
    function $o(a, b, c, d, e, f, g) { for (var h = f === a ? !1 : a.isTreeExpanded, k = c ? a.aq() : a.ud(); k.next();) { var l = k.value; l.isTreeLink && (h || l.Mc || l.Ta(), l = l.bt(a), null !== l && l !== a && !b.contains(l) && (b.add(l), h || (l.Ob(!0), l.zh(), g && e.Rp(l, f)), 2 < d || l.wasTreeExpanded)) && (l.wasTreeExpanded = !1, $o(l, b, c, d - 1, e, f, g)) } a.isTreeExpanded = !0 }
    na.Object.defineProperties(V.prototype, {
        portSpreading: { configurable: !0, get: function () { return this.Xo }, set: function (a) { var b = this.Xo; b !== a && (E && tb(a, V, V, "portSpreading"), this.Xo = a, this.g("portSpreading", b, a), a = this.diagram, null !== a && a.undoManager.isUndoingRedoing || this.gd()) } }, avoidable: {
            configurable: !0, get: function () { return 0 !== (this.T & 8) }, set: function (a) {
                var b = 0 !== (this.T & 8); if (b !== a) {
                    E && z(a, "boolean", V, "avoidable"); this.T ^= 8; var c = this.diagram; null !== c && Ek(c, this); this.g("avoidable",
                        b, a)
                }
            }
        }, avoidableMargin: { configurable: !0, get: function () { return this.Gk }, set: function (a) { "number" === typeof a ? a = new Hc(a) : w(a, Hc, V, "avoidableMargin"); var b = this.Gk; if (!b.A(a)) { this.Gk = a = a.J(); var c = this.diagram; null !== c && Ek(c, this); this.g("avoidableMargin", b, a) } } }, linksConnected: { configurable: !0, get: function () { return this.$a.iterator } }, linkConnected: {
            configurable: !0, get: function () { return this.io }, set: function (a) {
                var b = this.io; b !== a && (null !== a && z(a, "function",
                    V, "linkConnected"), this.io = a, this.g("linkConnected", b, a))
            }
        }, linkDisconnected: { configurable: !0, get: function () { return this.jo }, set: function (a) { var b = this.jo; b !== a && (null !== a && z(a, "function", V, "linkDisconnected"), this.jo = a, this.g("linkDisconnected", b, a)) } }, linkValidation: { configurable: !0, get: function () { return this.ki }, set: function (a) { var b = this.ki; b !== a && (null !== a && z(a, "function", V, "linkValidation"), this.ki = a, this.g("linkValidation", b, a)) } }, isLinkLabel: {
            configurable: !0,
            get: function () { return null !== this.ll }
        }, labeledLink: {
            configurable: !0, get: function () { return this.ll }, set: function (a) {
                var b = this.ll; if (b !== a) {
                E && null !== a && w(a, Q, V, "labeledLink"); var c = this.diagram, d = this.data; if (null !== b) { null !== b.bd && (b.bd.remove(this), b.v()); if (null !== c && null !== d && !c.undoManager.isUndoingRedoing) { var e = b.data, f = c.model; if (null !== e && f.im()) { var g = f.ra(d); void 0 !== g && f.Fx(e, g) } } this.containingGroup = null } this.ll = a; null !== a && (Vo(a, this), null === c || null === d || c.undoManager.isUndoingRedoing ||
                    (e = a.data, c = c.model, null !== e && c.im() && (d = c.ra(d), void 0 !== d && c.Lu(e, d))), this.containingGroup = a.containingGroup); Il(this); this.g("labeledLink", b, a)
                }
            }
        }, port: { configurable: !0, get: function () { return this.Ys("") } }, ports: { configurable: !0, get: function () { null === this.tc && Wo(this); return this.tc.iteratorValues } }, isTreeExpanded: {
            configurable: !0, get: function () { return 0 !== (this.T & 1) }, set: function (a) {
                var b = 0 !== (this.T & 1); if (b !== a) {
                    E && z(a, "boolean", V, "isTreeExpanded"); this.T ^=
                        1; var c = this.diagram; this.g("isTreeExpanded", b, a); b = this.treeExpandedChanged; if (null !== b) { var d = !0; null !== c && (d = c.fa, c.fa = !0); b(this); null !== c && (c.fa = d) } null !== c && c.undoManager.isUndoingRedoing ? this.Ob(a) : a ? this.expandTree() : this.collapseTree()
                }
            }
        }, wasTreeExpanded: { configurable: !0, get: function () { return 0 !== (this.T & 2) }, set: function (a) { var b = 0 !== (this.T & 2); b !== a && (E && z(a, "boolean", V, "wasTreeExpanded"), this.T ^= 2, this.g("wasTreeExpanded", b, a)) } }, treeExpandedChanged: {
            configurable: !0,
            get: function () { return this.Jp }, set: function (a) { var b = this.Jp; b !== a && (null !== a && z(a, "function", V, "treeExpandedChanged"), this.Jp = a, this.g("treeExpandedChanged", b, a)) }
        }, isTreeLeaf: { configurable: !0, get: function () { return 0 !== (this.T & 4) }, set: function (a) { var b = 0 !== (this.T & 4); b !== a && (E && z(a, "boolean", V, "isTreeLeaf"), this.T ^= 4, this.g("isTreeLeaf", b, a)) } }
    }); V.prototype.expandTree = V.prototype.expandTree; V.prototype.collapseTree = V.prototype.collapseTree; V.prototype.findTreeParts = V.prototype.gz;
    V.prototype.findTreeChildrenNodes = V.prototype.hv; V.prototype.findTreeChildrenLinks = V.prototype.cq; V.prototype.findTreeLevel = V.prototype.ez; V.prototype.findTreeParentChain = V.prototype.fz; V.prototype.findTreeParentNode = V.prototype.rg; V.prototype.findTreeParentLink = V.prototype.Li; V.prototype.findCommonTreeParent = V.prototype.Ty; V.prototype.findTreeRoot = V.prototype.hz; V.prototype.isInTreeOf = V.prototype.Cz; V.prototype.findPort = V.prototype.Ys; V.prototype.findLinksTo = V.prototype.Xy;
    V.prototype.findLinksBetween = V.prototype.Wy; V.prototype.findNodesInto = V.prototype.fv; V.prototype.findNodesOutOf = V.prototype.gv; V.prototype.findNodesConnected = V.prototype.ev; V.prototype.findLinksInto = V.prototype.ud; V.prototype.findLinksOutOf = V.prototype.aq; V.prototype.findLinksConnected = V.prototype.dv; V.prototype.invalidateConnectedLinks = V.prototype.gd; V.prototype.invalidateLinkBundle = V.prototype.Az; var ap = new D(V, "SpreadingNone", 10), Po = new D(V, "SpreadingEvenly", 11), bp = new D(V, "SpreadingPacked", 12);
    V.className = "Node"; V.SpreadingNone = ap; V.SpreadingEvenly = Po; V.SpreadingPacked = bp; function xg(a) { V.call(this, a); this.T |= 4608; this.so = new I; this.vl = new I; this.Pa = this.Bp = this.li = this.to = this.ro = null; this.ic = new Ni; this.ic.group = this } ma(xg, V);
    xg.prototype.cloneProtected = function (a) { V.prototype.cloneProtected.call(this, a); this.T = this.T & -32769; a.ro = this.ro; a.to = this.to; a.li = this.li; a.Bp = this.Bp; var b = a.bm(function (a) { return a instanceof lh }); b instanceof lh ? a.Pa = b : a.Pa = null; null !== this.ic ? (a.ic = this.ic.copy(), a.ic.group = a) : (null !== a.ic && (a.ic.group = null), a.ic = null) }; t = xg.prototype;
    t.qf = function (a) { V.prototype.qf.call(this, a); var b = a.ek(); for (a = a.memberParts; a.next();) { var c = a.value; c.v(); c.C(8); c.Wj(); if (c instanceof V) c.gd(b); else if (c instanceof Q) for (c = c.labelNodes; c.next();)c.value.gd(b) } };
    t.sk = function (a, b, c, d, e, f, g) {
        if (a === qf && "elements" === b) if (e instanceof lh) null === this.Pa ? this.Pa = e : this.Pa !== e && v("Cannot insert a second Placeholder into the visual tree of a Group."); else { if (e instanceof W) { var h = e.bm(function (a) { return a instanceof lh }); h instanceof lh && (null === this.Pa ? this.Pa = h : this.Pa !== h && v("Cannot insert a second Placeholder into the visual tree of a Group.")) } } else a === rf && "elements" === b && null !== this.Pa && (d === this.Pa ? this.Pa = null : d instanceof W && this.Pa.tg(d) && (this.Pa = null));
        V.prototype.sk.call(this, a, b, c, d, e, f, g)
    }; t.uh = function (a, b, c, d) { this.Ye = this.Pa; V.prototype.uh.call(this, a, b, c, d) }; t.Ui = function () { if (!V.prototype.Ui.call(this)) return !1; for (var a = this.memberParts; a.next();) { var b = a.value; if (b instanceof V) { if (b.isVisible() && Ej(b)) return !1 } else if (b instanceof Q && b.isVisible() && Ej(b) && b.fromNode !== this && b.toNode !== this) return !1 } return !0 };
    function Io(a, b) { if (a.so.add(b)) { b instanceof xg && a.vl.add(b); var c = a.memberAdded; if (null !== c) { var d = !0, e = a.diagram; null !== e && (d = e.fa, e.fa = !0); c(a, b); null !== e && (e.fa = d) } a.isVisible() && a.isSubGraphExpanded || b.Ob(!1) } b instanceof Q && !a.computesBoundsIncludingLinks || (b = a.Pa, null === b && (b = a), b.v()) }
    function Jo(a, b) { if (a.so.remove(b)) { b instanceof xg && a.vl.remove(b); var c = a.memberRemoved; if (null !== c) { var d = !0, e = a.diagram; null !== e && (d = e.fa, e.fa = !0); c(a, b); null !== e && (e.fa = d) } a.isVisible() && a.isSubGraphExpanded || b.Ob(!0) } b instanceof Q && !a.computesBoundsIncludingLinks || (b = a.Pa, null === b && (b = a), b.v()) } t.bk = function () { if (0 < this.so.count) { var a = this.diagram; if (null !== a) for (var b = this.so.copy().iterator; b.next();)a.remove(b.value) } V.prototype.bk.call(this) };
    xg.prototype.canAddMembers = function (a) { var b = this.diagram; if (null === b) return !1; b = b.commandHandler; for (a = $k(a).iterator; a.next();)if (!b.isValidMember(this, a.value)) return !1; return !0 }; xg.prototype.addMembers = function (a, b) { var c = this.diagram; if (null === c) return !1; c = c.commandHandler; var d = !0; for (a = $k(a).iterator; a.next();) { var e = a.value; !b || c.isValidMember(this, e) ? e.containingGroup = this : d = !1 } return d };
    xg.prototype.canUngroup = function () { if (!this.ungroupable) return !1; var a = this.layer; if (null !== a && !a.allowUngroup) return !1; a = a.diagram; return null === a || a.allowUngroup ? !0 : !1 }; t = xg.prototype;
    t.gd = function (a) { void 0 === a && (a = null); var b = 0 !== (this.T & 65536); V.prototype.gd.call(this, a); if (!b) for (0 !== (this.T & 65536) !== !0 && (this.T = this.T ^ 65536), b = this.cv(); b.next();) { var c = b.value; if (null === a || !a.contains(c)) { var d = c.fromNode; null !== d && d !== this && d.Xd(this) && !d.isVisible() ? (So(d, c.fromPort), So(d, c.toPort), c.Ta()) : (d = c.toNode, null !== d && d !== this && d.Xd(this) && !d.isVisible() && (So(d, c.fromPort), So(d, c.toPort), c.Ta())) } } };
    t.cv = function () { var a = this.ek(); a.add(this); for (var b = new I, c = a.iterator; c.next();) { var d = c.value; if (d instanceof V) for (d = d.linksConnected; d.next();) { var e = d.value; a.contains(e) || b.add(e) } } return b.iterator }; t.Vy = function () { var a = this.ek(); a.add(this); for (var b = new I, c = a.iterator; c.next();) { var d = c.value; if (d instanceof V) for (d = d.linksConnected; d.next();) { var e = d.value, f = e.fromNode; a.contains(f) && f !== this || b.add(f); e = e.toNode; a.contains(e) && e !== this || b.add(e) } } return b.iterator };
    t.Uy = function () { function a(b, d) { null !== b && (d.add(b), a(b.containingGroup, d)) } var b = new I; a(this, b); return b }; t.ek = function () { var a = new I; Yk(a, this, !0, 0, !0); a.remove(this); return a }; t.Ob = function (a) { V.prototype.Ob.call(this, a); for (var b = this.memberParts; b.next();)b.value.Ob(a) }; xg.prototype.collapseSubGraph = function () { var a = this.diagram; if (null !== a && !a.He) { a.He = !0; var b = this.ek(); cp(this, b, a, this); a.He = !1 } };
    function cp(a, b, c, d) { for (var e = a.memberParts; e.next();) { var f = e.value; f.Ob(!1); f instanceof xg && f.isSubGraphExpanded && (f.wasSubGraphExpanded = f.isSubGraphExpanded, cp(f, b, c, d)); if (f instanceof V) f.gd(b), c.Qp(f, d); else if (f instanceof Q) for (f = f.labelNodes; f.next();)f.value.gd(b) } a.isSubGraphExpanded = !1 } xg.prototype.expandSubGraph = function () { var a = this.diagram; if (null !== a && !a.He) { a.He = !0; var b = this.ek(); dp(this, b, a, this); a.He = !1 } };
    function dp(a, b, c, d) { for (var e = a.memberParts; e.next();) { var f = e.value; f.Ob(!0); f instanceof xg && f.wasSubGraphExpanded && (f.wasSubGraphExpanded = !1, dp(f, b, c, d)); if (f instanceof V) f.gd(b), c.Rp(f, d); else if (f instanceof Q) for (f = f.labelNodes; f.next();)f.value.gd(b) } a.isSubGraphExpanded = !0 }
    xg.prototype.move = function (a, b) {
    void 0 === b && (b = !1); var c = b ? this.location : this.position, d = c.x; isNaN(d) && (d = 0); c = c.y; isNaN(c) && (c = 0); d = a.x - d; c = a.y - c; var e = J.allocAt(d, c); V.prototype.move.call(this, a, b); a = new I; for (b = this.ek().iterator; b.next();) { var f = b.value; f instanceof Q && (f.suspendsRouting && a.add(f), f.Mc || f.fromNode !== this && f.toNode !== this) && (f.suspendsRouting = !0) } for (b.reset(); b.next();)if (f = b.value, !(f.Ah() || f instanceof V && f.isLinkLabel)) {
        var g = f.position, h = f.location; g.o() ? (e.x = g.x + d, e.y = g.y +
            c, f.position = e) : h.o() && (e.x = h.x + d, e.y = h.y + c, f.location = e)
    } for (b.reset(); b.next();)if (f = b.value, f instanceof Q && (f.suspendsRouting = a.contains(f), f.Mc || f.fromNode !== this && f.toNode !== this)) g = f.position, e.x = g.x + d, e.y = g.y + c, e.o() ? f.move(e) : f.Ta(), ck(f) && f.Ta(); J.free(e)
    };
    na.Object.defineProperties(xg.prototype, {
        placeholder: { configurable: !0, get: function () { return this.Pa } }, computesBoundsAfterDrag: { configurable: !0, get: function () { return 0 !== (this.T & 2048) }, set: function (a) { var b = 0 !== (this.T & 2048); b !== a && (z(a, "boolean", xg, "computesBoundsAfterDrag"), this.T ^= 2048, this.g("computesBoundsAfterDrag", b, a)) } }, computesBoundsIncludingLinks: {
            configurable: !0, get: function () { return 0 !== (this.T & 4096) }, set: function (a) {
                z(a, "boolean", xg, "computesBoundsIncludingLinks");
                var b = 0 !== (this.T & 4096); b !== a && (this.T ^= 4096, this.g("computesBoundsIncludingLinks", b, a))
            }
        }, computesBoundsIncludingLocation: { configurable: !0, get: function () { return 0 !== (this.T & 8192) }, set: function (a) { z(a, "boolean", xg, "computesBoundsIncludingLocation"); var b = 0 !== (this.T & 8192); b !== a && (this.T ^= 8192, this.g("computesBoundsIncludingLocation", b, a)) } }, handlesDragDropForMembers: {
            configurable: !0, get: function () { return 0 !== (this.T & 16384) }, set: function (a) {
                z(a, "boolean", xg, "handlesDragDropForMembers");
                var b = 0 !== (this.T & 16384); b !== a && (this.T ^= 16384, this.g("handlesDragDropForMembers", b, a))
            }
        }, memberParts: { configurable: !0, get: function () { return this.so.iterator } }, layout: { configurable: !0, get: function () { return this.ic }, set: function (a) { var b = this.ic; if (b !== a) { null !== a && w(a, Ni, xg, "layout"); null !== b && (b.diagram = null, b.group = null); this.ic = a; var c = this.diagram; null !== a && (a.diagram = c, a.group = this); null !== c && (c.Cg = !0); this.g("layout", b, a); null !== c && c.ec() } } }, memberAdded: {
            configurable: !0,
            enumerable: !0, get: function () { return this.ro }, set: function (a) { var b = this.ro; b !== a && (null !== a && z(a, "function", xg, "memberAdded"), this.ro = a, this.g("memberAdded", b, a)) }
        }, memberRemoved: { configurable: !0, get: function () { return this.to }, set: function (a) { var b = this.to; b !== a && (null !== a && z(a, "function", xg, "memberRemoved"), this.to = a, this.g("memberRemoved", b, a)) } }, memberValidation: {
            configurable: !0, get: function () { return this.li }, set: function (a) {
                var b = this.li; b !== a && (null !== a && z(a, "function",
                    xg, "memberValidation"), this.li = a, this.g("memberValidation", b, a))
            }
        }, ungroupable: { configurable: !0, get: function () { return 0 !== (this.T & 256) }, set: function (a) { var b = 0 !== (this.T & 256); b !== a && (z(a, "boolean", xg, "ungroupable"), this.T ^= 256, this.g("ungroupable", b, a)) } }, isSubGraphExpanded: {
            configurable: !0, get: function () { return 0 !== (this.T & 512) }, set: function (a) {
                var b = 0 !== (this.T & 512); if (b !== a) {
                    z(a, "boolean", xg, "isSubGraphExpanded"); this.T ^= 512; var c = this.diagram; this.g("isSubGraphExpanded",
                        b, a); b = this.subGraphExpandedChanged; if (null !== b) { var d = !0; null !== c && (d = c.fa, c.fa = !0); b(this); null !== c && (c.fa = d) } null !== c && c.undoManager.isUndoingRedoing ? (null !== this.Pa && this.Pa.v(), this.memberParts.each(function (a) { a.updateAdornments() })) : a ? this.expandSubGraph() : this.collapseSubGraph()
                }
            }
        }, wasSubGraphExpanded: {
            configurable: !0, get: function () { return 0 !== (this.T & 1024) }, set: function (a) {
                var b = 0 !== (this.T & 1024); b !== a && (z(a, "boolean", xg, "wasSubGraphExpanded"), this.T ^= 1024, this.g("wasSubGraphExpanded",
                    b, a))
            }
        }, subGraphExpandedChanged: { configurable: !0, get: function () { return this.Bp }, set: function (a) { var b = this.Bp; b !== a && (null !== a && z(a, "function", xg, "subGraphExpandedChanged"), this.Bp = a, this.g("subGraphExpandedChanged", b, a)) } }, rk: { configurable: !0, get: function () { return 0 !== (this.T & 32768) }, set: function (a) { 0 !== (this.T & 32768) !== a && (this.T ^= 32768) } }
    }); xg.prototype.expandSubGraph = xg.prototype.expandSubGraph; xg.prototype.collapseSubGraph = xg.prototype.collapseSubGraph;
    xg.prototype.findSubGraphParts = xg.prototype.ek; xg.prototype.findContainingGroupChain = xg.prototype.Uy; xg.prototype.findExternalNodesConnected = xg.prototype.Vy; xg.prototype.findExternalLinksConnected = xg.prototype.cv; xg.className = "Group"; function lh() { N.call(this); this.gb = Zc; this.lp = new L(NaN, NaN, NaN, NaN) } ma(lh, N); lh.prototype.cloneProtected = function (a) { N.prototype.cloneProtected.call(this, a); a.gb = this.gb.J(); a.lp = this.lp.copy() };
    lh.prototype.wh = function (a) { if (null === this.background && null === this.areaBackground) return !1; var b = this.naturalBounds; return Qc(0, 0, b.width, b.height, a.x, a.y) };
    lh.prototype.lm = function () {
        var a = this.part; null !== a && (a instanceof xg || a instanceof Cf) || v("Placeholder is not inside a Group or Adornment."); if (a instanceof xg) {
            var b = this.computeBorder(this.lp), c = this.minSize, d = this.rc; Cc(d, (isFinite(c.width) ? Math.max(c.width, b.width) : b.width) || 0, (isFinite(c.height) ? Math.max(c.height, b.height) : b.height) || 0); nl(this, 0, 0, d.width, d.height); c = a.memberParts; for (d = !1; c.next();)if (c.value.isVisible()) { d = !0; break } c = a.diagram; (d = !d || null === c) || (d = c.animationManager, d.Nf ?
                (d = d.Bj.K(a), d = null !== d && (d.start.position || d.start.location)) : d = !1); d || isNaN(b.x) || isNaN(b.y) ? null !== c && c.animationManager.isAnimating && c.animationManager.hs.add(this) : (c = J.alloc(), c.Xi(b, a.locationSpot), c.A(a.location) || (a.location = new J(c.x, c.y)), J.free(c))
        } else {
            b = this.rc; c = this.gb; d = c.left + c.right; var e = c.top + c.bottom, f = a.adornedObject; a.angle = f.Ni(); var g = 0; f instanceof Hg && (g = f.strokeWidth); var h = f.Fe(), k = f.naturalBounds, l = (k.width + g) * h; g = (k.height + g) * h; a.type !== W.Link && (f = f.oa("Selection" ===
                a.category ? fd : a.locationSpot, J.alloc()), a.location = f, J.free(f)); isNaN(l) || isNaN(g) ? (a = a.adornedObject, l = a.oa(fd, J.alloc()), f = L.allocAt(l.x, l.y, 0, 0), f.Le(a.oa(ud, l)), f.Le(a.oa(hd, l)), f.Le(a.oa(sd, l)), Cc(b, f.width + d || 0, f.height + e || 0), nl(this, -c.left, -c.top, b.width, b.height), J.free(l), L.free(f)) : (Cc(b, l + d || 0, g + e || 0), nl(this, -c.left, -c.top, b.width, b.height))
        }
    }; lh.prototype.uh = function (a, b, c, d) { this.actualBounds.h(a, b, c, d) };
    lh.prototype.computeBorder = function (a) {
        var b = this.part, c = b.diagram; if (null !== c && b instanceof xg && !b.layer.isTemporary && b.computesBoundsAfterDrag && this.lp.o()) { var d = c.toolManager.findTool("Dragging"); if (d === c.currentTool && (c = d.computeBorder(b, this.lp, a), null !== c)) return c } c = L.alloc(); d = this.computeMemberBounds(c); var e = this.gb; b instanceof xg && !b.isSubGraphExpanded ? a.h(d.x - e.left, d.y - e.top, 0, 0) : a.h(d.x - e.left, d.y - e.top, Math.max(d.width + e.left + e.right, 0), Math.max(d.height + e.top + e.bottom, 0)); L.free(c);
        b instanceof xg && b.computesBoundsIncludingLocation && b.location.o() && a.Le(b.location); return a
    };
    lh.prototype.computeMemberBounds = function (a) {
        if (!(this.part instanceof xg)) return a.h(0, 0, 0, 0), a; for (var b = this.part, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = b.memberParts; g.next();) { var h = g.value; if (h.isVisible()) { if (h instanceof Q) { if (!b.computesBoundsIncludingLinks) continue; if (Dj(h)) continue; if (h.fromNode === b || h.toNode === b) continue } h = h.actualBounds; h.left < c && (c = h.left); h.top < d && (d = h.top); h.right > e && (e = h.right); h.bottom > f && (f = h.bottom) } } isFinite(c) && isFinite(d) ? a.h(c, d, e - c, f - d) : (b = b.location,
            a.h(b.x, b.y, 0, 0)); return a
    }; na.Object.defineProperties(lh.prototype, { padding: { configurable: !0, get: function () { return this.gb }, set: function (a) { "number" === typeof a ? a = new Hc(a) : w(a, Hc, lh, "padding"); var b = this.gb; b.A(a) || (this.gb = a = a.J(), this.g("padding", b, a)) } } }); lh.className = "Placeholder";
    function Q() { R.call(this, W.Link); this.Va = 8; this.Qe = null; this.Re = ""; this.hf = this.Jn = null; this.jf = ""; this.Ip = null; this.Pm = ch; this.ln = 0; this.on = ch; this.pn = NaN; this.Ij = ep; this.xp = .5; this.bd = null; this.yb = (new F).freeze(); this.bh = this.Hc = null; this.Bl = new L; this.sa = new me; this.Un = !0; this.L = this.w = this.Af = this.Jf = null; this.l = []; this.Eu = new J; this.wr = this.Qw = this.Pw = null; this.fu = NaN; this.R = null } ma(Q, R);
    Q.prototype.cloneProtected = function (a) { R.prototype.cloneProtected.call(this, a); a.Va = this.Va & -113; a.Re = this.Re; a.Jn = this.Jn; a.jf = this.jf; a.Ip = this.Ip; a.Pm = this.Pm; a.ln = this.ln; a.on = this.on; a.pn = this.pn; a.Ij = this.Ij; a.xp = this.xp; null !== this.R && (a.R = this.R.copy()) }; t = Q.prototype; t.qf = function (a) { R.prototype.qf.call(this, a); this.Re = a.Re; this.jf = a.jf; a.Hc = null; a.Ta(); a.Af = this.Af; var b = a.fromPort; null !== b && So(a.fromNode, b); b = a.toPort; null !== b && So(a.toNode, b) };
    t.hb = function (a) { a.classType === Q ? 2 === (a.value & 2) ? this.routing = a : a === fh || a === bh || a === ah ? this.curve = a : a === fp || a === gp || a === hp ? this.adjusting = a : a !== ep && a !== ch && v("Unknown Link enum value for a Link property: " + a) : R.prototype.hb.call(this, a) }; t.Jc = function () { null === this.R && (this.R = new jl) }; t.Ui = function () { var a = this.fromNode; if (null !== a) { var b = a.findVisibleNode(); null !== b && (a = b); if (Ej(a) || Fj(a)) return !1 } a = this.toNode; return null !== a && (b = a.findVisibleNode(), null !== b && (a = b), Ej(a) || Fj(a)) ? !1 : !0 }; t.Rv = function () { return !1 };
    t.Sv = function () { }; t.dc = function () { return !1 }; Q.prototype.computeAngle = function (a, b, c) { return Q.computeAngle(b, c) }; Q.computeAngle = function (a, b) { switch (a) { default: case ch: a = 0; break; case Ln: a = b; break; case Um: a = b + 90; break; case Wm: a = b - 90; break; case ip: a = b + 180; break; case jp: a = K.qq(b); 90 < a && 270 > a && (a -= 180); break; case Vm: a = K.qq(b + 90); 90 < a && 270 > a && (a -= 180); break; case Xm: a = K.qq(b - 90); 90 < a && 270 > a && (a -= 180); break; case Ym: a = K.qq(b); if (45 < a && 135 > a || 225 < a && 315 > a) return 0; 90 < a && 270 > a && (a -= 180) }return K.qq(a) };
    function Oo(a) { var b = a.fromNode, c = a.toNode, d = null; null !== b ? d = null !== c ? b.lx(c) : b.containingGroup : null !== c ? d = c.containingGroup : d = null; b = d; c = a.Th; if (c !== b) { null !== c && Jo(c, a); a.Th = b; null !== b && Io(b, a); var e = a.containingGroupChanged; if (null !== e) { var f = !0, g = a.diagram; null !== g && (f = g.fa, g.fa = !0); e(a, c, b); null !== g && (g.fa = f) } !a.Mc || a.Pw !== c && a.Qw !== c || a.Ta() } if (a.isLabeledLink) for (a = a.labelNodes; a.next();)a.value.containingGroup = d } t = Q.prototype;
    t.zh = function () { var a = this.containingGroup; null !== a && this.fromNode !== a && this.toNode !== a && a.computesBoundsIncludingLinks && R.prototype.zh.call(this) }; t.bt = function (a) { E && w(a, V, Q, "getOtherNode:node"); var b = this.fromNode; return a === b ? this.toNode : b }; t.nz = function (a) { E && w(a, N, Q, "getOtherPort:port"); var b = this.fromPort; return a === b ? this.toPort : b }; function Vo(a, b) { null === a.bd && (a.bd = new I); a.bd.add(b); a.v() }
    t.hq = function (a) { R.prototype.hq.call(this, a); kp(this) && this.jq(this.actualBounds); if (!a) { a = this.Qe; var b = null; null !== a && (b = this.fromPort, To(a, this, b)); var c = this.hf; if (null !== c) { var d = this.toPort; c === a && d === b || To(c, this, d) } lp(this) } }; t.iq = function (a) { R.prototype.iq.call(this, a); kp(this) && this.jq(this.actualBounds); if (!a) { a = this.Qe; var b = null; null !== a && (b = this.fromPort, Uo(a, this, b)); var c = this.hf; if (null !== c) { var d = this.toPort; c === a && d === b || Uo(c, this, d) } mp(this) } };
    t.bk = function () { this.Mc = !0; if (null !== this.bd) { var a = this.diagram; if (null !== a) for (var b = this.bd.copy().iterator; b.next();)a.remove(b.value) } null !== this.data && (a = this.diagram, null !== a && a.partManager.removeDataForLink(this)) }; Q.prototype.updateRelationshipsFromData = function () { if (null !== this.data) { var a = this.diagram; null !== a && a.partManager.updateRelationshipsFromData(this) } };
    Q.prototype.move = function (a, b) { var c = b ? this.location : this.position, d = c.x; isNaN(d) && (d = 0); var e = c.y; isNaN(e) && (e = 0); d = a.x - d; e = a.y - e; !0 === b ? R.prototype.move.call(this, a, !1) : (a = J.allocAt(c.x + d, c.y + e), R.prototype.move.call(this, a, !1), J.free(a)); ng(this, d, e); for (a = this.labelNodes; a.next();)b = a.value, c = b.position, b.moveTo(c.x + d, c.y + e) };
    Q.prototype.canRelinkFrom = function () { if (!this.relinkableFrom) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowRelink) return !1; a = a.diagram; return null === a || a.allowRelink ? !0 : !1 }; Q.prototype.canRelinkTo = function () { if (!this.relinkableTo) return !1; var a = this.layer; if (null === a) return !0; if (!a.allowRelink) return !1; a = a.diagram; return null === a || a.allowRelink ? !0 : !1 };
    Q.prototype.computeMidPoint = function (a) {
        var b = this.pointsCount; if (0 === b) return a.assign(qc), a; if (1 === b) return a.assign(this.i(0)), a; if (2 === b) { var c = this.i(0), d = this.i(1); a.h((c.x + d.x) / 2, (c.y + d.y) / 2); return a } if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === fh)) return this.sa.kv(.5, a), a.add(this.i(0)), c = this.sa.figures.first(), a.offset(-c.startX, -c.startY), a; if (this.computeCurve() === fh) {
            if (3 === b) return this.i(1); d = (b - 1) / 3 | 0; c = 3 * (d / 2 | 0); if (1 === d % 2) {
                d = this.i(c); var e = this.i(c + 1),
                    f = this.i(c + 2); c = this.i(c + 3); K.wy(d.x, d.y, e.x, e.y, f.x, f.y, c.x, c.y, a)
            } else a.assign(this.i(c)); return a
        } var g = this.flattenedLengths; c = this.flattenedTotalLength; for (e = f = d = 0; d < c / 2 && f < b;) { e = g[f]; if (d + e > c / 2) break; d += e; f++ } b = this.i(f); f = this.i(f + 1); 1 > Math.abs(b.x - f.x) ? b.y > f.y ? a.h(b.x, b.y - (c / 2 - d)) : a.h(b.x, b.y + (c / 2 - d)) : 1 > Math.abs(b.y - f.y) ? b.x > f.x ? a.h(b.x - (c / 2 - d), b.y) : a.h(b.x + (c / 2 - d), b.y) : (c = (c / 2 - d) / e, a.h(b.x + c * (f.x - b.x), b.y + c * (f.y - b.y))); return a
    };
    Q.prototype.computeMidAngle = function () {
        var a = this.pointsCount; if (2 > a) return NaN; if (2 === a) return this.i(0).Xa(this.i(1)); if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === fh)) {
            a: {
                a = this.sa; var b = .5; 0 > b ? b = 0 : 1 < b && (b = 1); if (a.type === pe) a = 180 * Math.atan2(a.endY - a.startY, a.endX - a.startX) / Math.PI; else {
                    var c = a.flattenedSegments, d = a.flattenedLengths, e = c.length; b = a.flattenedTotalLength * b; for (var f = 0, g = 0; g < e; g++) {
                        var h = d[g], k = h.length; for (a = 0; a < k; a++) {
                            var l = h[a]; if (f + l >= b) {
                                b = c[g]; c = b[2 * a];
                                d = b[2 * a + 1]; e = b[2 * a + 2]; a = b[2 * a + 3]; a = 1 > Math.abs(e - c) && 1 > Math.abs(a - d) ? 0 : 1 > Math.abs(e - c) ? 0 <= a - d ? 90 : 270 : 1 > Math.abs(a - d) ? 0 <= e - c ? 0 : 180 : 180 * Math.atan2(a - d, e - c) / Math.PI; break a
                            } f += l
                        }
                    } a = NaN
                }
            } return a
        } if (this.computeCurve() === fh && 4 <= a) { d = (a - 1) / 3 | 0; c = 3 * (d / 2 | 0); if (1 === d % 2) return c = Math.floor(c), a = this.i(c), d = this.i(c + 1), e = this.i(c + 2), c = this.i(c + 3), K.vy(a.x, a.y, d.x, d.y, e.x, e.y, c.x, c.y); if (0 < c && c + 1 < a) return this.i(c - 1).Xa(this.i(c + 1)) } d = this.flattenedLengths; e = this.flattenedTotalLength; for (c = b = 0; b < e / 2 && c < a;) {
            f =
            d[c]; if (b + f > e / 2) break; b += f; c++
        } d = this.i(c); e = this.i(c + 1); if (1 > Math.abs(d.x - e.x) && 1 > Math.abs(d.y - e.y)) { if (0 < c && c + 2 < a) return this.i(c - 1).Xa(this.i(c + 2)) } else { if (1 > Math.abs(d.x - e.x)) return d.y > e.y ? 270 : 90; if (1 > Math.abs(d.y - e.y)) return d.x > e.x ? 180 : 0 } return d.Xa(e)
    }; t = Q.prototype; t.i = function (a) { return this.yb.j[a] };
    t.ld = function (a, b) { E && (w(b, J, Q, "setPoint"), b.o() || v("Link.setPoint called with a Point that does not have real numbers: " + b.toString())); E && null === this.Hc && v("Call Link.startRoute before modifying the points of the route."); this.yb.jd(a, b) }; t.N = function (a, b, c) { E && (B(b, Q, "setPointAt:x"), B(c, Q, "setPointAt:y")); E && null === this.Hc && v("Call Link.startRoute before modifying the points of the route."); this.yb.jd(a, new J(b, c)) };
    t.yz = function (a, b) { E && (w(b, J, Q, "insertPoint"), b.o() || v("Link.insertPoint called with a Point that does not have real numbers: " + b.toString())); E && null === this.Hc && v("Call Link.startRoute before modifying the points of the route."); this.yb.Lb(a, b) }; t.m = function (a, b, c) { E && (B(b, Q, "insertPointAt:x"), B(c, Q, "insertPointAt:y")); E && null === this.Hc && v("Call Link.startRoute before modifying the points of the route."); this.yb.Lb(a, new J(b, c)) };
    t.Be = function (a) { E && (w(a, J, Q, "addPoint"), a.o() || v("Link.addPoint called with a Point that does not have real numbers: " + a.toString())); E && null === this.Hc && v("Call Link.startRoute before modifying the points of the route."); this.yb.add(a) }; t.mf = function (a, b) { E && (B(a, Q, "insertPointAt:x"), B(b, Q, "insertPointAt:y")); E && null === this.Hc && v("Call Link.startRoute before modifying the points of the route."); this.yb.add(new J(a, b)) };
    t.Gv = function (a) { E && null === this.Hc && v("Call Link.startRoute before modifying the points of the route."); this.yb.nb(a) }; t.Xj = function () { E && null === this.Hc && v("Call Link.startRoute before modifying the points of the route."); this.yb.clear() };
    function ng(a, b, c) { if (0 !== b || 0 !== c) { for (var d = a.Mc, e = new F, f = a.yb.iterator; f.next();) { var g = f.value; e.add((new J(g.x + b, g.y + c)).freeze()) } e.freeze(); f = a.yb; a.yb = e; isNaN(b) || isNaN(c) || a.diagram.animationManager.sb ? a.v() : (a.oe.h(a.oe.x + b, a.oe.y + c), a.ua.h(a.ua.x + b, a.ua.y + c), Il(a)); d && np(a); b = a.diagram; null !== b && b.animationManager.sb && (a.bh = e); a.g("points", f, e) } } t.Dh = function () { null === this.Hc && (this.Hc = this.yb, this.yb = this.yb.copy()) };
    t.nf = function () {
        if (null !== this.Hc) {
            for (var a = this.Hc, b = this.yb, c = Infinity, d = Infinity, e = a.j, f = e.length, g = 0; g < f; g++) { var h = e[g]; c = Math.min(h.x, c); d = Math.min(h.y, d) } h = g = Infinity; for (var k = b.j, l = k.length, m = 0; m < l; m++) { var n = k[m]; g = Math.min(n.x, g); h = Math.min(n.y, h); n.freeze() } b.freeze(); if (l === f) for (f = 0; f < l; f++) { if (m = e[f], n = k[f], m.x - c !== n.x - g || m.y - d !== n.y - h) { this.v(); this.cc(); break } } else this.v(), this.cc(); this.Hc = null; c = this.diagram; null !== c && c.animationManager.sb && (this.bh = b); np(this); this.g("points",
                a, b)
        }
    }; t.Hx = function () { null !== this.Hc && (this.yb = this.Hc, this.Hc = null) }; function np(a) { 0 === a.yb.count ? a.Mc = !1 : (a.Mc = !0, a.wr = null, a.fu = NaN, a.defaultFromPoint = a.i(0), a.defaultToPoint = a.i(a.pointsCount - 1), op(a, !1)) }
    t.Ta = function () { if (!this.suspendsRouting) { var a = this.diagram; if (a) { if (a.lt.contains(this) || a.undoManager.isUndoingRedoing) return; a = a.animationManager; if (a.isTicking && !a.isAnimating) return; null !== this.bh && !a.isTicking && a.isAnimating && (this.bh = null) } a = this.path; null !== a && (this.Mc = !1, this.v(), a.v()) } }; t.bj = function () { if (!this.Mc && !this.Uu) { var a = !0; try { this.Uu = !0, this.Dh(), a = this.computePoints() } finally { this.Uu = !1, a ? this.nf() : this.Hx() } } };
    Q.prototype.computePoints = function () {
        var a = this.diagram; if (null === a) return !1; var b = this.fromNode, c = null; null === b ? (a.si || (a.gp = new Hg, a.gp.desiredSize = rc, a.gp.strokeWidth = 0, a.si = new V, a.si.add(a.gp), a.si.bc()), this.defaultFromPoint && (a.si.position = a.si.location = this.defaultFromPoint, a.si.bc(), b = a.si, c = a.gp)) : c = this.fromPort; if (null !== c && !b.isVisible()) { var d = b.findVisibleNode(); null !== d && d !== b ? (b = d, c = d.port) : b = d } this.Pw = b; if (null === b || !b.location.o()) return !1; for (; !(null === c || c.actualBounds.o() && c.uf());)c =
            c.panel; if (null === c) return !1; var e = this.toNode, f = null; null === e ? (a.ti || (a.hp = new Hg, a.hp.desiredSize = rc, a.hp.strokeWidth = 0, a.ti = new V, a.ti.add(a.hp), a.ti.bc()), this.defaultToPoint && (a.ti.position = a.ti.location = this.defaultToPoint, a.ti.bc(), e = a.ti, f = a.hp)) : f = this.toPort; null === f || e.isVisible() || (a = e.findVisibleNode(), null !== a && a !== e ? (e = a, f = a.port) : e = a); this.Qw = e; if (null === e || !e.location.o()) return !1; for (; !(null === f || f.actualBounds.o() && f.uf());)f = f.panel; if (null === f) return !1; var g = this.pointsCount;
        d = this.computeSpot(!0, c); a = this.computeSpot(!1, f); var h = pp(d), k = pp(a), l = c === f && null !== c, m = this.isOrthogonal, n = this.curve === fh; this.Jf = l && !m ? n = !0 : !1; var p = this.adjusting === ch || l; if (!m && !l && h && k) {
            if (h = !1, !p && 3 <= g && (p = this.getLinkPoint(b, c, d, !0, !1, e, f), k = this.getLinkPoint(e, f, a, !1, !1, b, c), h = this.adjustPoints(0, p, g - 1, k)) && (p = this.getLinkPoint(b, c, d, !0, !1, e, f), k = this.getLinkPoint(e, f, a, !1, !1, b, c), this.adjustPoints(0, p, g - 1, k)), !h) if (this.Xj(), n) {
                g = this.getLinkPoint(b, c, d, !0, !1, e, f); p = this.getLinkPoint(e,
                    f, a, !1, !1, b, c); h = p.x - g.x; k = p.y - g.y; l = this.computeCurviness(); n = m = 0; var q = g.x + h / 3, r = g.y + k / 3, u = q, x = r; K.B(k, 0) ? x = 0 < h ? x - l : x + l : (m = -h / k, n = Math.sqrt(l * l / (m * m + 1)), 0 > l && (n = -n), u = (0 > k ? -1 : 1) * n + q, x = m * (u - q) + r); q = g.x + 2 * h / 3; r = g.y + 2 * k / 3; var y = q, A = r; K.B(k, 0) ? A = 0 < h ? A - l : A + l : (y = (0 > k ? -1 : 1) * n + q, A = m * (y - q) + r); this.Xj(); this.Be(g); this.mf(u, x); this.mf(y, A); this.Be(p); this.ld(0, this.getLinkPoint(b, c, d, !0, !1, e, f)); this.ld(3, this.getLinkPoint(e, f, a, !1, !1, b, c))
            } else d = this.getLinkPoint(b, c, d, !0, !1, e, f), a = this.getLinkPoint(e,
                f, a, !1, !1, b, c), this.hasCurviness() ? (p = a.x - d.x, e = a.y - d.y, f = this.computeCurviness(), b = d.x + p / 2, c = d.y + e / 2, g = b, h = c, K.B(e, 0) ? h = 0 < p ? h - f : h + f : (p = -p / e, g = Math.sqrt(f * f / (p * p + 1)), 0 > f && (g = -g), g = (0 > e ? -1 : 1) * g + b, h = p * (g - b) + c), this.Be(d), this.mf(g, h)) : this.Be(d), this.Be(a)
        } else {
            n = this.isAvoiding; p && (m && n || l) && this.Xj(); var C = l ? this.computeCurviness() : 0; n = this.getLinkPoint(b, c, d, !0, m, e, f); q = u = r = 0; if (m || !h || l) x = this.computeEndSegmentLength(b, c, d, !0), q = this.getLinkDirection(b, c, n, d, !0, m, e, f), l && (h || d.A(a) || !m && 1 === d.x +
                a.x && 1 === d.y + a.y) && (q -= m ? 90 : 30, 0 > C && (q -= 180)), 0 > q ? q += 360 : 360 <= q && (q -= 360), l && (x += Math.abs(C) * (m ? 1 : 2)), 0 === q ? r = x : 90 === q ? u = x : 180 === q ? r = -x : 270 === q ? u = -x : (r = x * Math.cos(q * Math.PI / 180), u = x * Math.sin(q * Math.PI / 180)), d.Nb() && l && (x = c.oa(qd, J.alloc()), y = J.allocAt(x.x + 1E3 * r, x.y + 1E3 * u), this.getLinkPointFromPoint(b, c, x, y, !0, n), J.free(x), J.free(y)); x = this.getLinkPoint(e, f, a, !1, m, b, c); var G = A = y = 0; if (m || !k || l) {
                    var H = this.computeEndSegmentLength(e, f, a, !1); G = this.getLinkDirection(e, f, x, a, !1, m, b, c); l && (k || d.A(a) || !m &&
                        1 === d.x + a.x && 1 === d.y + a.y) && (G += m ? 0 : 30, 0 > C && (G += 180)); 0 > G ? G += 360 : 360 <= G && (G -= 360); l && (H += Math.abs(C) * (m ? 1 : 2)); 0 === G ? y = H : 90 === G ? A = H : 180 === G ? y = -H : 270 === G ? A = -H : (y = H * Math.cos(G * Math.PI / 180), A = H * Math.sin(G * Math.PI / 180)); a.Nb() && l && (a = f.oa(qd, J.alloc()), d = J.allocAt(a.x + 1E3 * y, a.y + 1E3 * A), this.getLinkPointFromPoint(e, f, a, d, !1, x), J.free(a), J.free(d))
                } a = n; if (m || !h || l) a = new J(n.x + r, n.y + u); d = x; if (m || !k || l) d = new J(x.x + y, x.y + A); !p && !m && h && 3 < g && this.adjustPoints(0, n, g - 2, d) ? this.ld(g - 1, x) : !p && !m && k && 3 < g && this.adjustPoints(1,
                    a, g - 1, x) ? this.ld(0, n) : !p && (m ? 6 <= g : 4 < g) && this.adjustPoints(1, a, g - 2, d) ? (this.ld(0, n), this.ld(g - 1, x)) : (this.Xj(), this.Be(n), (m || !h || l) && this.Be(a), m && this.addOrthoPoints(a, q, d, G, b, e), (m || !k || l) && this.Be(d), this.Be(x))
        } return !0
    }; function qp(a, b) { Math.abs(b.x - a.x) > Math.abs(b.y - a.y) ? (b.x >= a.x ? b.x = a.x + 9E9 : b.x = a.x - 9E9, b.y = a.y) : (b.y >= a.y ? b.y = a.y + 9E9 : b.y = a.y - 9E9, b.x = a.x); return b }
    Q.prototype.getLinkPointFromPoint = function (a, b, c, d, e, f) {
    void 0 === f && (f = new J); if (null === a || null === b) return f.assign(c), f; a.isVisible() || (e = a.findVisibleNode(), null !== e && e !== a && (b = e.port)); a = null; e = b.panel; null === e || e.ae() || (e = e.panel); if (null === e) { e = d.x; d = d.y; var g = c.x; c = c.y } else { a = e.td; e = 1 / (a.m11 * a.m22 - a.m12 * a.m21); g = a.m22 * e; var h = -a.m12 * e, k = -a.m21 * e, l = a.m11 * e, m = e * (a.m21 * a.dy - a.m22 * a.dx), n = e * (a.m12 * a.dx - a.m11 * a.dy); e = d.x * g + d.y * k + m; d = d.x * h + d.y * l + n; g = c.x * g + c.y * k + m; c = c.x * h + c.y * l + n } b.fk(e, d, g, c, f); null !==
        a && f.transform(a); return f
    }; function rp(a, b) { var c = b.Wo; null === c && (c = new sp, c.port = b, c.node = b.part, b.Wo = c); return tp(c, a) }
    Q.prototype.getLinkPoint = function (a, b, c, d, e, f, g, h) {
    void 0 === h && (h = new J); if (c.Za() && !pp(c)) return b.oa(c, h), h; if (c.tf()) { var k = rp(this, b); if (null !== k) { h.assign(k.nq); if (e && this.routing === up) { var l = rp(this, g); if (null !== l && k.$l < l.$l) { k = J.alloc(); l = J.alloc(); var m = new L(b.oa(fd, k), b.oa(ud, l)), n = this.computeSpot(!d, g); a = this.getLinkPoint(f, g, n, !d, e, a, b, l); (c.sf(wd) || c.sf(Ad)) && a.y >= m.y && a.y <= m.y + m.height ? h.y = a.y : (c.sf(vd) || c.sf(Bd)) && a.x >= m.x && a.x <= m.x + m.width && (h.x = a.x); J.free(k); J.free(l) } } return h } } c =
        b.oa(.5 === c.x && .5 === c.y ? c : qd, J.alloc()); this.pointsCount > (e ? 6 : 2) ? (g = d ? this.i(1) : this.i(this.pointsCount - 2), e && (g = qp(c, g.copy()))) : (k = this.computeSpot(!d, g), f = J.alloc(), g = g.oa(.5 === k.x && .5 === k.y ? k : qd, f), e && (g = qp(c, g)), J.free(f)); this.getLinkPointFromPoint(a, b, c, g, d, h); J.free(c); return h
    };
    Q.prototype.getLinkDirection = function (a, b, c, d, e, f, g, h) {
        a: if (d.Za()) var k = d.x > d.y ? d.x > 1 - d.y ? 0 : d.x < 1 - d.y ? 270 : 315 : d.x < d.y ? d.x > 1 - d.y ? 90 : d.x < 1 - d.y ? 180 : 135 : .5 > d.x ? 225 : .5 < d.x ? 45 : 0; else {
            if (d.tf() && (k = rp(this, b), null !== k)) switch (k.Ac) { case 1: k = 270; break a; case 2: k = 180; break a; default: case 4: k = 0; break a; case 8: k = 90; break a }k = b.oa(qd, J.alloc()); this.pointsCount > (f ? 6 : 2) ? (h = e ? this.i(1) : this.i(this.pointsCount - 2), h = f ? qp(k, h.copy()) : c) : (c = J.alloc(), h = h.oa(qd, c), J.free(c)); c = Math.abs(h.x - k.x) > Math.abs(h.y - k.y) ? h.x >=
                k.x ? 0 : 180 : h.y >= k.y ? 90 : 270; J.free(k); k = c
        } d.Nb() && g.Xd(a) && (k += 180, 360 <= k && (k -= 360)); if (pp(d)) return k; a = b.Ni(); if (0 === a) return k; 45 <= a && 135 > a ? k += 90 : 135 <= a && 225 > a ? k += 180 : 225 <= a && 315 > a && (k += 270); 360 <= k && (k -= 360); return k
    }; Q.prototype.computeEndSegmentLength = function (a, b, c, d) { if (null !== b && c.tf() && (a = rp(this, b), null !== a)) return a.av; a = d ? this.fromEndSegmentLength : this.toEndSegmentLength; null !== b && isNaN(a) && (a = d ? b.fromEndSegmentLength : b.toEndSegmentLength); isNaN(a) && (a = 10); return a };
    Q.prototype.computeSpot = function (a, b) { void 0 === b && (b = null); a ? (a = b ? b : this.fromPort, null === a ? a = qd : (b = this.fromSpot, b.Cb() && (b = a.fromSpot), a = b === Qd ? ed : b)) : (a = b ? b : this.toPort, null === a ? a = qd : (b = this.toSpot, b.Cb() && (b = a.toSpot), a = b === Qd ? ed : b)); return a }; function pp(a) { return a === ed || .5 === a.x && .5 === a.y } Q.prototype.computeOtherPoint = function (a, b) { a = b.oa(qd); b = b.Wo; b = null !== b ? tp(b, this) : null; null !== b && (a = b.nq); return a };
    Q.prototype.computeShortLength = function (a) { if (a) { a = this.fromShortLength; if (isNaN(a)) { var b = this.fromPort; null !== b && (a = b.fromShortLength) } return isNaN(a) ? 0 : a } a = this.toShortLength; isNaN(a) && (b = this.toPort, null !== b && (a = b.toShortLength)); return isNaN(a) ? 0 : a };
    Q.prototype.pg = function (a, b, c, d, e, f) {
        if (!1 === this.pickable) return !1; void 0 === b && (b = null); void 0 === c && (c = null); var g = f; void 0 === f && (g = $b.alloc(), g.reset()); g.multiply(this.transform); if (this.vh(a, g)) return nn(this, b, c, e), void 0 === f && $b.free(g), !0; if (this.Kc(a, g)) {
            var h = !1; if (!this.isAtomic) for (var k = this.Z.j, l = k.length; l--;) {
                var m = k[l]; if (m.visible || m === this.locationObject) {
                    var n = m.actualBounds, p = this.naturalBounds; if (!(n.x > p.width || n.y > p.height || 0 > n.x + n.width || 0 > n.y + n.height)) {
                        n = $b.alloc(); n.set(g);
                        if (m instanceof W) h = m.pg(a, b, c, d, e, n); else if (this.path === m) {
                            if (m instanceof Hg) if (h = a, p = d, !1 === m.pickable) h = !1; else if (n.multiply(m.transform), p) b: {
                                var q = h, r = n; if (m.vh(q, r)) h = !0; else {
                                    if (void 0 === r && (r = m.transform, q.pf(m.actualBounds))) { h = !0; break b } h = q.left; p = q.right; var u = q.top; q = q.bottom; var x = J.alloc(), y = J.alloc(), A = J.alloc(), C = $b.alloc(); C.set(r); C.uv(m.transform); C.gt(); y.x = p; y.y = u; y.transform(C); x.x = h; x.y = u; x.transform(C); r = !1; Jn(m, x, y, A) ? r = !0 : (x.x = p, x.y = q, x.transform(C), Jn(m, x, y, A) ? r = !0 : (y.x =
                                        h, y.y = q, y.transform(C), Jn(m, x, y, A) ? r = !0 : (x.x = h, x.y = u, x.transform(C), Jn(m, x, y, A) && (r = !0)))); $b.free(C); J.free(x); J.free(y); J.free(A); h = r
                                }
                            } else h = m.vh(h, n)
                        } else h = pl(m, a, d, n); h && (p = m, null !== b && (p = b(m)), p && (null === c || c(p)) && e.add(p)); $b.free(n)
                    }
                }
            } void 0 === f && $b.free(g); return h || null !== this.background || null !== this.areaBackground
        } void 0 === f && $b.free(g); return !1
    };
    Q.prototype.computeCurve = function () { if (null === this.Jf) { var a = this.fromPort, b = this.isOrthogonal; this.Jf = null !== a && a === this.toPort && !b } return this.Jf ? fh : this.curve }; Q.prototype.computeCorner = function () { if (this.curve === fh) return 0; var a = this.corner; if (isNaN(a) || 0 > a) a = 10; return a };
    Q.prototype.findMidLabel = function () { for (var a = this.path, b = this.Z.j, c = b.length, d = 0; d < c; d++) { var e = b[d]; if (e !== a && !e.isPanelMain && (-Infinity === e.segmentIndex || isNaN(e.segmentIndex))) return e } for (a = this.labelNodes; a.next();)if (b = a.value, -Infinity === b.segmentIndex || isNaN(b.segmentIndex)) return b; return null };
    Q.prototype.computeSpacing = function () {
        if (!this.isVisible()) return 0; var a = Math.max(14, this.computeThickness()); var b = this.fromPort, c = this.toPort; if (null !== b && null !== c) {
            var d = this.findMidLabel(); if (null !== d) {
                var e = d.naturalBounds, f = d.margin, g = isNaN(e.width) ? 30 : e.width * d.scale + f.left + f.right; e = isNaN(e.height) ? 14 : e.height * d.scale + f.top + f.bottom; d = d.segmentOrientation; d === Ln || d === jp || d === ip ? a = Math.max(a, e) : d === Wm || d === Xm || d === Um || d === Vm ? a = Math.max(a, g) : (b = b.oa(qd).Xa(c.oa(qd)) / 180 * Math.PI, a = Math.max(a,
                    Math.abs(Math.sin(b) * g) + Math.abs(Math.cos(b) * e) + 1)); this.curve === fh && (a *= 1.333)
            }
        } return a
    }; Q.prototype.arrangeBundledLinks = function (a, b) { if (b) for (b = 0; b < a.length; b++) { var c = a[b]; c.adjusting === ch && c.Ta() } };
    Q.prototype.computeCurviness = function () { var a = this.curviness; if (isNaN(a)) { a = 16; var b = this.Af; if (null !== b) { for (var c = Qa(), d = 0, e = b.links, f = 0; f < e.length; f++) { var g = e[f].computeSpacing(); c.push(g); d += g } d = -d / 2; for (f = 0; f < e.length; f++) { if (e[f] === this) { a = d + c[f] / 2; break } d += c[f] } b.ot === this.fromNode && (a = -a); Ta(c) } } return a }; Q.prototype.computeThickness = function () { if (!this.isVisible()) return 0; var a = this.path; return null !== a ? Math.max(a.strokeWidth, 1) : 1 };
    Q.prototype.hasCurviness = function () { return !isNaN(this.curviness) || null !== this.Af };
    Q.prototype.adjustPoints = function (a, b, c, d) {
        var e = this.adjusting; if (this.isOrthogonal) { if (e === gp) return !1; e === hp && (e = fp) } switch (e) {
            case gp: var f = this.i(a), g = this.i(c); if (!f.Sa(b) || !g.Sa(d)) {
                e = f.x; f = f.y; var h = g.x - e, k = g.y - f, l = Math.sqrt(h * h + k * k); if (!K.da(l, 0)) {
                    if (K.da(h, 0)) var m = 0 > k ? -Math.PI / 2 : Math.PI / 2; else m = Math.atan(k / Math.abs(h)), 0 > h && (m = Math.PI - m); g = b.x; var n = b.y; h = d.x - g; var p = d.y - n; k = Math.sqrt(h * h + p * p); K.da(h, 0) ? p = 0 > p ? -Math.PI / 2 : Math.PI / 2 : (p = Math.atan(p / Math.abs(h)), 0 > h && (p = Math.PI - p)); l = k / l; m =
                        p - m; this.ld(a, b); for (a += 1; a < c; a++)b = this.i(a), h = b.x - e, k = b.y - f, b = Math.sqrt(h * h + k * k), K.da(b, 0) || (K.da(h, 0) ? k = 0 > k ? -Math.PI / 2 : Math.PI / 2 : (k = Math.atan(k / Math.abs(h)), 0 > h && (k = Math.PI - k)), h = k + m, b *= l, this.N(a, g + b * Math.cos(h), n + b * Math.sin(h))); this.ld(c, d)
                }
            } return !0; case hp: f = this.i(a); n = this.i(c); if (!f.Sa(b) || !n.Sa(d)) {
                e = f.x; f = f.y; g = n.x; n = n.y; l = (g - e) * (g - e) + (n - f) * (n - f); h = b.x; m = b.y; k = d.x; p = d.y; var q = 1; if (0 !== k - h) { var r = (p - m) / (k - h); q = Math.sqrt(1 + 1 / (r * r)) } else r = 9E9; this.ld(a, b); for (a += 1; a < c; a++) {
                    b = this.i(a);
                    var u = b.x, x = b.y, y = .5; 0 !== l && (y = ((e - u) * (e - g) + (f - x) * (f - n)) / l); var A = e + y * (g - e), C = f + y * (n - f); b = Math.sqrt((u - A) * (u - A) + (x - C) * (x - C)); x < r * (u - A) + C && (b = -b); 0 < r && (b = -b); u = h + y * (k - h); y = m + y * (p - m); 0 !== r ? (b = u + b / q, this.N(a, b, y - (b - u) / r)) : this.N(a, u, y + b)
                } this.ld(c, d)
            } return !0; case fp: a: {
                if (this.isOrthogonal && (e = this.i(a), f = this.i(a + 1), g = this.i(a + 2), h = f.x, m = f.y, n = h, l = m, K.B(e.y, f.y) ? K.B(f.x, g.x) ? m = b.y : K.B(f.y, g.y) && (h = b.x) : K.B(e.x, f.x) && (K.B(f.y, g.y) ? h = b.x : K.B(f.x, g.x) && (m = b.y)), this.N(a + 1, h, m), e = this.i(c), f = this.i(c -
                    1), g = this.i(c - 2), h = f.x, m = f.y, k = h, p = m, K.B(e.y, f.y) ? K.B(f.x, g.x) ? m = d.y : K.B(f.y, g.y) && (h = d.x) : K.B(e.x, f.x) && (K.B(f.y, g.y) ? h = d.x : K.B(f.x, g.x) && (m = d.y)), this.N(c - 1, h, m), ck(this))) { this.N(a + 1, n, l); this.N(c - 1, k, p); c = !1; break a } this.ld(a, b); this.ld(c, d); c = !0
            } return c; default: return !1
        }
    };
    Q.prototype.addOrthoPoints = function (a, b, c, d, e, f) {
        b = -45 <= b && 45 > b ? 0 : 45 <= b && 135 > b ? 90 : 135 <= b && 225 > b ? 180 : 270; d = -45 <= d && 45 > d ? 0 : 45 <= d && 135 > d ? 90 : 135 <= d && 225 > d ? 180 : 270; var g = e.actualBounds.copy(), h = f.actualBounds.copy(); if (g.o() && h.o()) {
            g.Xc(8, 8); h.Xc(8, 8); g.Le(a); h.Le(c); if (0 === b) if (c.x > a.x || 270 === d && c.y < a.y && h.right > a.x || 90 === d && c.y > a.y && h.right > a.x) {
                var k = new J(c.x, a.y); var l = new J(c.x, (a.y + c.y) / 2); 180 === d ? (k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1), l.x = k.x, l.y = c.y) : 270 === d && c.y < a.y || 90 === d &&
                    c.y > a.y ? (k.x = a.x < h.left ? this.computeMidOrthoPosition(a.x, a.y, h.left, c.y, !1) : a.x < h.right && (270 === d && a.y < h.top || 90 === d && a.y > h.bottom) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : h.right, l.x = k.x, l.y = c.y) : 0 === d && a.x < h.left && a.y > h.top && a.y < h.bottom && (k.x = a.x, k.y = a.y < c.y ? Math.min(c.y, h.top) : Math.max(c.y, h.bottom), l.y = k.y)
            } else {
                k = new J(a.x, c.y); l = new J((a.x + c.x) / 2, c.y); if (180 === d || 90 === d && c.y < g.top || 270 === d && c.y > g.bottom) 180 === d && (h.ea(a) || g.ea(c)) ? k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) :
                    c.y < a.y && (180 === d || 90 === d) ? k.y = this.computeMidOrthoPosition(a.x, g.top, c.x, Math.max(c.y, h.bottom), !0) : c.y > a.y && (180 === d || 270 === d) && (k.y = this.computeMidOrthoPosition(a.x, g.bottom, c.x, Math.min(c.y, h.top), !0)), l.x = c.x, l.y = k.y; if (k.y > g.top && k.y < g.bottom) if (c.x >= g.left && c.x <= a.x || a.x <= h.right && a.x >= c.x) { if (90 === d || 270 === d) k = new J(Math.max((a.x + c.x) / 2, a.x), a.y), l = new J(k.x, c.y) } else k.y = 270 === d || (0 === d || 180 === d) && c.y < a.y ? Math.min(c.y, 0 === d ? g.top : Math.min(g.top, h.top)) : Math.max(c.y, 0 === d ? g.bottom : Math.max(g.bottom,
                        h.bottom)), l.x = c.x, l.y = k.y
            } else if (180 === b) if (c.x < a.x || 270 === d && c.y < a.y && h.left < a.x || 90 === d && c.y > a.y && h.left < a.x) k = new J(c.x, a.y), l = new J(c.x, (a.y + c.y) / 2), 0 === d ? (k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1), l.x = k.x, l.y = c.y) : 270 === d && c.y < a.y || 90 === d && c.y > a.y ? (k.x = a.x > h.right ? this.computeMidOrthoPosition(a.x, a.y, h.right, c.y, !1) : a.x > h.left && (270 === d && a.y < h.top || 90 === d && a.y > h.bottom) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : h.left, l.x = k.x, l.y = c.y) : 180 === d && a.x > h.right && a.y > h.top && a.y <
                h.bottom && (k.x = a.x, k.y = a.y < c.y ? Math.min(c.y, h.top) : Math.max(c.y, h.bottom), l.y = k.y); else {
                    k = new J(a.x, c.y); l = new J((a.x + c.x) / 2, c.y); if (0 === d || 90 === d && c.y < g.top || 270 === d && c.y > g.bottom) 0 === d && (h.ea(a) || g.ea(c)) ? k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : c.y < a.y && (0 === d || 90 === d) ? k.y = this.computeMidOrthoPosition(a.x, g.top, c.x, Math.max(c.y, h.bottom), !0) : c.y > a.y && (0 === d || 270 === d) && (k.y = this.computeMidOrthoPosition(a.x, g.bottom, c.x, Math.min(c.y, h.top), !0)), l.x = c.x, l.y = k.y; if (k.y > g.top && k.y < g.bottom) if (c.x <=
                        g.right && c.x >= a.x || a.x >= h.left && a.x <= c.x) { if (90 === d || 270 === d) k = new J(Math.min((a.x + c.x) / 2, a.x), a.y), l = new J(k.x, c.y) } else k.y = 270 === d || (0 === d || 180 === d) && c.y < a.y ? Math.min(c.y, 180 === d ? g.top : Math.min(g.top, h.top)) : Math.max(c.y, 180 === d ? g.bottom : Math.max(g.bottom, h.bottom)), l.x = c.x, l.y = k.y
            } else if (90 === b) if (c.y > a.y || 180 === d && c.x < a.x && h.bottom > a.y || 0 === d && c.x > a.x && h.bottom > a.y) k = new J(a.x, c.y), l = new J((a.x + c.x) / 2, c.y), 270 === d ? (k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0), l.x = c.x, l.y = k.y) : 180 ===
                d && c.x < a.x || 0 === d && c.x > a.x ? (k.y = a.y < h.top ? this.computeMidOrthoPosition(a.x, a.y, c.x, h.top, !0) : a.y < h.bottom && (180 === d && a.x < h.left || 0 === d && a.x > h.right) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : h.bottom, l.x = c.x, l.y = k.y) : 90 === d && a.y < h.top && a.x > h.left && a.x < h.right && (k.x = a.x < c.x ? Math.min(c.x, h.left) : Math.max(c.x, h.right), k.y = a.y, l.x = k.x); else {
                    k = new J(c.x, a.y); l = new J(c.x, (a.y + c.y) / 2); if (270 === d || 0 === d && c.x < g.left || 180 === d && c.x > g.right) 270 === d && (h.ea(a) || g.ea(c)) ? k.x = this.computeMidOrthoPosition(a.x,
                        a.y, c.x, c.y, !1) : c.x < a.x && (270 === d || 0 === d) ? k.x = this.computeMidOrthoPosition(g.left, a.y, Math.max(c.x, h.right), c.y, !1) : c.x > a.x && (270 === d || 180 === d) && (k.x = this.computeMidOrthoPosition(g.right, a.y, Math.min(c.x, h.left), c.y, !1)), l.x = k.x, l.y = c.y; if (k.x > g.left && k.x < g.right) if (c.y >= g.top && c.y <= a.y || a.y <= h.bottom && a.y >= c.y) { if (0 === d || 180 === d) k = new J(a.x, Math.max((a.y + c.y) / 2, a.y)), l = new J(c.x, k.y) } else k.x = 180 === d || (90 === d || 270 === d) && c.x < a.x ? Math.min(c.x, 90 === d ? g.left : Math.min(g.left, h.left)) : Math.max(c.x, 90 ===
                            d ? g.right : Math.max(g.right, h.right)), l.x = k.x, l.y = c.y
            } else if (c.y < a.y || 180 === d && c.x < a.x && h.top < a.y || 0 === d && c.x > a.x && h.top < a.y) k = new J(a.x, c.y), l = new J((a.x + c.x) / 2, c.y), 90 === d ? (k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0), l.x = c.x, l.y = k.y) : 180 === d && c.x < a.x || 0 === d && c.x >= a.x ? (k.y = a.y > h.bottom ? this.computeMidOrthoPosition(a.x, a.y, c.x, h.bottom, !0) : a.y > h.top && (180 === d && a.x < h.left || 0 === d && a.x > h.right) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : h.top, l.x = c.x, l.y = k.y) : 270 === d && a.y > h.bottom && a.x >
                h.left && a.x < h.right && (k.x = a.x < c.x ? Math.min(c.x, h.left) : Math.max(c.x, h.right), k.y = a.y, l.x = k.x); else {
                    k = new J(c.x, a.y); l = new J(c.x, (a.y + c.y) / 2); if (90 === d || 0 === d && c.x < g.left || 180 === d && c.x > g.right) 90 === d && (h.ea(a) || g.ea(c)) ? k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : c.x < a.x && (90 === d || 0 === d) ? k.x = this.computeMidOrthoPosition(g.left, a.y, Math.max(c.x, h.right), c.y, !1) : c.x > a.x && (90 === d || 180 === d) && (k.x = this.computeMidOrthoPosition(g.right, a.y, Math.min(c.x, h.left), c.y, !1)), l.x = k.x, l.y = c.y; if (k.x > g.left &&
                        k.x < g.right) if (c.y <= g.bottom && c.y >= a.y || a.y >= h.top && a.y <= c.y) { if (0 === d || 180 === d) k = new J(a.x, Math.min((a.y + c.y) / 2, a.y)), l = new J(c.x, k.y) } else k.x = 180 === d || (90 === d || 270 === d) && c.x < a.x ? Math.min(c.x, 270 === d ? g.left : Math.min(g.left, h.left)) : Math.max(c.x, 270 === d ? g.right : Math.max(g.right, h.right)), l.x = k.x, l.y = c.y
            } var m = k, n = l, p = c; if (this.isAvoiding) {
                var q = this.diagram; if (null === q || !yk(q) || g.ea(p) && !f.Xd(e) || h.ea(a) && !e.Xd(f) || e === f || this.layer.isTemporary) b = !1; else {
                    var r = zk(q, !0, this.containingGroup, null);
                    if (r.ik(Math.min(a.x, m.x), Math.min(a.y, m.y), Math.abs(a.x - m.x), Math.abs(a.y - m.y)) && r.ik(Math.min(m.x, n.x), Math.min(m.y, n.y), Math.abs(m.x - n.x), Math.abs(m.y - n.y)) && r.ik(Math.min(n.x, p.x), Math.min(n.y, p.y), Math.abs(n.x - p.x), Math.abs(n.y - p.y))) b = !1; else {
                        e = a; f = p; var u = c = null; if (q.isVirtualized) {
                            q = r.bounds.copy(); q.Xc(-r.Yl, -r.Xl); var x = J.alloc(); vp(r, a.x, a.y) || (K.Wc(q.x, q.y, q.x + q.width, q.y + q.height, a.x, a.y, m.x, m.y, x) ? (c = a = x.copy(), b = x.Xa(m)) : K.Wc(q.x, q.y, q.x + q.width, q.y + q.height, m.x, m.y, n.x, n.y, x) ? (c = a =
                                x.copy(), b = x.Xa(n)) : K.Wc(q.x, q.y, q.x + q.width, q.y + q.height, n.x, n.y, p.x, p.y, x) && (c = a = x.copy(), b = x.Xa(p))); vp(r, p.x, p.y) || (K.Wc(q.x, q.y, q.x + q.width, q.y + q.height, p.x, p.y, n.x, n.y, x) ? (u = p = x.copy(), d = n.Xa(x)) : K.Wc(q.x, q.y, q.x + q.width, q.y + q.height, n.x, n.y, m.x, m.y, x) ? (u = p = x.copy(), d = m.Xa(x)) : K.Wc(q.x, q.y, q.x + q.width, q.y + q.height, m.x, m.y, a.x, a.y, x) && (u = p = x.copy(), d = a.Xa(x))); J.free(x)
                        } g = g.copy().Lc(h); h = r.cA; g.Xc(r.Yl * h, r.Xl * h); wp(r, a, b, p, d, g); h = xp(r, p.x, p.y); !r.abort && h >= yp && (Ck(r), h = r.Gz, g.Xc(r.Yl * h, r.Xl *
                            h), wp(r, a, b, p, d, g), h = xp(r, p.x, p.y)); !r.abort && h >= yp && r.iA && (Ck(r), wp(r, a, b, p, d, r.bounds), h = xp(r, p.x, p.y)); if (!r.abort && h < yp && xp(r, p.x, p.y) !== zp) {
                                Ap(this, r, p.x, p.y, d, !0); g = this.i(2); if (4 > this.pointsCount) 0 === b || 180 === b ? (g.x = a.x, g.y = p.y) : (g.x = p.x, g.y = a.y), this.N(2, g.x, g.y), this.m(3, g.x, g.y); else if (p = this.i(3), 0 === b || 180 === b) K.B(g.x, p.x) ? (g = 0 === b ? Math.max(g.x, a.x) : Math.min(g.x, a.x), this.N(2, g, a.y), this.N(3, g, p.y)) : K.B(g.y, p.y) ? (Math.abs(a.y - g.y) <= r.Xl / 2 && (this.N(2, g.x, a.y), this.N(3, p.x, a.y)), this.m(2,
                                    g.x, a.y)) : this.N(2, a.x, g.y); else if (90 === b || 270 === b) K.B(g.y, p.y) ? (g = 90 === b ? Math.max(g.y, a.y) : Math.min(g.y, a.y), this.N(2, a.x, g), this.N(3, p.x, g)) : K.B(g.x, p.x) ? (Math.abs(a.x - g.x) <= r.Yl / 2 && (this.N(2, a.x, g.y), this.N(3, a.x, p.y)), this.m(2, a.x, g.y)) : this.N(2, g.x, a.y); null !== c && (a = this.i(1), p = this.i(2), a.x !== p.x && a.y !== p.y ? 0 === b || 180 === b ? this.m(2, a.x, p.y) : this.m(2, p.x, a.y) : 0 === b || 180 === b ? this.m(2, e.x, c.y) : this.m(2, c.x, e.y)); null !== u && (0 === d || 180 === d ? this.mf(f.x, u.y) : this.mf(u.x, f.y)); b = !0
                            } else b = !1
                    }
                }
            } else b =
                !1; b || (this.Be(k), this.Be(l))
        }
    }; Q.prototype.computeMidOrthoPosition = function (a, b, c, d, e) { var f = 0; this.hasCurviness() && (f = this.computeCurviness()); return e ? (b + d) / 2 + f : (a + c) / 2 + f }; function ck(a) { if (null === a.diagram || !a.isAvoiding || !yk(a.diagram)) return !1; var b = a.points.j, c = b.length; if (4 > c) return !1; a = zk(a.diagram, !0, a.containingGroup, null); for (var d = 1; d < c - 2; d++) { var e = b[d], f = b[d + 1]; if (!a.ik(Math.min(e.x, f.x), Math.min(e.y, f.y), Math.abs(e.x - f.x), Math.abs(e.y - f.y))) return !0 } return !1 }
    function Ap(a, b, c, d, e, f) {
        var g = b.Yl, h = b.Xl, k = xp(b, c, d), l = c, m = d; for (0 === e ? l += g : 90 === e ? m += h : 180 === e ? l -= g : m -= h; k > Bp && xp(b, l, m) === k - 1;)c = l, d = m, 0 === e ? l += g : 90 === e ? m += h : 180 === e ? l -= g : m -= h, --k; if (f) { if (k > Bp) if (180 === e || 0 === e) c = Math.floor(c / g) * g + g / 2; else if (90 === e || 270 === e) d = Math.floor(d / h) * h + h / 2 } else c = Math.floor(c / g) * g + g / 2, d = Math.floor(d / h) * h + h / 2; k > Bp && (f = e, l = c, m = d, 0 === e ? (f = 90, m += h) : 90 === e ? (f = 180, l -= g) : 180 === e ? (f = 270, m -= h) : 270 === e && (f = 0, l += g), xp(b, l, m) === k - 1 ? Ap(a, b, l, m, f, !1) : (l = c, m = d, 0 === e ? (f = 270, m -= h) : 90 ===
            e ? (f = 0, l += g) : 180 === e ? (f = 90, m += h) : 270 === e && (f = 180, l -= g), xp(b, l, m) === k - 1 && Ap(a, b, l, m, f, !1))); a.mf(c, d)
    } Q.prototype.Ry = function (a) { E && w(a, J, Q, "findClosestSegment:p"); var b = a.x; a = a.y; for (var c = this.i(0), d = this.i(1), e = cc(b, a, c.x, c.y, d.x, d.y), f = 0, g = 1; g < this.pointsCount - 1; g++) { c = this.i(g + 1); var h = cc(b, a, d.x, d.y, c.x, c.y); d = c; h < e && (f = g, e = h) } return f }; Q.prototype.cc = function () { this.Un = !0 };
    Q.prototype.kk = function (a) { if (!a) { if (!1 === this.Mc) return; a = this.Bb(); if (!this.Un && (null === a || null !== a.geometry)) return } this.sa = this.makeGeometry(); a = this.path; if (null !== a) { a.sa = this.sa; for (var b = this.Z.j, c = b.length, d = 0; d < c; d++) { var e = b[d]; e !== a && e.isPanelMain && e instanceof Hg && (e.sa = this.sa) } } };
    Q.prototype.makeGeometry = function () {
        var a = this.sa, b = this.pointsCount; if (2 > b) return a.type = pe, this.Un = !1, a; var c = !1, d = this.diagram; null !== d && kp(this) && d.Yh.contains(this) && (0 !== this.Bl.width || 0 !== this.Bl.height) && (c = !0); var e = this.i(0).copy(), f = e.copy(); d = this.yb.j; var g = this.computeCurve(); if (g === fh && 3 <= b && !K.da(this.smoothness, 0)) if (3 === b) { var h = this.i(1); d = Math.min(e.x, h.x); var k = Math.min(e.y, h.y); h = this.i(2); d = Math.min(d, h.x); k = Math.min(k, h.y) } else {
            if (this.isOrthogonal) for (k = 0; k < b; k++)h = d[k], f.x =
                Math.min(h.x, f.x), f.y = Math.min(h.y, f.y); else for (d = 3; d < b; d += 3)d + 3 >= b && (d = b - 1), k = this.i(d), f.x = Math.min(k.x, f.x), f.y = Math.min(k.y, f.y); d = f.x; k = f.y
        } else { for (k = 0; k < b; k++)h = d[k], f.x = Math.min(h.x, f.x), f.y = Math.min(h.y, f.y); d = f.x; k = f.y } d -= this.Eu.x; k -= this.Eu.y; e.x -= d; e.y -= k; if (2 !== b || kp(this)) {
        a.type = ne; h = Ae(a); 0 !== this.computeShortLength(!0) && (e = Cp(this, e, !0, f)); Be(h, e.x, e.y, !1); if (g === fh && 3 <= b && !K.da(this.smoothness, 0)) if (3 === b) c = this.i(1), b = c.x - d, c = c.y - k, e = this.i(2).copy(), e.x -= d, e.y -= k, 0 !== this.computeShortLength(!1) &&
            (e = Cp(this, e, !1, f)), Ce(h, b, c, b, c, e.x, e.y); else if (this.isOrthogonal) {
                f = new J(d, k); e = this.i(1).copy(); g = new J(d, k); b = new J(d, k); c = this.i(0); for (var l, m = this.smoothness / 3, n = 1; n < this.pointsCount - 1; n++) {
                    l = this.i(n); var p = c, q = l, r = this.i(Dp(this, l, n, !1)); if (!K.da(p.x, q.x) || !K.da(q.x, r.x)) if (!K.da(p.y, q.y) || !K.da(q.y, r.y)) {
                        var u = m; isNaN(u) && (u = this.smoothness / 3); var x = p.x; p = p.y; var y = q.x; q = q.y; var A = r.x; r = r.y; var C = u * Ep(x, p, y, q); u *= Ep(y, q, A, r); K.da(p, q) && K.da(y, A) && (y > x ? r > q ? (g.x = y - C, g.y = q - C, b.x = y + u, b.y =
                            q + u) : (g.x = y - C, g.y = q + C, b.x = y + u, b.y = q - u) : r > q ? (g.x = y + C, g.y = q - C, b.x = y - u, b.y = q + u) : (g.x = y + C, g.y = q + C, b.x = y - u, b.y = q - u)); K.da(x, y) && K.da(q, r) && (q > p ? (A > y ? (g.x = y - C, g.y = q - C, b.x = y + u) : (g.x = y + C, g.y = q - C, b.x = y - u), b.y = q + u) : (A > y ? (g.x = y - C, g.y = q + C, b.x = y + u) : (g.x = y + C, g.y = q + C, b.x = y - u), b.y = q - u)); if (K.da(x, y) && K.da(y, A) || K.da(p, q) && K.da(q, r)) x = .5 * (x + A), p = .5 * (p + r), g.x = x, g.y = p, b.x = x, b.y = p; 1 === n ? (e.x = .5 * (c.x + l.x), e.y = .5 * (c.y + l.y)) : 2 === n && K.da(c.x, this.i(0).x) && K.da(c.y, this.i(0).y) && (e.x = .5 * (c.x + l.x), e.y = .5 * (c.y + l.y)); Ce(h, e.x -
                                d, e.y - k, g.x - d, g.y - k, l.x - d, l.y - k); f.set(g); e.set(b); c = l
                    }
                } f = c.x; c = c.y; e = this.i(this.pointsCount - 1); 0 !== this.computeShortLength(!1) && (e = Cp(this, e.copy(), !1, gc)); f = .5 * (f + e.x); c = .5 * (c + e.y); Ce(h, b.x - d, b.y - k, f - d, c - k, e.x - d, e.y - k)
            } else for (c = 3; c < b; c += 3)f = this.i(c - 2), c + 3 >= b && (c = b - 1), e = this.i(c - 1), g = this.i(c), c === b - 1 && 0 !== this.computeShortLength(!1) && (g = Cp(this, g.copy(), !1, gc)), Ce(h, f.x - d, f.y - k, e.x - d, e.y - k, g.x - d, g.y - k); else {
                f = J.alloc(); f.assign(this.i(0)); g = 1; for (e = 0; g < b;) {
                    g = Dp(this, f, g, 1 < g); m = this.i(g); if (g >=
                        b - 1) { if (!f.A(m)) 0 !== this.computeShortLength(!1) && (m = Cp(this, m.copy(), !1, gc)), Fp(this, h, -d, -k, f, m, c); else if (0 === e) for (g = 1; g < b;)m = this.i(g++), Fp(this, h, -d, -k, f, m, c), f.assign(m); break } e = Dp(this, m, g + 1, g < b - 3); g = -d; l = -k; n = this.i(e); x = c; K.B(f.y, m.y) && K.B(m.x, n.x) ? (p = this.computeCorner(), p = Math.min(p, Math.abs(m.x - f.x) / 2), p = u = Math.min(p, Math.abs(n.y - m.y) / 2), K.B(p, 0) ? (Fp(this, h, g, l, f, m, x), f.assign(m)) : (y = m.x, q = m.y, A = y, r = q, m.x > f.x ? y = m.x - p : y = m.x + p, n.y > m.y ? r = m.y + u : r = m.y - u, Fp(this, h, g, l, f, new J(y, q), x), He(h, m.x +
                            g, m.y + l, A + g, r + l), f.h(A, r))) : K.B(f.x, m.x) && K.B(m.y, n.y) ? (p = this.computeCorner(), p = Math.min(p, Math.abs(m.y - f.y) / 2), p = u = Math.min(p, Math.abs(n.x - m.x) / 2), K.B(u, 0) ? (Fp(this, h, g, l, f, m, x), f.assign(m)) : (y = m.x, q = m.y, A = y, r = q, m.y > f.y ? q = m.y - p : q = m.y + p, n.x > m.x ? A = m.x + u : A = m.x - u, Fp(this, h, g, l, f, new J(y, q), x), He(h, m.x + g, m.y + l, A + g, r + l), f.h(A, r))) : (Fp(this, h, g, l, f, m, x), f.assign(m)); g = e
                } J.free(f)
        } Ke = h
        } else h = this.i(1).copy(), h.x -= d, h.y -= k, 0 !== this.computeShortLength(!0) && (e = Cp(this, e, !0, f)), 0 !== this.computeShortLength(!1) &&
            (h = Cp(this, h, !1, f)), a.type = pe, a.startX = e.x, a.startY = e.y, a.endX = h.x, a.endY = h.y; this.Un = !1; return a
    }; function Ep(a, b, c, d) { a = c - a; if (isNaN(a) || Infinity === a || -Infinity === a) return NaN; 0 > a && (a = -a); b = d - b; if (isNaN(b) || Infinity === b || -Infinity === b) return NaN; 0 > b && (b = -b); return K.da(a, 0) ? b : K.da(b, 0) ? a : Math.sqrt(a * a + b * b) }
    function Cp(a, b, c, d) { var e = a.pointsCount; if (2 > e) return b; if (c) { var f = a.i(1); c = f.x - d.x; f = f.y - d.y; d = Ep(b.x, b.y, c, f); if (0 === d) return b; e = 2 === e ? .5 * d : d; a = a.computeShortLength(!0); a > e && (a = e); e = a * (f - b.y) / d; b.x += a * (c - b.x) / d; b.y += e } else { f = a.i(e - 2); c = f.x - d.x; f = f.y - d.y; d = Ep(b.x, b.y, c, f); if (0 === d) return b; e = 2 === e ? .5 * d : d; a = a.computeShortLength(!1); a > e && (a = e); e = a * (b.y - f) / d; b.x -= a * (b.x - c) / d; b.y -= e } return b }
    function Dp(a, b, c, d) { for (var e = a.pointsCount, f = b; K.da(b.x, f.x) && K.da(b.y, f.y);) { if (c >= e) return e - 1; f = a.i(c++) } if (!K.da(b.x, f.x) && !K.da(b.y, f.y)) return c - 1; for (var g = f; K.da(b.x, f.x) && K.da(f.x, g.x) && (!d || (b.y >= f.y ? f.y >= g.y : f.y <= g.y)) || K.da(b.y, f.y) && K.da(f.y, g.y) && (!d || (b.x >= f.x ? f.x >= g.x : f.x <= g.x));) { if (c >= e) return e - 1; g = a.i(c++) } return c - 2 }
    function Fp(a, b, c, d, e, f, g) {
        if (!g && kp(a)) {
            g = []; var h = 0; a.isVisible() && (h = Gp(a, e, f, g)); if (0 < h) if (K.B(e.y, f.y)) if (e.x < f.x) for (var k = 0; k < h;) { var l = Math.max(e.x, Math.min(g[k++] - 5, f.x - 10)); b.lineTo(l + c, f.y + d); var m = l + c; for (var n = Math.min(l + 10, f.x); k < h;)if (l = g[k], l < n + 10) k++ , n = Math.min(l + 5, f.x); else break; l = f.y - 10 + d; n += c; var p = f.y + d; a.curve === bh ? Be(b, n, p, !1) : Ce(b, m, l, n, l, n, p) } else for (--h; 0 <= h;) {
                k = Math.min(e.x, Math.max(g[h--] + 5, f.x + 10)); b.lineTo(k + c, f.y + d); m = k + c; for (l = Math.max(k - 10, f.x); 0 <= h;)if (k = g[h], k >
                    l - 10) h-- , l = Math.max(k - 5, f.x); else break; k = f.y - 10 + d; l += c; n = f.y + d; a.curve === bh ? Be(b, l, n, !1) : Ce(b, m, k, l, k, l, n)
            } else if (K.B(e.x, f.x)) if (e.y < f.y) for (k = 0; k < h;) { l = Math.max(e.y, Math.min(g[k++] - 5, f.y - 10)); b.lineTo(f.x + c, l + d); m = l + d; for (l = Math.min(l + 10, f.y); k < h;)if (n = g[k], n < l + 10) k++ , l = Math.min(n + 5, f.y); else break; n = f.x - 10 + c; p = f.x + c; l += d; a.curve === bh ? Be(b, p, l, !1) : Ce(b, n, m, n, l, p, l) } else for (--h; 0 <= h;) {
                k = Math.min(e.y, Math.max(g[h--] + 5, f.y + 10)); b.lineTo(f.x + c, k + d); m = k + d; for (k = Math.max(k - 10, f.y); 0 <= h;)if (l = g[h],
                    l > k - 10) h-- , k = Math.max(l - 5, f.y); else break; l = f.x - 10 + c; n = f.x + c; k += d; a.curve === bh ? Be(b, n, k, !1) : Ce(b, l, m, l, k, n, k)
            }
        } b.lineTo(f.x + c, f.y + d)
    }
    function Gp(a, b, c, d) { var e = a.diagram; if (null === e || b.A(c)) return 0; for (e = e.layers; e.next();) { var f = e.value; if (null !== f && f.visible) { f = f.Ga.j; for (var g = f.length, h = 0; h < g; h++) { var k = f[h]; if (k instanceof Q) { if (k === a) return 0 < d.length && d.sort(function (a, b) { return a - b }), d.length; if (k.isVisible() && kp(k)) { var l = k.routeBounds; l.o() && a.routeBounds.Kc(l) && !a.usesSamePort(k) && (l = k.path, null !== l && l.uf() && Hp(b, c, d, k)) } } } } } 0 < d.length && d.sort(function (a, b) { return a - b }); return d.length }
    function Hp(a, b, c, d) {
        for (var e = K.B(a.y, b.y), f = d.pointsCount, g = d.i(0), h = J.alloc(), k = 1; k < f; k++) {
            var l = d.i(k); if (k < f - 1) { var m = d.i(k + 1); if (g.y === l.y && l.y === m.y) { if (l.x > g.x && m.x >= l.x || l.x < g.x && m.x <= l.x) continue } else if (g.x === l.x && l.x === m.x && (l.y > g.y && m.y >= l.y || l.y < g.y && m.y <= l.y)) continue } a: {
                m = a.x; var n = a.y, p = b.x, q = b.y, r = g.x; g = g.y; var u = l.x, x = l.y; if (!K.B(m, p)) { if (K.B(n, q) && K.B(r, u) && Math.min(m, p) < r && Math.max(m, p) > r && Math.min(g, x) < n && Math.max(g, x) > n && !K.B(g, x)) { h.x = r; h.y = n; m = !0; break a } } else if (!K.B(n, q) &&
                    K.B(g, x) && Math.min(n, q) < g && Math.max(n, q) > g && Math.min(r, u) < m && Math.max(r, u) > m && !K.B(r, u)) { h.x = m; h.y = g; m = !0; break a } h.x = 0; h.y = 0; m = !1
            } m && (e ? c.push(h.x) : c.push(h.y)); g = l
        } J.free(h)
    } function kp(a) { a = a.curve; return a === ah || a === bh } function op(a, b) { if (b || kp(a)) b = a.diagram, null === b || b.Yi || b.Yh.contains(a) || 0 === a.Bl.width && 0 === a.Bl.height || b.Yh.add(a, a.Bl) }
    Q.prototype.jq = function (a) { var b = this.layer; if (null !== b && b.visible && !b.isTemporary) { var c = b.diagram; if (null !== c && !c.animationManager.isAnimating) { var d = !1; for (c = c.layers; c.next();) { var e = c.value; if (e.visible) if (e === b) { d = !0; var f = !1; e = e.Ga.j; for (var g = e.length, h = 0; h < g; h++) { var k = e[h]; k instanceof Q && (k === this ? f = !0 : f && Ip(this, k, a)) } } else if (d) for (f = e.Ga.j, e = f.length, g = 0; g < e; g++)h = f[g], h instanceof Q && Ip(this, h, a) } } } };
    function Ip(a, b, c) { if (null !== b && null !== b.sa && kp(b)) { var d = b.routeBounds; d.o() && (a.routeBounds.Kc(d) || c.Kc(d)) && (a.usesSamePort(b) || b.cc()) } } Q.prototype.usesSamePort = function (a) { var b = this.pointsCount, c = a.pointsCount; if (0 < b && 0 < c) { var d = this.i(0), e = a.i(0); if (d.Sa(e)) return !0; b = this.i(b - 1); a = a.i(c - 1); if (b.Sa(a) || d.Sa(a) || b.Sa(e)) return !0 } else if (this.fromNode === a.fromNode || this.toNode === a.toNode || this.fromNode === a.toNode || this.toNode === a.fromNode) return !0; return !1 };
    Q.prototype.isVisible = function () {
        if (!R.prototype.isVisible.call(this)) return !1; var a = this.containingGroup, b = !0, c = this.diagram; null !== c && (b = c.isTreePathToChildren); c = this.fromNode; if (null !== c) { if (this.isTreeLink && b && !c.isTreeExpanded) return !1; if (c === a) return !0; for (var d = c; null !== d;) { if (d.labeledLink === this) return !0; d = d.containingGroup } c = c.findVisibleNode(); if (null === c || c === a) return !1 } c = this.toNode; if (null !== c) {
            if (this.isTreeLink && !b && !c.isTreeExpanded) return !1; if (c === a) return !0; for (b = c; null !== b;) {
                if (b.labeledLink ===
                    this) return !0; b = b.containingGroup
            } b = c.findVisibleNode(); if (null === b || b === a) return !1
        } return !0
    }; Q.prototype.Ob = function (a) { R.prototype.Ob.call(this, a); null !== this.Af && this.Af.gm(); if (null !== this.bd) for (var b = this.bd.iterator; b.next();)b.value.Ob(a) };
    function lp(a) { var b = a.Qe; if (null !== b) { var c = a.hf; if (null !== c) { for (var d = a.Re, e = a.jf, f = a = null, g = b.$a.j, h = g.length, k = 0; k < h; k++) { var l = g[k]; if (l.Qe === b && l.Re === d && l.hf === c && l.jf === e || l.Qe === c && l.Re === e && l.hf === b && l.jf === d) null === f ? f = l : (null === a && (a = [], a.push(f)), a.push(l)) } if (null !== a) { f = Ro(b, c, d, e); null === f && (f = new Jp(b, d, c, e), Qo(b, f), Qo(c, f)); f.links = a; for (b = 0; b < a.length; b++)a[b].Af = f; f.gm() } } } } function mp(a) { var b = a.Af; null !== b && (a.Af = null, a = b.links.indexOf(a), 0 <= a && (Oa(b.links, a), b.gm())) }
    Q.prototype.Ah = function () { return !0 };
    na.Object.defineProperties(Q.prototype, {
        fromNode: {
            configurable: !0, get: function () { return this.Qe }, set: function (a) {
                var b = this.Qe; if (b !== a) {
                E && null !== a && w(a, V, Q, "fromNode"); var c = this.fromPort; null !== b && (this.hf !== b && Uo(b, this, c), mp(this), this.C(2)); this.Qe = a; null !== a && this.Ob(a.isVisible()); this.Jf = null; this.Ta(); var d = this.diagram; null !== d && d.partManager.setFromNodeForLink(this, a, b); var e = this.fromPort, f = this.fromPortChanged; if (null !== f) {
                    var g = !0; null !== d && (g = d.fa, d.fa = !0); f(this, c, e);
                    null !== d && (d.fa = g)
                } null !== a && (this.hf !== a && To(a, this, e), lp(this), this.C(1)); this.g("fromNode", b, a); Oo(this)
                }
            }
        }, fromPortId: {
            configurable: !0, get: function () { return this.Re }, set: function (a) {
                var b = this.Re; if (b !== a) {
                    E && z(a, "string", Q, "fromPortId"); var c = this.fromPort; null !== c && So(this.fromNode, c); mp(this); this.Re = a; var d = this.fromPort; null !== d && So(this.fromNode, d); var e = this.diagram; if (null !== e) { var f = this.data, g = e.model; null !== f && g.im() && g.Lx(f, a) } c !== d && (this.Jf = null, this.Ta(), f = this.fromPortChanged,
                        null !== f && (g = !0, null !== e && (g = e.fa, e.fa = !0), f(this, c, d), null !== e && (e.fa = g))); lp(this); this.g("fromPortId", b, a)
                }
            }
        }, fromPort: { configurable: !0, get: function () { var a = this.Qe; return null === a ? null : a.Ys(this.Re) } }, fromPortChanged: { configurable: !0, get: function () { return this.Jn }, set: function (a) { var b = this.Jn; b !== a && (null !== a && z(a, "function", Q, "fromPortChanged"), this.Jn = a, this.g("fromPortChanged", b, a)) } }, toNode: {
            configurable: !0, get: function () { return this.hf }, set: function (a) {
                var b =
                    this.hf; if (b !== a) { E && null !== a && w(a, V, Q, "toNode"); var c = this.toPort; null !== b && (this.Qe !== b && Uo(b, this, c), mp(this), this.C(2)); this.hf = a; null !== a && this.Ob(a.isVisible()); this.Jf = null; this.Ta(); var d = this.diagram; null !== d && d.partManager.setToNodeForLink(this, a, b); var e = this.toPort, f = this.toPortChanged; if (null !== f) { var g = !0; null !== d && (g = d.fa, d.fa = !0); f(this, c, e); null !== d && (d.fa = g) } null !== a && (this.Qe !== a && To(a, this, e), lp(this), this.C(1)); this.g("toNode", b, a); Oo(this) }
            }
        }, toPortId: {
            configurable: !0,
            get: function () { return this.jf }, set: function (a) { var b = this.jf; if (b !== a) { E && z(a, "string", Q, "toPortId"); var c = this.toPort; null !== c && So(this.toNode, c); mp(this); this.jf = a; var d = this.toPort; null !== d && So(this.toNode, d); var e = this.diagram; if (null !== e) { var f = this.data, g = e.model; null !== f && g.im() && g.Px(f, a) } c !== d && (this.Jf = null, this.Ta(), f = this.toPortChanged, null !== f && (g = !0, null !== e && (g = e.fa, e.fa = !0), f(this, c, d), null !== e && (e.fa = g))); lp(this); this.g("toPortId", b, a) } }
        }, toPort: {
            configurable: !0, get: function () {
                var a =
                    this.hf; return null === a ? null : a.Ys(this.jf)
            }
        }, toPortChanged: { configurable: !0, get: function () { return this.Ip }, set: function (a) { var b = this.Ip; b !== a && (null !== a && z(a, "function", Q, "toPortChanged"), this.Ip = a, this.g("toPortChanged", b, a)) } }, fromSpot: { configurable: !0, get: function () { return null !== this.R ? this.R.Og : Qd }, set: function (a) { this.Jc(); var b = this.R.Og; b.A(a) || (E && w(a, M, Q, "fromSpot"), a = a.J(), this.R.Og = a, this.g("fromSpot", b, a), this.Ta()) } }, fromEndSegmentLength: {
            configurable: !0,
            enumerable: !0, get: function () { return null !== this.R ? this.R.Mg : NaN }, set: function (a) { this.Jc(); var b = this.R.Mg; b !== a && (E && z(a, "number", Q, "fromEndSegmentLength"), 0 > a && Ca(a, ">= 0", Q, "fromEndSegmentLength"), this.R.Mg = a, this.g("fromEndSegmentLength", b, a), this.Ta()) }
        }, fromShortLength: { configurable: !0, get: function () { return null !== this.R ? this.R.Ng : NaN }, set: function (a) { this.Jc(); var b = this.R.Ng; b !== a && (E && z(a, "number", Q, "fromShortLength"), this.R.Ng = a, this.g("fromShortLength", b, a), this.Ta(), this.cc()) } },
        toSpot: { configurable: !0, get: function () { return null !== this.R ? this.R.nh : Qd }, set: function (a) { this.Jc(); var b = this.R.nh; b.A(a) || (E && w(a, M, Q, "toSpot"), a = a.J(), this.R.nh = a, this.g("toSpot", b, a), this.Ta()) } }, toEndSegmentLength: { configurable: !0, get: function () { return null !== this.R ? this.R.lh : NaN }, set: function (a) { this.Jc(); var b = this.R.lh; b !== a && (E && z(a, "number", Q, "toEndSegmentLength"), 0 > a && Ca(a, ">= 0", Q, "toEndSegmentLength"), this.R.lh = a, this.g("toEndSegmentLength", b, a), this.Ta()) } },
        toShortLength: { configurable: !0, get: function () { return null !== this.R ? this.R.mh : NaN }, set: function (a) { this.Jc(); var b = this.R.mh; b !== a && (E && z(a, "number", Q, "toShortLength"), this.R.mh = a, this.g("toShortLength", b, a), this.Ta(), this.cc()) } }, isLabeledLink: { configurable: !0, get: function () { return null === this.bd ? !1 : 0 < this.bd.count } }, labelNodes: { configurable: !0, get: function () { return null === this.bd ? Cb : this.bd.iterator } }, relinkableFrom: {
            configurable: !0, get: function () {
                return 0 !==
                    (this.Va & 1)
            }, set: function (a) { var b = 0 !== (this.Va & 1); b !== a && (E && z(a, "boolean", Q, "relinkableFrom"), this.Va ^= 1, this.g("relinkableFrom", b, a), this.Mb()) }
        }, relinkableTo: { configurable: !0, get: function () { return 0 !== (this.Va & 2) }, set: function (a) { var b = 0 !== (this.Va & 2); b !== a && (E && z(a, "boolean", Q, "relinkableTo"), this.Va ^= 2, this.g("relinkableTo", b, a), this.Mb()) } }, resegmentable: {
            configurable: !0, get: function () { return 0 !== (this.Va & 4) }, set: function (a) {
                var b = 0 !== (this.Va & 4); b !== a && (E && z(a,
                    "boolean", Q, "resegmentable"), this.Va ^= 4, this.g("resegmentable", b, a), this.Mb())
            }
        }, isTreeLink: { configurable: !0, get: function () { return 0 !== (this.Va & 8) }, set: function (a) { var b = 0 !== (this.Va & 8); b !== a && (E && z(a, "boolean", Q, "isTreeLink"), this.Va ^= 8, this.g("isTreeLink", b, a), null !== this.fromNode && Lk(this.fromNode), null !== this.toNode && Lk(this.toNode)) } }, path: { configurable: !0, get: function () { var a = this.Bb(); return a instanceof Hg ? a : null } }, routeBounds: {
            configurable: !0, get: function () {
                this.bj();
                var a = this.Bl, b = Infinity, c = Infinity, d = this.pointsCount; if (0 === d) a.h(NaN, NaN, 0, 0); else {
                    if (1 === d) d = this.i(0), b = Math.min(d.x, b), c = Math.min(d.y, c), a.h(d.x, d.y, 0, 0); else if (2 === d) { d = this.i(0); var e = this.i(1); b = Math.min(d.x, e.x); c = Math.min(d.y, e.y); a.h(d.x, d.y, 0, 0); a.Le(e) } else if (this.computeCurve() === fh && 3 <= d && !this.isOrthogonal) if (e = this.i(0), b = e.x, c = e.y, a.h(b, c, 0, 0), 3 === d) {
                        d = this.i(1); b = Math.min(d.x, b); c = Math.min(d.y, c); var f = this.i(2); b = Math.min(f.x, b); c = Math.min(f.y, c); K.Wl(e.x, e.y, d.x, d.y, d.x, d.y,
                            f.x, f.y, .5, a)
                    } else for (f = 3; f < d; f += 3) { var g = this.i(f - 2); f + 3 >= d && (f = d - 1); var h = this.i(f - 1), k = this.i(f); K.Wl(e.x, e.y, g.x, g.y, h.x, h.y, k.x, k.y, .5, a); b = Math.min(k.x, b); c = Math.min(k.y, c); e = k } else for (e = this.i(0), f = this.i(1), b = Math.min(e.x, f.x), c = Math.min(e.y, f.y), a.h(e.x, e.y, 0, 0), a.Le(f), e = 2; e < d; e++)f = this.i(e), b = Math.min(f.x, b), c = Math.min(f.y, c), a.Le(f); this.Eu.h(b - a.x, c - a.y)
                } return a
            }
        }, midPoint: { configurable: !0, get: function () { this.bj(); return this.computeMidPoint(new J) } }, midAngle: {
            configurable: !0,
            enumerable: !0, get: function () { this.bj(); return this.computeMidAngle() }
        }, flattenedLengths: { configurable: !0, get: function () { if (null === this.wr) { this.Mc || np(this); for (var a = this.wr = [], b = this.pointsCount, c = 0; c < b - 1; c++) { var d = this.i(c); var e = this.i(c + 1); K.da(d.x, e.x) ? (d = e.y - d.y, 0 > d && (d = -d)) : K.da(d.y, e.y) ? (d = e.x - d.x, 0 > d && (d = -d)) : d = Math.sqrt(d.Ee(e)); a.push(d) } } return this.wr } }, flattenedTotalLength: {
            configurable: !0, get: function () {
                var a = this.fu; if (isNaN(a)) {
                    for (var b = this.flattenedLengths,
                        c = b.length, d = a = 0; d < c; d++)a += b[d]; this.fu = a
                } return a
            }
        }, points: {
            configurable: !0, get: function () { return this.yb }, set: function (a) {
                var b = this.yb; if (b !== a) {
                    var c = null; if (Array.isArray(a)) {
                        var d = 0 === a.length % 2; if (d) for (var e = 0; e < a.length; e++)if ("number" !== typeof a[e] || isNaN(a[e])) { d = !1; break } if (d) for (c = new F, d = 0; d < a.length / 2; d++)e = (new J(a[2 * d], a[2 * d + 1])).freeze(), c.add(e); else {
                            d = !0; for (e = 0; e < a.length; e++) {
                                var f = a[e]; if (!Ia(f) || "number" !== typeof f.x || isNaN(f.x) || "number" !== typeof f.y || isNaN(f.y)) {
                                    d =
                                    !1; break
                                }
                            } if (d) for (c = new F, d = 0; d < a.length; d++)e = a[d], c.add((new J(e.x, e.y)).freeze()); else E && v("Link.points array must contain only an even number of numbers or objects with x and y properties, not: " + a)
                        }
                    } else if (a instanceof F) for (c = a.copy(), a = c.iterator; a.next();)a.value.freeze(); else v("Link.points value is not an instance of List or Array: " + a); c.freeze(); this.yb = c; this.cc(); this.v(); np(this); a = this.diagram; null !== a && (a.Ti || a.undoManager.isUndoingRedoing || a.lt.add(this), a.animationManager.sb &&
                        (this.bh = c)); this.g("points", b, c)
                }
            }
        }, pointsCount: { configurable: !0, get: function () { return this.yb.count } }, Mc: { configurable: !0, get: function () { return 0 !== (this.Va & 16) }, set: function (a) { 0 !== (this.Va & 16) !== a && (this.Va ^= 16) } }, suspendsRouting: { configurable: !0, get: function () { return 0 !== (this.Va & 32) }, set: function (a) { 0 !== (this.Va & 32) !== a && (this.Va ^= 32) } }, Uu: {
            configurable: !0, get: function () { return 0 !== (this.Va & 64) }, set: function (a) {
            0 !== (this.Va & 64) !== a && (this.Va ^=
                64)
            }
        }, defaultFromPoint: { configurable: !0, get: function () { return this.w }, set: function (a) { this.w = a.copy() } }, defaultToPoint: { configurable: !0, get: function () { return this.L }, set: function (a) { this.L = a.copy() } }, isOrthogonal: { configurable: !0, get: function () { return 2 === (this.Ij.value & 2) } }, isAvoiding: { configurable: !0, get: function () { return 4 === (this.Ij.value & 4) } }, geometry: {
            configurable: !0, get: function () {
            this.Un && (this.bj(), this.sa = this.makeGeometry());
                return this.sa
            }
        }, firstPickIndex: { configurable: !0, get: function () { return 2 >= this.pointsCount ? 0 : this.isOrthogonal || !pp(this.computeSpot(!0)) ? 1 : 0 } }, lastPickIndex: { configurable: !0, get: function () { var a = this.pointsCount; return 0 === a ? 0 : 2 >= a ? a - 1 : this.isOrthogonal || !pp(this.computeSpot(!1)) ? a - 2 : a - 1 } }, adjusting: { configurable: !0, get: function () { return this.Pm }, set: function (a) { var b = this.Pm; b !== a && (E && tb(a, Q, Q, "adjusting"), this.Pm = a, this.g("adjusting", b, a)) } }, corner: {
            configurable: !0,
            enumerable: !0, get: function () { return this.ln }, set: function (a) { var b = this.ln; b !== a && (E && z(a, "number", Q, "corner"), this.ln = a, this.cc(), this.g("corner", b, a)) }
        }, curve: { configurable: !0, get: function () { return this.on }, set: function (a) { var b = this.on; b !== a && (E && tb(a, Q, Q, "curve"), this.on = a, this.Ta(), this.cc(), op(this, b === bh || b === ah || a === bh || a === ah), this.g("curve", b, a)) } }, curviness: {
            configurable: !0, get: function () { return this.pn }, set: function (a) {
                var b = this.pn; b !== a && (E && z(a, "number",
                    Q, "curviness"), this.pn = a, this.Ta(), this.cc(), this.g("curviness", b, a))
            }
        }, routing: { configurable: !0, get: function () { return this.Ij }, set: function (a) { var b = this.Ij; b !== a && (E && tb(a, Q, Q, "routing"), this.Ij = a, this.Jf = null, this.Ta(), op(this, 2 === (b.value & 2) || 2 === (a.value & 2)), this.g("routing", b, a)) } }, smoothness: { configurable: !0, get: function () { return this.xp }, set: function (a) { var b = this.xp; b !== a && (E && z(a, "number", Q, "smoothness"), this.xp = a, this.cc(), this.g("smoothness", b, a)) } }, key: {
            configurable: !0,
            enumerable: !0, get: function () { var a = this.diagram; if (null !== a && a.model.im()) return a.model.kc(this.data) }
        }
    }); Q.prototype.invalidateOtherJumpOvers = Q.prototype.jq; Q.prototype.findClosestSegment = Q.prototype.Ry; Q.prototype.updateRoute = Q.prototype.bj; Q.prototype.invalidateRoute = Q.prototype.Ta; Q.prototype.rollbackRoute = Q.prototype.Hx; Q.prototype.commitRoute = Q.prototype.nf; Q.prototype.startRoute = Q.prototype.Dh; Q.prototype.clearPoints = Q.prototype.Xj; Q.prototype.removePoint = Q.prototype.Gv;
    Q.prototype.addPointAt = Q.prototype.mf; Q.prototype.addPoint = Q.prototype.Be; Q.prototype.insertPointAt = Q.prototype.m; Q.prototype.insertPoint = Q.prototype.yz; Q.prototype.setPointAt = Q.prototype.N; Q.prototype.setPoint = Q.prototype.ld; Q.prototype.getPoint = Q.prototype.i; Q.prototype.getOtherPort = Q.prototype.nz; Q.prototype.getOtherNode = Q.prototype.bt;
    var ep = new D(Q, "Normal", 1), Kp = new D(Q, "Orthogonal", 2), Lp = new D(Q, "AvoidsNodes", 6), up = new D(Q, "AvoidsNodesStraight", 7), ch = new D(Q, "None", 0), fh = new D(Q, "Bezier", 9), bh = new D(Q, "JumpGap", 10), ah = new D(Q, "JumpOver", 11), fp = new D(Q, "End", 17), gp = new D(Q, "Scale", 18), hp = new D(Q, "Stretch", 19), Ln = new D(Q, "OrientAlong", 21), Um = new D(Q, "OrientPlus90", 22), Wm = new D(Q, "OrientMinus90", 23), ip = new D(Q, "OrientOpposite", 24), jp = new D(Q, "OrientUpright", 25), Vm = new D(Q, "OrientPlus90Upright", 26), Xm = new D(Q, "OrientMinus90Upright",
        27), Ym = new D(Q, "OrientUpright45", 28); Q.className = "Link"; Q.Normal = ep; Q.Orthogonal = Kp; Q.AvoidsNodes = Lp; Q.AvoidsNodesStraight = up; Q.None = ch; Q.Bezier = fh; Q.JumpGap = bh; Q.JumpOver = ah; Q.End = fp; Q.Scale = gp; Q.Stretch = hp; Q.OrientAlong = Ln; Q.OrientPlus90 = Um; Q.OrientMinus90 = Wm; Q.OrientOpposite = ip; Q.OrientUpright = jp; Q.OrientPlus90Upright = Vm; Q.OrientMinus90Upright = Xm; Q.OrientUpright45 = Ym; function Jp(a, b, c, d) { qb(this); this.ke = this.Hr = !1; this.ot = a; this.Cx = b; this.vv = c; this.Ex = d; this.links = [] }
    Jp.prototype.gm = function () { if (!this.Hr) { var a = this.links; 0 < a.length && (a = a[0].diagram, null !== a && (a.Ew.add(this), this.ke = a.undoManager.isUndoingRedoing)) } this.Hr = !0 }; Jp.prototype.ew = function () { if (this.Hr) { this.Hr = !1; var a = this.links; if (0 < a.length) { var b = a[0], c = b.diagram; c = null === c || c.Ti && !this.ke; this.ke = !1; b.arrangeBundledLinks(a, c); 1 === a.length && (b.Af = null, a.length = 0) } 0 === a.length && (a = this.ot, null !== this && null !== a.Ne && a.Ne.remove(this), a = this.vv, null !== this && null !== a.Ne && a.Ne.remove(this)) } };
    Jp.className = "LinkBundle"; function Ak() { qb(this); this.Qx = this.group = null; this.ft = !0; this.abort = !1; this.Md = this.Ld = 1; this.qo = this.po = -1; this.mc = this.lc = 8; this.Eb = [[]]; this.Qj = this.Pj = 0; this.iA = !1; this.cA = 22; this.Gz = 111 }
    Ak.prototype.initialize = function (a) {
        if (!(0 >= a.width || 0 >= a.height)) {
            var b = a.y, c = a.x + a.width, d = a.y + a.height; this.Ld = Math.floor((a.x - this.lc) / this.lc) * this.lc; this.Md = Math.floor((b - this.mc) / this.mc) * this.mc; this.po = Math.ceil((c + 2 * this.lc) / this.lc) * this.lc; this.qo = Math.ceil((d + 2 * this.mc) / this.mc) * this.mc; a = 1 + (Math.ceil((this.po - this.Ld) / this.lc) | 0); b = 1 + (Math.ceil((this.qo - this.Md) / this.mc) | 0); if (null === this.Eb || this.Pj < a - 1 || this.Qj < b - 1) { c = []; for (d = 0; d <= a; d++)c[d] = []; this.Eb = c; this.Pj = a - 1; this.Qj = b - 1 } a =
                Mp; if (null !== this.Eb) for (b = 0; b <= this.Pj; b++)for (c = 0; c <= this.Qj; c++)this.Eb[b][c] = a
        }
    }; function vp(a, b, c) { return a.Ld <= b && b <= a.po && a.Md <= c && c <= a.qo } function xp(a, b, c) { if (!vp(a, b, c)) return Mp; b -= a.Ld; b /= a.lc; c -= a.Md; c /= a.mc; return a.Eb[b | 0][c | 0] } function Dk(a, b, c) { vp(a, b, c) && (b -= a.Ld, b /= a.lc, c -= a.Md, c /= a.mc, a.Eb[b | 0][c | 0] = zp) } function Ck(a) { if (null !== a.Eb) for (var b = 0; b <= a.Pj; b++)for (var c = 0; c <= a.Qj; c++)a.Eb[b][c] >= Bp && (a.Eb[b][c] = Mp) }
    Ak.prototype.ik = function (a, b, c, d) { if (a > this.po || a + c < this.Ld || b > this.qo || b + d < this.Md) return !0; a = (a - this.Ld) / this.lc | 0; b = (b - this.Md) / this.mc | 0; c = Math.max(0, c) / this.lc + 1 | 0; var e = Math.max(0, d) / this.mc + 1 | 0; 0 > a && (c += a, a = 0); 0 > b && (e += b, b = 0); if (0 > c || 0 > e) return !0; d = Math.min(a + c - 1, this.Pj) | 0; for (c = Math.min(b + e - 1, this.Qj) | 0; a <= d; a++)for (e = b; e <= c; e++)if (this.Eb[a][e] === zp) return !1; return !0 };
    function Np(a, b, c, d, e, f, g, h, k) {
        if (!(b < f || b > g || c < h || c > k)) {
            var l = b | 0; var m = c | 0; var n = a.Eb[l][m]; if (n >= Bp && n < yp) for (e ? m += d : l += d, n += 1; f <= l && l <= g && h <= m && m <= k && !(n >= a.Eb[l][m]);)a.Eb[l][m] = n, n += 1, e ? m += d : l += d; l = e ? m : l; if (e) if (0 < d) for (c += d; c < l; c += d)Np(a, b, c, 1, !e, f, g, h, k), Np(a, b, c, -1, !e, f, g, h, k); else for (c += d; c > l; c += d)Np(a, b, c, 1, !e, f, g, h, k), Np(a, b, c, -1, !e, f, g, h, k); else if (0 < d) for (b += d; b < l; b += d)Np(a, b, c, 1, !e, f, g, h, k), Np(a, b, c, -1, !e, f, g, h, k); else for (b += d; b > l; b += d)Np(a, b, c, 1, !e, f, g, h, k), Np(a, b, c, -1, !e, f, g, h,
                k)
        }
    } function Op(a, b, c, d, e, f, g, h, k) { b |= 0; c |= 0; var l = zp, m = Bp; for (a.Eb[b][c] = m; l === zp && b > f && b < g && c > h && c < k;)m += 1, a.Eb[b][c] = m, e ? c += d : b += d, l = a.Eb[b][c] } function Pp(a, b, c, d, e, f, g, h, k) { b |= 0; c |= 0; var l = zp, m = yp; for (a.Eb[b][c] = m; l === zp && b > f && b < g && c > h && c < k;)a.Eb[b][c] = m, e ? c += d : b += d, l = a.Eb[b][c] }
    function wp(a, b, c, d, e, f) {
        if (null !== a.Eb) {
        a.abort = !1; var g = b.x, h = b.y; if (vp(a, g, h) && (g -= a.Ld, g /= a.lc, h -= a.Md, h /= a.mc, b = d.x, d = d.y, vp(a, b, d))) if (b -= a.Ld, b /= a.lc, d -= a.Md, d /= a.mc, 1 >= Math.abs(g - b) && 1 >= Math.abs(h - d)) a.abort = !0; else {
            var k = f.x, l = f.y, m = f.x + f.width, n = f.y + f.height; k -= a.Ld; k /= a.lc; l -= a.Md; l /= a.mc; m -= a.Ld; m /= a.lc; n -= a.Md; n /= a.mc; f = Math.max(0, Math.min(a.Pj, k | 0)); m = Math.min(a.Pj, Math.max(0, m | 0)); l = Math.max(0, Math.min(a.Qj, l | 0)); n = Math.min(a.Qj, Math.max(0, n | 0)); g |= 0; h |= 0; b |= 0; d |= 0; k = 0 === c || 90 === c ?
                1 : -1; c = 90 === c || 270 === c; a.Eb[g][h] === zp ? (Op(a, g, h, k, c, f, m, l, n), Op(a, g, h, 1, !c, f, m, l, n), Op(a, g, h, -1, !c, f, m, l, n)) : Op(a, g, h, k, c, g, h, g, h); a.Eb[b][d] === zp ? (Pp(a, b, d, 0 === e || 90 === e ? 1 : -1, 90 === e || 270 === e, f, m, l, n), Pp(a, b, d, 1, !(90 === e || 270 === e), f, m, l, n), Pp(a, b, d, -1, !(90 === e || 270 === e), f, m, l, n)) : Pp(a, b, d, k, c, b, d, b, d); a.abort || (Np(a, g, h, 1, !1, f, m, l, n), Np(a, g, h, -1, !1, f, m, l, n), Np(a, g, h, 1, !0, f, m, l, n), Np(a, g, h, -1, !0, f, m, l, n))
        }
        }
    }
    na.Object.defineProperties(Ak.prototype, { bounds: { configurable: !0, get: function () { return new L(this.Ld, this.Md, this.po - this.Ld, this.qo - this.Md) } }, Yl: { configurable: !0, get: function () { return this.lc }, set: function (a) { 0 < a && a !== this.lc && (this.lc = a, this.initialize(this.bounds)) } }, Xl: { configurable: !0, get: function () { return this.mc }, set: function (a) { 0 < a && a !== this.mc && (this.mc = a, this.initialize(this.bounds)) } } }); var zp = 0, Bp = 1, yp = 999999, Mp = yp + 1; Ak.className = "PositionArray";
    function sp() { qb(this); this.port = this.node = null; this.Yd = []; this.pq = !1 } sp.prototype.toString = function () { for (var a = this.Yd, b = this.node.toString() + " " + a.length.toString() + ":", c = 0; c < a.length; c++) { var d = a[c]; null !== d && (b += "\n  " + d.toString()) } return b };
    function Qp(a, b, c, d) {
        b = b.offsetY; switch (b) { case 8: return 90; case 2: return 180; case 1: return 270; case 4: return 0 }switch (b) { case 9: return 180 < c ? 270 : 90; case 6: return 90 < c && 270 >= c ? 180 : 0 }a = 180 * Math.atan2(a.height, a.width) / Math.PI; switch (b) {
            case 3: return c > a && c <= 180 + a ? 180 : 270; case 5: return c > 180 - a && c <= 360 - a ? 270 : 0; case 12: return c > a && c <= 180 + a ? 90 : 0; case 10: return c > 180 - a && c <= 360 - a ? 180 : 90; case 7: return 90 < c && c <= 180 + a ? 180 : c > 180 + a && c <= 360 - a ? 270 : 0; case 13: return 180 < c && c <= 360 - a ? 270 : c > a && 180 >= c ? 90 : 0; case 14: return c >
                a && c <= 180 - a ? 90 : c > 180 - a && 270 >= c ? 180 : 0; case 11: return c > 180 - a && c <= 180 + a ? 180 : c > 180 + a ? 270 : 90
        }d && 15 !== b && (c -= 15, 0 > c && (c += 360)); return c > a && c < 180 - a ? 90 : c >= 180 - a && c <= 180 + a ? 180 : c > 180 + a && c < 360 - a ? 270 : 0
    } sp.prototype.gm = function () { this.Yd.length = 0 };
    function tp(a, b) {
        var c = a.Yd; if (0 === c.length) {
            a: if (!a.pq) {
                c = a.pq; a.pq = !0; var d = null, e = a.node; e = e instanceof xg ? e : null; if (null === e || e.isSubGraphExpanded) var f = a.node.dv(a.port.portId); else { if (!e.actualBounds.o()) { a.pq = c; break a } d = e; f = d.cv() } var g = a.Yd.length = 0, h = a.port.oa(fd, J.alloc()), k = a.port.oa(ud, J.alloc()); e = L.allocAt(h.x, h.y, 0, 0); e.Le(k); J.free(h); J.free(k); h = J.allocAt(e.x + e.width / 2, e.y + e.height / 2); k = a.port.Ni(); for (f = f.iterator; f.next();) {
                    var l = f.value; if (l.isVisible() && l.fromPort !== l.toPort) {
                        var m =
                            l.fromPort === a.port || null !== l.fromNode && l.fromNode.Xd(d), n = l.computeSpot(m, a.port); if (n.tf() && (m = m ? l.toPort : l.fromPort, null !== m)) { var p = m.part; if (null !== p) { var q = p.findVisibleNode(); null !== q && q !== p && (p = q, m = p.port); m = l.computeOtherPoint(p, m); p = h.Xa(m); p -= k; 0 > p && (p += 360); n = Qp(e, n, p, l.isOrthogonal); 0 === n ? (n = 4, 180 < p && (p -= 360)) : n = 90 === n ? 8 : 180 === n ? 2 : 1; q = a.Yd[g]; void 0 === q ? (q = new Rp(l, p, n), a.Yd[g] = q) : (q.link = l, q.angle = p, q.Ac = n); q.zv.set(m); g++ } }
                    }
                } J.free(h); a.Yd.sort(sp.prototype.l); k = a.Yd.length; d = -1; for (g =
                    h = 0; g < k; g++)f = a.Yd[g], void 0 !== f && (f.Ac !== d && (d = f.Ac, h = 0), f.gq = h, h++); d = -1; h = 0; for (g = k - 1; 0 <= g; g--)k = a.Yd[g], void 0 !== k && (k.Ac !== d && (d = k.Ac, h = k.gq + 1), k.$l = h); g = a.Yd; n = a.port; d = a.node.portSpreading; h = J.alloc(); k = J.alloc(); f = J.alloc(); l = J.alloc(); n.oa(fd, h); n.oa(hd, k); n.oa(ud, f); n.oa(sd, l); q = p = m = n = 0; if (d === bp) for (var r = 0; r < g.length; r++) { var u = g[r]; if (null !== u) { var x = u.link.computeThickness(); switch (u.Ac) { case 8: p += x; break; case 2: q += x; break; case 1: n += x; break; default: case 4: m += x } } } var y = r = 0, A = 1, C = u = 0;
                for (x = 0; x < g.length; x++) {
                    var G = g[x]; if (null !== G) {
                        if (r !== G.Ac) { r = G.Ac; switch (r) { case 8: var H = f; y = l; break; case 2: H = l; y = h; break; case 1: H = h; y = k; break; default: case 4: H = k, y = f }u = y.x - H.x; C = y.y - H.y; switch (r) { case 8: p > Math.abs(u) ? (A = Math.abs(u) / p, p = Math.abs(u)) : A = 1; break; case 2: q > Math.abs(C) ? (A = Math.abs(C) / q, q = Math.abs(C)) : A = 1; break; case 1: n > Math.abs(u) ? (A = Math.abs(u) / n, n = Math.abs(u)) : A = 1; break; default: case 4: m > Math.abs(C) ? (A = Math.abs(C) / m, m = Math.abs(C)) : A = 1 }y = 0 } var O = G.nq; if (d === bp) {
                            G = G.link.computeThickness();
                            G *= A; O.set(H); switch (r) { case 8: O.x = H.x + u / 2 + p / 2 - y - G / 2; break; case 2: O.y = H.y + C / 2 + q / 2 - y - G / 2; break; case 1: O.x = H.x + u / 2 - n / 2 + y + G / 2; break; default: case 4: O.y = H.y + C / 2 - m / 2 + y + G / 2 }y += G
                        } else { var S = .5; d === Po && (S = (G.gq + 1) / (G.$l + 1)); O.x = H.x + u * S; O.y = H.y + C * S }
                    }
                } J.free(h); J.free(k); J.free(f); J.free(l); H = a.Yd; for (g = 0; g < H.length; g++)d = H[g], null !== d && (d.av = a.computeEndSegmentLength(d)); a.pq = c; L.free(e)
            } c = a.Yd
        } for (a = 0; a < c.length; a++)if (e = c[a], null !== e && e.link === b) return e; return null
    }
    sp.prototype.l = function (a, b) { return a === b ? 0 : null === a ? -1 : null === b ? 1 : a.Ac < b.Ac ? -1 : a.Ac > b.Ac ? 1 : a.angle < b.angle ? -1 : a.angle > b.angle ? 1 : 0 }; sp.prototype.computeEndSegmentLength = function (a) { var b = a.link, c = b.computeEndSegmentLength(this.node, this.port, ed, b.fromPort === this.port), d = a.gq; if (0 > d) return c; var e = a.$l; if (1 >= e || !b.isOrthogonal) return c; b = a.zv; var f = a.nq; if (2 === a.Ac || 8 === a.Ac) d = e - 1 - d; return ((a = 2 === a.Ac || 4 === a.Ac) ? b.y < f.y : b.x < f.x) ? c + 8 * d : (a ? b.y === f.y : b.x === f.x) ? c : c + 8 * (e - 1 - d) }; sp.className = "Knot";
    function Rp(a, b, c) { this.link = a; this.angle = b; this.Ac = c; this.zv = new J; this.$l = this.gq = 0; this.nq = new J; this.av = 0 } Rp.prototype.toString = function () { return this.link.toString() + " " + this.angle.toString() + " " + this.Ac.toString() + ":" + this.gq.toString() + "/" + this.$l.toString() + " " + this.nq.toString() + " " + this.av.toString() + " " + this.zv.toString() }; Rp.className = "LinkInfo"; function jl() { this.nh = this.Og = Qd; this.mh = this.Ng = this.lh = this.Mg = NaN; this.Gp = this.Hn = null; this.Hp = this.In = Infinity }
    jl.prototype.copy = function () { var a = new jl; a.Og = this.Og.J(); a.nh = this.nh.J(); a.Mg = this.Mg; a.lh = this.lh; a.Ng = this.Ng; a.mh = this.mh; a.Hn = this.Hn; a.Gp = this.Gp; a.In = this.In; a.Hp = this.Hp; return a }; jl.className = "LinkSettings"; function Ni() { 0 < arguments.length && Da(Ni); qb(this); this.L = this.D = null; this.Sg = this.Wn = !0; this.bo = !1; this.Um = (new J(0, 0)).freeze(); this.Zn = !0; this.Yn = null; this.yw = ""; this.w = null; this.ao = !1; this.l = null }
    Ni.prototype.cloneProtected = function (a) { a.Wn = this.Wn; a.Sg = this.Sg; a.bo = this.bo; a.Um.assign(this.Um); a.Zn = this.Zn; a.Yn = this.Yn; a.yw = this.yw; a.ao = !0 }; Ni.prototype.copy = function () { var a = new this.constructor; this.cloneProtected(a); return a }; Ni.prototype.hb = function (a) { Fa(this, a) }; Ni.prototype.toString = function () { var a = Va(this.constructor); a += "("; null !== this.group && (a += " in " + this.group); null !== this.diagram && (a += " for " + this.diagram); return a + ")" };
    Ni.prototype.C = function () { if (this.isValidLayout) { var a = this.diagram; if (null !== a && !a.undoManager.isUndoingRedoing) { var b = a.animationManager; !b.isTicking && (b.isAnimating && b.xd(), this.isOngoing && a.Ti || this.isInitial && !a.Ti) && (this.isValidLayout = !1, a.ec()) } } }; Ni.prototype.createNetwork = function () { return new Sp(this) }; Ni.prototype.makeNetwork = function (a) { var b = this.createNetwork(); a instanceof P ? (b.ng(a.nodes, !0), b.ng(a.links, !0)) : a instanceof xg ? b.ng(a.memberParts) : b.ng(a.iterator); return b };
    Ni.prototype.updateParts = function () { var a = this.diagram; if (null === a && null !== this.network) for (var b = this.network.vertexes.iterator; b.next();) { var c = b.value.node; if (null !== c && (a = c.diagram, null !== a)) break } this.isValidLayout = !0; try { null !== a && a.Ca("Layout"), this.commitLayout() } finally { null !== a && a.ab("Layout") } }; Ni.prototype.commitLayout = function () { if (null !== this.network) { for (var a = this.network.vertexes.iterator; a.next();)a.value.commit(); if (this.isRouting) for (a = this.network.edges.iterator; a.next();)a.value.commit() } };
    Ni.prototype.doLayout = function (a) {
    E && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"); var b = new I; a instanceof P ? (Tp(this, b, a.nodes, !0, this.rk, !0, !1, !0), Tp(this, b, a.parts, !0, this.rk, !0, !1, !0)) : a instanceof xg ? Tp(this, b, a.memberParts, !1, this.rk, !0, !1, !0) : b.addAll(a.iterator); var c = b.count; if (0 < c) {
        a = this.diagram; null !== a && a.Ca("Layout"); c = Math.ceil(Math.sqrt(c)); this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin); var d =
            this.arrangementOrigin.x, e = d, f = this.arrangementOrigin.y, g = 0, h = 0; for (b = b.iterator; b.next();) { var k = b.value; Up(k); var l = k.measuredBounds, m = l.width; l = l.height; k.moveTo(e, f); k instanceof xg && (k.rk = !1); e += Math.max(m, 50) + 20; h = Math.max(h, Math.max(l, 50)); g >= c - 1 ? (g = 0, e = d, f += h + 20, h = 0) : g++ } null !== a && a.ab("Layout")
    } this.isValidLayout = !0
    }; Ni.prototype.rk = function (a) { return !a.location.o() || a instanceof xg && a.rk ? !0 : !1 };
    function Tp(a, b, c, d, e, f, g, h) { for (c = c.iterator; c.next();) { var k = c.value; d && !k.isTopLevel || null !== e && !e(k) || !k.canLayout() || (f && k instanceof V ? k.isLinkLabel || (k instanceof xg ? null === k.layout ? Tp(a, b, k.memberParts, !1, e, f, g, h) : (Up(k), b.add(k)) : (Up(k), b.add(k))) : g && k instanceof Q ? b.add(k) : !h || !k.dc() || k instanceof V || (Up(k), b.add(k))) } } function Up(a) { var b = a.actualBounds; (0 === b.width || 0 === b.height || isNaN(b.width) || isNaN(b.height)) && a.bc() }
    Ni.prototype.Pi = function (a, b) { var c = this.boundsComputation; if (null !== c) return b || (b = new L), c(a, this, b); if (!b) return a.actualBounds; b.set(a.actualBounds); return b }; Ni.prototype.ax = function (a) { var b = new I; a instanceof P ? (Tp(this, b, a.nodes, !0, null, !0, !0, !0), Tp(this, b, a.links, !0, null, !0, !0, !0), Tp(this, b, a.parts, !0, null, !0, !0, !0)) : a instanceof xg ? Tp(this, b, a.memberParts, !1, null, !0, !0, !0) : Tp(this, b, a.iterator, !1, null, !0, !0, !0); return b };
    Ni.prototype.initialOrigin = function (a) { var b = this.group; if (null !== b) { var c = b.position.copy(); (isNaN(c.x) || isNaN(c.y)) && c.set(a); b = b.placeholder; null !== b && (c = b.oa(fd), (isNaN(c.x) || isNaN(c.y)) && c.set(a), a = b.padding, c.x += a.left, c.y += a.top); return c } return a };
    na.Object.defineProperties(Ni.prototype, {
        diagram: { configurable: !0, get: function () { return this.D }, set: function (a) { null !== a && w(a, P, Ni, "diagram"); this.D = a } }, group: { configurable: !0, get: function () { return this.L }, set: function (a) { this.L !== a && (null !== a && w(a, xg, Ni, "group"), this.L = a, null !== a && (this.D = a.diagram)) } }, isOngoing: { configurable: !0, get: function () { return this.Wn }, set: function (a) { this.Wn !== a && (z(a, "boolean", Ni, "isOngoing"), this.Wn = a) } }, isInitial: {
            configurable: !0,
            enumerable: !0, get: function () { return this.Sg }, set: function (a) { z(a, "boolean", Ni, "isInitial"); this.Sg = a; a || (this.ao = !0) }
        }, isViewportSized: { configurable: !0, get: function () { return this.bo }, set: function (a) { this.bo !== a && (z(a, "boolean", Ni, "isViewportSized"), (this.bo = a) && this.C()) } }, isRouting: { configurable: !0, get: function () { return this.Zn }, set: function (a) { this.Zn !== a && (z(a, "boolean", Ni, "isRouting"), this.Zn = a) } }, isRealtime: {
            configurable: !0, get: function () { return this.Yn },
            set: function (a) { this.Yn !== a && (null !== a && z(a, "boolean", Ni, "isRealtime"), this.Yn = a) }
        }, isValidLayout: { configurable: !0, get: function () { return this.ao }, set: function (a) { this.ao !== a && (z(a, "boolean", Ni, "isValidLayout"), this.ao = a, a || (a = this.diagram, null !== a && (a.Cg = !0))) } }, network: { configurable: !0, get: function () { return this.l }, set: function (a) { this.l !== a && (null !== a && w(a, Sp, Ni, "network"), this.l = a, null !== a && (a.layout = this)) } }, boundsComputation: {
            configurable: !0, get: function () { return this.w },
            set: function (a) { this.w !== a && (null !== a && z(a, "function", Ni, "boundsComputation"), this.w = a, this.C()) }
        }, arrangementOrigin: { configurable: !0, get: function () { return this.Um }, set: function (a) { w(a, J, Ni, "arrangementOrigin"); this.Um.A(a) || (this.Um.assign(a), this.C()) } }
    }); Ni.prototype.collectParts = Ni.prototype.ax; Ni.prototype.getLayoutBounds = Ni.prototype.Pi; Ni.prototype.invalidateLayout = Ni.prototype.C; Ni.className = "Layout";
    function Sp(a) { qb(this); E && !a && v("LayoutNetwork constructor requires non-null Layout argument"); this.ic = a; this.kf = new I; this.ge = new I; this.pt = new Ub; this.kt = new Ub } Sp.prototype.clear = function () { if (this.kf) for (var a = this.kf.iterator; a.next();)a.value.clear(); if (this.ge) for (a = this.ge.iterator; a.next();)a.value.clear(); this.kf = new I; this.ge = new I; this.pt = new Ub; this.kt = new Ub };
    Sp.prototype.toString = function (a) { void 0 === a && (a = 0); var b = "LayoutNetwork" + (null !== this.layout ? "(" + this.layout.toString() + ")" : ""); if (0 >= a) return b; b += " vertexes: " + this.kf.count + " edges: " + this.ge.count; if (1 < a) { for (var c = this.kf.iterator; c.next();)b += "\n    " + c.value.toString(a - 1); for (c = this.ge.iterator; c.next();)b += "\n    " + c.value.toString(a - 1) } return b }; Sp.prototype.createVertex = function () { return new Vp(this) }; Sp.prototype.createEdge = function () { return new Wp(this) };
    Sp.prototype.ng = function (a, b, c) {
        if (null !== a) {
        void 0 === b && (b = !1); z(b, "boolean", Sp, "addParts:toplevelonly"); void 0 === c && (c = null); null === c && (c = function (a) { if (a instanceof V) return !a.isLinkLabel; if (a instanceof Q) { var b = a.fromNode; if (null === b || b.isLinkLabel) return !1; a = a.toNode; return null === a || a.isLinkLabel ? !1 : !0 } return !1 }); for (a = a.iterator; a.next();) {
            var d = a.value; if (d instanceof V && (!b || d.isTopLevel) && d.canLayout() && c(d)) if (d instanceof xg && null === d.layout) this.ng(d.memberParts, !1); else if (null === this.Mi(d)) {
                var e =
                    this.createVertex(); e.node = d; this.th(e)
            }
        } for (a.reset(); a.next();)if (d = a.value, d instanceof Q && (!b || d.isTopLevel) && d.canLayout() && c(d) && null === this.$p(d)) { var f = d.fromNode; e = d.toNode; null !== f && null !== e && f !== e && (f = this.findGroupVertex(f), e = this.findGroupVertex(e), null !== f && null !== e && this.jk(f, e, d)) }
        }
    };
    Sp.prototype.findGroupVertex = function (a) { if (null === a) return null; var b = a.findVisibleNode(); if (null === b) return null; a = this.Mi(b); if (null !== a) return a; for (b = b.containingGroup; null !== b;) { a = this.Mi(b); if (null !== a) return a; b = b.containingGroup } return null }; t = Sp.prototype; t.th = function (a) { if (null !== a) { E && w(a, Vp, Sp, "addVertex:vertex"); this.kf.add(a); var b = a.node; null !== b && this.pt.add(b, a); a.network = this } };
    t.Vl = function (a) { if (null === a) return null; E && w(a, V, Sp, "addNode:node"); var b = this.Mi(a); null === b && (b = this.createVertex(), b.node = a, this.th(b)); return b }; t.Yu = function (a) { if (null !== a && (E && w(a, Vp, Sp, "deleteVertex:vertex"), Xp(this, a))) { for (var b = a.xg, c = b.count - 1; 0 <= c; c--) { var d = b.O(c); this.ck(d) } b = a.og; for (a = b.count - 1; 0 <= a; a--)c = b.O(a), this.ck(c) } }; function Xp(a, b) { if (null === b) return !1; var c = a.kf.remove(b); c && a.pt.remove(b.node); return c }
    t.Hy = function (a) { null !== a && (E && w(a, V, Sp, "deleteNode:node"), a = this.Mi(a), null !== a && this.Yu(a)) }; t.Mi = function (a) { if (null === a) return null; E && w(a, V, Sp, "findVertex:node"); return this.pt.K(a) }; t.Sj = function (a) { if (null !== a) { E && w(a, Wp, Sp, "addEdge:edge"); this.ge.add(a); var b = a.link; null !== b && null === this.$p(b) && this.kt.add(b, a); b = a.toVertex; null !== b && b.Mu(a); b = a.fromVertex; null !== b && b.Ku(a); a.network = this } };
    t.my = function (a) { if (null === a) return null; E && w(a, Q, Sp, "addLink:link"); var b = a.fromNode, c = a.toNode, d = this.$p(a); null === d ? (d = this.createEdge(), d.link = a, null !== b && (d.fromVertex = this.Vl(b)), null !== c && (d.toVertex = this.Vl(c)), this.Sj(d)) : (null !== b ? d.fromVertex = this.Vl(b) : d.fromVertex = null, null !== c ? d.toVertex = this.Vl(c) : d.toVertex = null); return d }; t.ck = function (a) { if (null !== a) { E && w(a, Wp, Sp, "deleteEdge:edge"); var b = a.toVertex; null !== b && b.Xu(a); b = a.fromVertex; null !== b && b.Wu(a); Yp(this, a) } };
    function Yp(a, b) { null !== b && a.ge.remove(b) && a.kt.remove(b.link) } t.Gy = function (a) { null !== a && (E && w(a, Q, Sp, "deleteLink:link"), a = this.$p(a), null !== a && this.ck(a)) }; t.$p = function (a) { if (null === a) return null; E && w(a, Q, Sp, "findEdge:link"); return this.kt.K(a) };
    t.jk = function (a, b, c) { if (null === a || null === b) return null; E && (w(a, Vp, Sp, "linkVertexes:fromVertex"), w(b, Vp, Sp, "linkVertexes:toVertex"), null !== c && w(c, Q, Sp, "linkVertexes:link")); if (a.network === this && b.network === this) { var d = this.createEdge(); d.link = c; d.fromVertex = a; d.toVertex = b; this.Sj(d); return d } return null }; t.xm = function (a) { if (null !== a) { E && w(a, Wp, Sp, "reverseEdge:edge"); var b = a.fromVertex, c = a.toVertex; null !== b && null !== c && (b.Wu(a), c.Xu(a), a.xm(), b.Mu(a), c.Ku(a)) } };
    t.Xp = function () { for (var a = Qa(), b = this.ge.iterator; b.next();) { var c = b.value; c.fromVertex === c.toVertex && a.push(c) } b = a.length; for (c = 0; c < b; c++)this.ck(a[c]); Ta(a) }; Sp.prototype.deleteArtificialVertexes = function () { for (var a = Qa(), b = this.kf.iterator; b.next();) { var c = b.value; null === c.node && a.push(c) } c = a.length; for (b = 0; b < c; b++)this.Yu(a[b]); b = Qa(); for (c = this.ge.iterator; c.next();) { var d = c.value; null === d.link && b.push(d) } c = b.length; for (d = 0; d < c; d++)this.ck(b[d]); Ta(a); Ta(b) };
    function Zp(a) { for (var b = Qa(), c = a.ge.iterator; c.next();) { var d = c.value; null !== d.fromVertex && null !== d.toVertex || b.push(d) } c = b.length; for (d = 0; d < c; d++)a.ck(b[d]); Ta(b) }
    Sp.prototype.Rx = function () { this.deleteArtificialVertexes(); Zp(this); this.Xp(); for (var a = new F, b = !0; b;) { b = !1; for (var c = this.kf.iterator; c.next();) { var d = c.value; if (0 < d.xg.count || 0 < d.og.count) { b = this.layout.createNetwork(); a.add(b); $p(this, b, d); b = !0; break } } } a.sort(function (a, b) { return null === a || null === b || a === b ? 0 : b.vertexes.count - a.vertexes.count }); return a };
    function $p(a, b, c) { if (null !== c && c.network !== b) { Xp(a, c); b.th(c); for (var d = c.sourceEdges; d.next();) { var e = d.value; e.network !== b && (Yp(a, e), b.Sj(e), $p(a, b, e.fromVertex)) } for (d = c.destinationEdges; d.next();)c = d.value, c.network !== b && (Yp(a, c), b.Sj(c), $p(a, b, c.toVertex)) } } Sp.prototype.Qy = function () { for (var a = new I, b = this.kf.iterator; b.next();)a.add(b.value.node); for (b = this.ge.iterator; b.next();)a.add(b.value.link); return a };
    na.Object.defineProperties(Sp.prototype, { layout: { configurable: !0, get: function () { return this.ic }, set: function (a) { null !== a && (this.ic = a) } }, vertexes: { configurable: !0, get: function () { return this.kf } }, edges: { configurable: !0, get: function () { return this.ge } } }); Sp.prototype.findAllParts = Sp.prototype.Qy; Sp.prototype.splitIntoSubNetworks = Sp.prototype.Rx; Sp.prototype.deleteSelfEdges = Sp.prototype.Xp; Sp.prototype.reverseEdge = Sp.prototype.xm; Sp.prototype.linkVertexes = Sp.prototype.jk;
    Sp.prototype.findEdge = Sp.prototype.$p; Sp.prototype.deleteLink = Sp.prototype.Gy; Sp.prototype.deleteEdge = Sp.prototype.ck; Sp.prototype.addLink = Sp.prototype.my; Sp.prototype.addEdge = Sp.prototype.Sj; Sp.prototype.findVertex = Sp.prototype.Mi; Sp.prototype.deleteNode = Sp.prototype.Hy; Sp.prototype.deleteVertex = Sp.prototype.Yu; Sp.prototype.addNode = Sp.prototype.Vl; Sp.prototype.addVertex = Sp.prototype.th; Sp.prototype.addParts = Sp.prototype.ng; Sp.className = "LayoutNetwork";
    function Vp(a) { qb(this); E && !a && v("LayoutVertex constructor requires non-null LayoutNetwork argument"); this.Oc = a; this.l = (new L(0, 0, 10, 10)).freeze(); this.w = (new J(5, 5)).freeze(); this.mi = this.kb = null; this.xg = new F; this.og = new F } Vp.prototype.clear = function () { this.mi = this.kb = null; this.xg = new F; this.og = new F };
    Vp.prototype.toString = function (a) { void 0 === a && (a = 0); var b = "LayoutVertex#" + Jb(this); if (0 < a && (b += null !== this.node ? "(" + this.node.toString() + ")" : "", 1 < a)) { a = ""; for (var c = !0, d = this.xg.iterator; d.next();) { var e = d.value; c ? c = !1 : a += ","; a += e.toString(0) } e = ""; c = !0; for (d = this.og.iterator; d.next();) { var f = d.value; c ? c = !1 : e += ","; e += f.toString(0) } b += " sources: " + a + " destinations: " + e } return b };
    Vp.prototype.commit = function () { var a = this.kb; if (null !== a) { var b = this.bounds, c = a.bounds; Ia(c) ? (c.x = b.x, c.y = b.y, c.width = b.width, c.height = b.height) : a.bounds = b.copy() } else if (a = this.node, null !== a) { b = this.bounds; if (!(a instanceof xg)) { c = L.alloc(); var d = this.network.layout.Pi(a, c), e = a.locationObject.oa(qd); if (d.o() && e.o()) { a.moveTo(b.x + this.focusX - (e.x - d.x), b.y + this.focusY - (e.y - d.y)); L.free(c); return } L.free(c) } a.moveTo(b.x, b.y) } };
    Vp.prototype.Mu = function (a) { null !== a && (E && w(a, Wp, Vp, "addSourceEdge:edge"), this.xg.contains(a) || this.xg.add(a)) }; Vp.prototype.Xu = function (a) { null !== a && (E && w(a, Wp, Vp, "deleteSourceEdge:edge"), this.xg.remove(a)) }; Vp.prototype.Ku = function (a) { null !== a && (E && w(a, Wp, Vp, "addDestinationEdge:edge"), this.og.contains(a) || this.og.add(a)) }; Vp.prototype.Wu = function (a) { null !== a && (E && w(a, Wp, Vp, "deleteDestinationEdge:edge"), this.og.remove(a)) };
    function aq(a, b) { E && w(a, Vp, Vp, "standardComparer:m"); E && w(b, Vp, Vp, "standardComparer:n"); a = a.mi; b = b.mi; return a ? b ? (a = a.text, b = b.text, a < b ? -1 : a > b ? 1 : 0) : 1 : null !== b ? -1 : 0 }
    na.Object.defineProperties(Vp.prototype, {
        sourceEdgesArrayAccess: { configurable: !0, get: function () { return this.xg._dataArray } }, destinationEdgesArrayAccess: { configurable: !0, get: function () { return this.og._dataArray } }, data: { configurable: !0, get: function () { return this.kb }, set: function (a) { this.kb = a; if (null !== a) { var b = a.bounds; a = b.x; var c = b.y, d = b.width; b = b.height; this.w.h(d / 2, b / 2); this.l.h(a, c, d, b) } } }, node: {
            configurable: !0, get: function () { return this.mi },
            set: function (a) { if (this.mi !== a) { E && null !== a && w(a, V, Vp, "node"); this.mi = a; a.bc(); var b = this.network.layout, c = L.alloc(), d = b.Pi(a, c); b = d.x; var e = d.y, f = d.width; d = d.height; isNaN(b) && (b = 0); isNaN(e) && (e = 0); this.l.h(b, e, f, d); L.free(c); if (!(a instanceof xg) && (a = a.locationObject.oa(qd), a.o())) { this.w.h(a.x - b, a.y - e); return } this.w.h(f / 2, d / 2) } }
        }, bounds: { configurable: !0, get: function () { return this.l }, set: function (a) { this.l.A(a) || (E && w(a, L, Vp, "bounds"), this.l.assign(a)) } }, focus: {
            configurable: !0,
            get: function () { return this.w }, set: function (a) { this.w.A(a) || (E && w(a, J, Vp, "focus"), this.w.assign(a)) }
        }, centerX: { configurable: !0, get: function () { return this.l.x + this.w.x }, set: function (a) { var b = this.l; b.x + this.w.x !== a && (E && B(a, Vp, "centerX"), b.ja(), b.x = a - this.w.x, b.freeze()) } }, centerY: { configurable: !0, get: function () { return this.l.y + this.w.y }, set: function (a) { var b = this.l; b.y + this.w.y !== a && (E && B(a, Vp, "centerY"), b.ja(), b.y = a - this.w.y, b.freeze()) } }, focusX: {
            configurable: !0,
            get: function () { return this.w.x }, set: function (a) { var b = this.w; b.x !== a && (b.ja(), b.x = a, b.freeze()) }
        }, focusY: { configurable: !0, get: function () { return this.w.y }, set: function (a) { var b = this.w; b.y !== a && (b.ja(), b.y = a, b.freeze()) } }, x: { configurable: !0, get: function () { return this.l.x }, set: function (a) { var b = this.l; b.x !== a && (b.ja(), b.x = a, b.freeze()) } }, y: { configurable: !0, get: function () { return this.l.y }, set: function (a) { var b = this.l; b.y !== a && (b.ja(), b.y = a, b.freeze()) } }, width: {
            configurable: !0,
            enumerable: !0, get: function () { return this.l.width }, set: function (a) { var b = this.l; b.width !== a && (b.ja(), b.width = a, b.freeze()) }
        }, height: { configurable: !0, get: function () { return this.l.height }, set: function (a) { var b = this.l; b.height !== a && (b.ja(), b.height = a, b.freeze()) } }, network: { configurable: !0, get: function () { return this.Oc }, set: function (a) { E && w(a, Sp, Vp, "network"); this.Oc = a } }, sourceVertexes: {
            configurable: !0, get: function () {
                for (var a = new I, b = this.sourceEdges; b.next();)a.add(b.value.fromVertex);
                return a.iterator
            }
        }, destinationVertexes: { configurable: !0, get: function () { for (var a = new I, b = this.destinationEdges; b.next();)a.add(b.value.toVertex); return a.iterator } }, vertexes: { configurable: !0, get: function () { for (var a = new I, b = this.sourceEdges; b.next();)a.add(b.value.fromVertex); for (b = this.destinationEdges; b.next();)a.add(b.value.toVertex); return a.iterator } }, sourceEdges: { configurable: !0, get: function () { return this.xg.iterator } }, destinationEdges: {
            configurable: !0,
            enumerable: !0, get: function () { return this.og.iterator }
        }, edges: { configurable: !0, get: function () { for (var a = new F, b = this.sourceEdges; b.next();)a.add(b.value); for (b = this.destinationEdges; b.next();)a.add(b.value); return a.iterator } }, edgesCount: { configurable: !0, get: function () { return this.xg.count + this.og.count } }
    }); Vp.prototype.deleteDestinationEdge = Vp.prototype.Wu; Vp.prototype.addDestinationEdge = Vp.prototype.Ku; Vp.prototype.deleteSourceEdge = Vp.prototype.Xu;
    Vp.prototype.addSourceEdge = Vp.prototype.Mu; Vp.className = "LayoutVertex"; Vp.standardComparer = aq;
    Vp.smartComparer = function (a, b) {
        E && w(a, Vp, Vp, "smartComparer:m"); E && w(b, Vp, Vp, "smartComparer:n"); if (null !== a) {
            if (null !== b) {
                a = a.mi; var c = b.mi; if (null !== a) {
                    if (null !== c) {
                        b = a.text.toLocaleLowerCase().split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/); a = c.text.toLocaleLowerCase().split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/); for (c = 0; c < b.length; c++)if ("" !== a[c] && void 0 !== a[c]) {
                            var d = parseFloat(b[c]), e = parseFloat(a[c]); if (isNaN(d)) if (isNaN(e)) { if (0 !== b[c].localeCompare(a[c])) return b[c].localeCompare(a[c]) } else return 1;
                            else { if (isNaN(e)) return -1; if (0 !== d - e) return d - e }
                        } else if ("" !== b[c]) return 1; return "" !== a[c] && void 0 !== a[c] ? -1 : 0
                    } return 1
                } return null !== c ? -1 : 0
            } return 1
        } return null !== b ? -1 : 0
    }; function Wp(a) { qb(this); E && !a && v("LayoutEdge constructor requires non-null LayoutNetwork argument"); this.Xb = a; this.ig = this.Lf = this.ql = this.kb = null } Wp.prototype.clear = function () { this.ig = this.Lf = this.ql = this.kb = null };
    Wp.prototype.toString = function (a) { void 0 === a && (a = 0); var b = "LayoutEdge#" + Jb(this); 0 < a && (b += null !== this.ql ? "(" + this.ql.toString() + ")" : "", 1 < a && (b += " " + (this.Lf ? this.Lf.toString() : "null") + " --\x3e " + (this.ig ? this.ig.toString() : "null"))); return b }; Wp.prototype.xm = function () { var a = this.Lf; this.Lf = this.ig; this.ig = a }; Wp.prototype.commit = function () { }; Wp.prototype.sx = function (a) { E && w(a, Vp, Wp, "getOtherVertex:v"); return this.ig === a ? this.Lf : this.Lf === a ? this.ig : null };
    na.Object.defineProperties(Wp.prototype, {
        network: { configurable: !0, get: function () { return this.Xb }, set: function (a) { E && w(a, Sp, Wp, "network"); this.Xb = a } }, data: { configurable: !0, get: function () { return this.kb }, set: function (a) { this.kb !== a && (E && null !== a && z(a, "object", Wp, "data"), this.kb = a) } }, link: { configurable: !0, get: function () { return this.ql }, set: function (a) { this.ql !== a && (E && null !== a && w(a, Q, Wp, "link"), this.ql = a) } }, fromVertex: {
            configurable: !0, get: function () { return this.Lf },
            set: function (a) { this.Lf !== a && (E && null !== a && w(a, Vp, Wp, "network"), this.Lf = a) }
        }, toVertex: { configurable: !0, get: function () { return this.ig }, set: function (a) { this.ig !== a && (E && null !== a && w(a, Vp, Wp, "network"), this.ig = a) } }
    }); Wp.prototype.getOtherVertex = Wp.prototype.sx; Wp.className = "LayoutEdge";
    function Sk() { 0 < arguments.length && Da(Sk); Ni.call(this); this.isViewportSized = !0; this.Np = this.Op = NaN; this.Eg = (new Zb(NaN, NaN)).freeze(); this.bf = (new Zb(10, 10)).freeze(); this.xb = bq; this.Db = cq; this.Tc = dq; this.Pc = eq } ma(Sk, Ni); Sk.prototype.cloneProtected = function (a) { Ni.prototype.cloneProtected.call(this, a); a.Op = this.Op; a.Np = this.Np; a.Eg.assign(this.Eg); a.bf.assign(this.bf); a.xb = this.xb; a.Db = this.Db; a.Tc = this.Tc; a.Pc = this.Pc };
    Sk.prototype.hb = function (a) { a.classType === Sk ? a === dq || a === fq || a === gq || a === hq ? this.sorting = a : a === cq || a === iq ? this.arrangement = a : a === bq || a === jq ? this.alignment = a : v("Unknown enum value: " + a) : Ni.prototype.hb.call(this, a) };
    Sk.prototype.doLayout = function (a) {
    E && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"); this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin); var b = this.ax(a); a = this.diagram; for (var c = b.copy().iterator; c.next();) { var d = c.value; if (!d.Ah() || null === d.fromNode && null === d.toNode) { if (d.bc(), d instanceof xg) for (d = d.memberParts; d.next();)b.remove(d.value) } else b.remove(d) } var e = b.Oa(); if (0 !== e.length) {
        switch (this.sorting) {
            case hq: e.reverse();
                break; case dq: e.sort(this.comparer); break; case fq: e.sort(this.comparer), e.reverse()
        }var f = this.wrappingColumn; isNaN(f) && (f = 0); var g = this.wrappingWidth; isNaN(g) && null !== a ? (b = a.padding, g = Math.max(a.viewportBounds.width - b.left - b.right, 0)) : g = Math.max(this.wrappingWidth, 0); 0 >= f && 0 >= g && (f = 1); b = this.spacing.width; isFinite(b) || (b = 0); c = this.spacing.height; isFinite(c) || (c = 0); null !== a && a.Ca("Layout"); d = []; switch (this.alignment) {
            case jq: var h = b, k = c, l = L.alloc(), m = Math.max(this.cellSize.width, 1); if (!isFinite(m)) for (var n =
                m = 0; n < e.length; n++) { var p = this.Pi(e[n], l); m = Math.max(m, p.width) } m = Math.max(m + h, 1); n = Math.max(this.cellSize.height, 1); if (!isFinite(n)) for (p = n = 0; p < e.length; p++) { var q = this.Pi(e[p], l); n = Math.max(n, q.height) } n = Math.max(n + k, 1); p = this.arrangement; for (var r = q = this.arrangementOrigin.x, u = this.arrangementOrigin.y, x = 0, y = 0, A = 0; A < e.length; A++) {
                    var C = e[A], G = this.Pi(C, l), H = Math.ceil((G.width + h) / m) * m, O = Math.ceil((G.height + k) / n) * n; switch (p) { case iq: var S = Math.abs(r - G.width); break; default: S = r + G.width }if (0 < f && x > f - 1 ||
                        0 < g && 0 < x && S - q > g) d.push(new L(0, u, g + h, y)), x = 0, r = q, u += y, y = 0; y = Math.max(y, O); switch (p) { case iq: G = -G.width; break; default: G = 0 }C.moveTo(r + G, u); switch (p) { case iq: r -= H; break; default: r += H }x++
                } d.push(new L(0, u, g + h, y)); L.free(l); break; case bq: k = g; m = f; n = b; p = c; g = L.alloc(); q = Math.max(this.cellSize.width, 1); f = u = l = 0; h = J.alloc(); for (r = 0; r < e.length; r++)y = e[r], x = this.Pi(y, g), y = y.rf(y.locationObject, y.locationSpot, h), l = Math.max(l, y.x), u = Math.max(u, x.width - y.x), f = Math.max(f, y.y); r = this.arrangement; switch (r) {
                    case iq: l +=
                        n; break; default: u += n
                }q = isFinite(q) ? Math.max(q + n, 1) : Math.max(l + u, 1); var T = y = this.arrangementOrigin.x; A = this.arrangementOrigin.y; u = 0; k >= l && (k -= l); l = C = 0; H = Math.max(this.cellSize.height, 1); G = f = 0; O = !0; x = J.alloc(); for (S = 0; S < e.length; S++) {
                    var ea = e[S], Z = this.Pi(ea, g), va = ea.rf(ea.locationObject, ea.locationSpot, h); if (0 < u) switch (r) {
                        case iq: T = (T - y - (Z.width - va.x)) / q; T = K.da(Math.round(T), T) ? Math.round(T) : Math.floor(T); T = T * q + y; break; default: T = (T - y + va.x) / q, T = K.da(Math.round(T), T) ? Math.round(T) : Math.ceil(T), T = T * q +
                            y
                    } else switch (r) { case iq: C = T + va.x + Z.width; break; default: C = T - va.x }switch (r) { case iq: var za = -(T + va.x) + C; break; default: za = T + Z.width - va.x - C }if (0 < m && u > m - 1 || 0 < k && 0 < u && za > k) { d.push(new L(0, O ? A - f : A, k + n, G + f + p)); for (T = 0; T < u && S !== u; T++) { za = e[S - u + T]; var U = za.rf(za.locationObject, za.locationSpot, x); za.moveTo(za.position.x, za.position.y + f - U.y) } G += p; A = O ? A + G : A + (G + f); u = G = f = 0; T = y; O = !1 } T === y && (l = r === iq ? Math.max(l, Z.width - va.x) : Math.min(l, -va.x)); f = Math.max(f, va.y); G = Math.max(G, Z.height - va.y); isFinite(H) && (G = Math.max(G,
                        Math.max(Z.height, H) - va.y)); O ? ea.moveTo(T - va.x, A - va.y) : ea.moveTo(T - va.x, A); switch (r) { case iq: T -= va.x + n; break; default: T += Z.width - va.x + n }u++
                } d.push(new L(0, A, k + n, (O ? G : G + f) + p)); if (e.length !== u) for (k = 0; k < u; k++)m = e[e.length - u + k], n = m.rf(m.locationObject, m.locationSpot, h), m.moveTo(m.position.x, m.position.y + f - n.y); J.free(h); J.free(x); if (r === iq) for (e = 0; e < d.length; e++)f = d[e], f.width += l, f.x -= l; else for (e = 0; e < d.length; e++)f = d[e], f.x > l && (f.width += f.x - l, f.x = l); L.free(g)
        }for (h = f = g = e = 0; h < d.length; h++)k = d[h], e = Math.min(e,
            k.x), g = Math.min(g, k.y), f = Math.max(f, k.x + k.width); this.arrangement === iq ? this.commitLayers(d, new J(e + b / 2 - (f + e), g - c / 2)) : this.commitLayers(d, new J(e - b / 2, g - c / 2)); null !== a && a.ab("Layout"); this.isValidLayout = !0
    }
    }; Sk.prototype.commitLayers = function () { }; function eq(a, b) { E && w(a, R, Sk, "standardComparer:a"); E && w(b, R, Sk, "standardComparer:b"); a = a.text; b = b.text; return a < b ? -1 : a > b ? 1 : 0 }
    na.Object.defineProperties(Sk.prototype, {
        wrappingWidth: { configurable: !0, get: function () { return this.Op }, set: function (a) { this.Op !== a && (z(a, "number", Sk, "wrappingWidth"), 0 < a || isNaN(a)) && (this.Op = a, this.isViewportSized = isNaN(a), this.C()) } }, wrappingColumn: { configurable: !0, get: function () { return this.Np }, set: function (a) { this.Np !== a && (z(a, "number", Sk, "wrappingColumn"), 0 < a || isNaN(a)) && (this.Np = a, this.C()) } }, cellSize: {
            configurable: !0, get: function () { return this.Eg }, set: function (a) {
                w(a,
                    Zb, Sk, "cellSize"); this.Eg.A(a) || (this.Eg.assign(a), this.C())
            }
        }, spacing: { configurable: !0, get: function () { return this.bf }, set: function (a) { w(a, Zb, Sk, "spacing"); this.bf.A(a) || (this.bf.assign(a), this.C()) } }, alignment: { configurable: !0, get: function () { return this.xb }, set: function (a) { this.xb !== a && (tb(a, Sk, Sk, "alignment"), a === bq || a === jq) && (this.xb = a, this.C()) } }, arrangement: {
            configurable: !0, get: function () { return this.Db }, set: function (a) {
            this.Db !== a && (tb(a, Sk, Sk, "arrangement"),
                a === cq || a === iq) && (this.Db = a, this.C())
            }
        }, sorting: { configurable: !0, get: function () { return this.Tc }, set: function (a) { this.Tc !== a && (tb(a, Sk, Sk, "sorting"), a === gq || a === hq || a === dq || a === fq) && (this.Tc = a, this.C()) } }, comparer: { configurable: !0, get: function () { return this.Pc }, set: function (a) { this.Pc !== a && (z(a, "function", Sk, "comparer"), this.Pc = a, this.C()) } }
    });
    var jq = new D(Sk, "Position", 0), bq = new D(Sk, "Location", 1), cq = new D(Sk, "LeftToRight", 2), iq = new D(Sk, "RightToLeft", 3), gq = new D(Sk, "Forward", 4), hq = new D(Sk, "Reverse", 5), dq = new D(Sk, "Ascending", 6), fq = new D(Sk, "Descending", 7); Sk.className = "GridLayout"; Sk.standardComparer = eq;
    Sk.smartComparer = function (a, b) {
        E && w(a, R, Sk, "standardComparer:a"); E && w(b, R, Sk, "standardComparer:b"); if (null !== a) {
            if (null !== b) {
                a = a.text.toLocaleLowerCase().split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/); b = b.text.toLocaleLowerCase().split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/); for (var c = 0; c < a.length; c++)if ("" !== b[c] && void 0 !== b[c]) {
                    var d = parseFloat(a[c]), e = parseFloat(b[c]); if (isNaN(d)) if (isNaN(e)) { if (0 !== a[c].localeCompare(b[c])) return a[c].localeCompare(b[c]) } else return 1; else {
                        if (isNaN(e)) return -1;
                        if (0 !== d - e) return d - e
                    }
                } else if ("" !== a[c]) return 1; return "" !== b[c] && void 0 !== b[c] ? -1 : 0
            } return 1
        } return null !== b ? -1 : 0
    }; Sk.Position = jq; Sk.Location = bq; Sk.LeftToRight = cq; Sk.RightToLeft = iq; Sk.Forward = gq; Sk.Reverse = hq; Sk.Ascending = dq; Sk.Descending = fq; function Ii() { this.Jo = new I; this.lo = new I; this.Ga = new I; this.Oe = new Ub; this.Gg = new Ub; this.sj = new Ub; this.D = null; this.Jq = !1 } t = Ii.prototype; t.clear = function () { this.Jo.clear(); this.lo.clear(); this.Ga.clear(); this.Oe.clear(); this.Gg.clear(); this.sj.clear() };
    t.ib = function (a) { E && null !== a && w(a, P, Ii, "setDiagram"); this.D = a }; t.Ri = function (a) { if (a instanceof V) { if (this.Jo.add(a), a instanceof xg) { var b = a.containingGroup; null === b ? this.D.Ai.add(a) : b.vl.add(a); b = a.layout; null !== b && (b.diagram = this.D) } } else a instanceof Q ? this.lo.add(a) : a instanceof Cf || this.Ga.add(a); b = a.data; null === b || a instanceof Cf || (a instanceof Q ? this.Gg.add(b, a) : this.Oe.add(b, a)) };
    t.zc = function (a) { a.Wj(); if (a instanceof V) { if (this.Jo.remove(a), a instanceof xg) { var b = a.containingGroup; null === b ? this.D.Ai.remove(a) : b.vl.remove(a); b = a.layout; null !== b && (b.diagram = null) } } else a instanceof Q ? this.lo.remove(a) : a instanceof Cf || this.Ga.remove(a); b = a.data; null === b || a instanceof Cf || (a instanceof Q ? this.Gg.remove(b) : this.Oe.remove(b)) };
    t.wd = function () {
        for (var a = this.D.nodeTemplateMap.iterator; a.next();) { var b = a.value, c = a.key; (!b.dc() || b instanceof xg) && v('Invalid node template in Diagram.nodeTemplateMap: template for "' + c + '" must be a Node or a simple Part, not a Group or Link: ' + b) } for (a = this.D.groupTemplateMap.iterator; a.next();)b = a.value, c = a.key, b instanceof xg || v('Invalid group template in Diagram.groupTemplateMap: template for "' + c + '" must be a Group, not a normal Node or Link: ' + b); for (a = this.D.linkTemplateMap.iterator; a.next();)b =
            a.value, c = a.key, b instanceof Q || v('Invalid link template in Diagram.linkTemplateMap: template for "' + c + '" must be a Link, not a normal Node or simple Part: ' + b); a = Qa(); for (b = this.D.selection.iterator; b.next();)(c = b.value.data) && a.push(c); b = Qa(); for (c = this.D.highlighteds.iterator; c.next();) { var d = c.value.data; d && b.push(d) } c = Qa(); for (d = this.nodes.iterator; d.next();) { var e = d.value; null !== e.data && (c.push(e.data), c.push(e.location)) } for (d = this.links.iterator; d.next();)e = d.value, null !== e.data && (c.push(e.data),
                c.push(e.location)); for (d = this.parts.iterator; d.next();)e = d.value, null !== e.data && (c.push(e.data), c.push(e.location)); this.removeAllModeledParts(); this.addAllModeledParts(); for (d = 0; d < a.length; d++)e = this.xc(a[d]), null !== e && (e.isSelected = !0); for (d = 0; d < b.length; d++)e = this.xc(b[d]), null !== e && (e.isHighlighted = !0); for (d = 0; d < c.length; d += 2)e = this.xc(c[d]), null !== e && (e.location = c[d + 1]); Ta(a); Ta(b); Ta(c)
    }; Ii.prototype.addAllModeledParts = function () { this.addModeledParts(this.diagram.model.nodeDataArray) };
    Ii.prototype.addModeledParts = function (a, b) { var c = this, d = this.diagram.model; a.forEach(function (a) { d.Ab(a) && kq(c, a, !1) }); a.forEach(function (a) { d.Ab(a) && c.resolveReferencesForData(a) }); !1 !== b && uk(this.diagram, !1) };
    function kq(a, b, c) { if (void 0 !== b && null !== b && !a.diagram.undoManager.isUndoingRedoing && !a.Oe.contains(b)) { void 0 === c && (c = !0); a: { if (void 0 !== b && null !== b && !a.D.undoManager.isUndoingRedoing && !a.Oe.contains(b)) { var d = a.$s(b); var e = No(a, b, d); if (null !== e && (mh(e), e = e.copy(), null !== e)) { var f = a.diagram.skipsModelSourceBindings; a.diagram.skipsModelSourceBindings = !0; e.Bf = d; e.kb = b; a.Jq && (e.Ug = "Tool"); a.diagram.add(e); e.kb = null; e.data = b; a.diagram.skipsModelSourceBindings = f; d = e; break a } } d = null } null !== d && c && a.resolveReferencesForData(b) } }
    Ii.prototype.insertLink = function () { return null }; Ii.prototype.resolveReferencesForData = function () { }; Ii.prototype.$s = function (a) { return this.D.model.$s(a) };
    function No(a, b, c) { a = a.D; var d = a.model; d.Si() && d.ht(b) ? (b = a.groupTemplateMap.K(c), null === b && (b = a.groupTemplateMap.K(""), null === b && (lq || (lq = !0, Ga('No Group template found for category "' + c + '"'), Ga("  Using default group template")), b = a.vw))) : (b = a.nodeTemplateMap.K(c), null === b && (b = a.nodeTemplateMap.K(""), null === b && (mq || (mq = !0, Ga('No Node template found for category "' + c + '"'), Ga("  Using default node template")), b = a.xw))); return b } Ii.prototype.getLinkCategoryForData = function () { return "" };
    Ii.prototype.setLinkCategoryForData = function () { }; Ii.prototype.setFromNodeForLink = function () { }; Ii.prototype.setToNodeForLink = function () { }; Ii.prototype.findLinkTemplateForCategory = function (a) { var b = this.D.linkTemplateMap.K(a); null === b && (b = this.D.linkTemplateMap.K(""), null === b && (nq || (nq = !0, Ga('No Link template found for category "' + a + '"'), Ga("  Using default link template")), b = this.D.ww)); return b }; Ii.prototype.removeAllModeledParts = function () { this.vt(this.diagram.model.nodeDataArray) };
    Ii.prototype.vt = function (a) { var b = this; a.forEach(function (a) { b.wq(a) }) }; Ii.prototype.wq = function (a) { a = this.xc(a); null !== a && (Xj(this.diagram, a, !1), this.unresolveReferencesForPart(a)) }; Ii.prototype.unresolveReferencesForPart = function () { }; Ii.prototype.removeDataForLink = function () { }; Ii.prototype.findPartForKey = function (a) { if (null === a || void 0 === a) return null; a = this.D.model.Sb(a); return null !== a ? this.Oe.K(a) : null }; t = Ii.prototype;
    t.Kb = function (a) { if (null === a || void 0 === a) return null; a = this.D.model.Sb(a); if (null === a) return null; a = this.Oe.K(a); return a instanceof V ? a : null }; t.xc = function (a) { if (null === a) return null; var b = this.Oe.K(a); return null !== b ? b : b = this.Gg.K(a) }; t.Ii = function (a) { if (null === a) return null; a = this.Oe.K(a); return a instanceof V ? a : null }; t.wc = function (a) { return null === a ? null : this.Gg.K(a) };
    t.Xs = function (a) { for (var b = 0; b < arguments.length; ++b); b = new I; for (var c = this.Jo.iterator; c.next();) { var d = c.value, e = d.data; if (null !== e) for (var f = 0; f < arguments.length; f++) { var g = arguments[f]; if (Ia(g) && oq(this, e, g)) { b.add(d); break } } } return b.iterator }; t.Ws = function (a) { for (var b = 0; b < arguments.length; ++b); b = new I; for (var c = this.lo.iterator; c.next();) { var d = c.value, e = d.data; if (null !== e) for (var f = 0; f < arguments.length; f++) { var g = arguments[f]; if (Ia(g) && oq(this, e, g)) { b.add(d); break } } } return b.iterator };
    function oq(a, b, c) { for (var d in c) { var e = b[d], f = c[d]; if (Ka(f)) { if (!Ka(e) || e.length < f.length) return !1; for (var g = 0; g < e.length; g++) { var h = f[g]; if (void 0 !== h && !pq(a, e[g], h)) return !1 } } else if (!pq(a, e, f)) return !1 } return !0 } function pq(a, b, c) { if ("function" === typeof c) { if (!c(b)) return !1 } else if (c instanceof RegExp) { if (!b || !c.test(b.toString())) return !1 } else if (Ia(b) && Ia(c)) { if (!oq(a, b, c)) return !1 } else if (b !== c) return !1; return !0 }
    Ii.prototype.doModelChanged = function (a) {
        if (this.D) {
            var b = this.D; if (a.model === b.model) {
                var c = a.change; b.doModelChanged(a); if (b.fa) {
                b.fa = !1; try {
                    var d = a.modelChange; if ("" !== d) if (c === of) { if ("nodeCategory" === d) { var e = this.xc(a.object), f = a.newValue; null !== e && "string" === typeof f && (e.category = f) } else "nodeDataArray" === d && (this.vt(a.oldValue), this.addModeledParts(a.newValue)); b.isModified = !0 } else if (c === qf) { var g = a.newValue; "nodeDataArray" === d && Ia(g) && kq(this, g); b.isModified = !0 } else if (c === rf) {
                        var h = a.oldValue;
                        "nodeDataArray" === d && Ia(h) && this.wq(h); b.isModified = !0
                    } else c === pf && ("SourceChanged" === d ? null !== a.object ? this.updateDataBindings(a.object, a.propertyName) : (this.Dq(), this.updateAllTargetBindings()) : "ModelDisplaced" === d && this.wd()); else if (c === of) { var k = a.propertyName, l = a.object; if (l === b.model) { if ("nodeKeyProperty" === k || "nodeCategoryProperty" === k) b.undoManager.isUndoingRedoing || this.wd() } else this.updateDataBindings(l, k); b.isModified = !0 } else if (c === qf || c === rf) {
                        var m = a.change === qf, n = m ? a.newParam : a.oldParam,
                        p = m ? a.newValue : a.oldValue, q = this.sj.K(a.object); if (Array.isArray(q)) for (a = 0; a < q.length; a++) { var r = q[a]; if (m) tn(r, p, n); else if (!(0 > n)) { var u = n + ln(r); r.zc(u, !0); xn(r, u, n) } } b.isModified = !0
                    }
                } finally { b.fa = !0 }
                }
            }
        }
    }; Ii.prototype.updateAllTargetBindings = function (a) { void 0 === a && (a = ""); for (var b = this.parts.iterator; b.next();)b.value.Fa(a); for (b = this.nodes.iterator; b.next();)b.value.Fa(a); for (b = this.links.iterator; b.next();)b.value.Fa(a) };
    Ii.prototype.Dq = function () {
        for (var a = this.D.model, b = new I, c = a.nodeDataArray, d = 0; d < c.length; d++)b.add(c[d]); var e = []; this.nodes.each(function (a) { null === a.data || b.contains(a.data) || e.push(a.data) }); this.parts.each(function (a) { null === a.data || b.contains(a.data) || e.push(a.data) }); e.forEach(function (b) { qq(a, b, !1) }); for (d = 0; d < c.length; d++) { var f = c[d]; null === this.xc(f) && rq(a, f, !1) } this.refreshDataBoundLinks(); for (c = this.parts.iterator; c.next();)c.value.updateRelationshipsFromData(); for (c = this.nodes.iterator; c.next();)c.value.updateRelationshipsFromData();
        for (c = this.links.iterator; c.next();)c.value.updateRelationshipsFromData()
    }; Ii.prototype.refreshDataBoundLinks = function () { }; Ii.prototype.updateRelationshipsFromData = function () { };
    Ii.prototype.updateDataBindings = function (a, b) { if ("string" === typeof b) { var c = this.xc(a); if (null !== c) c.Fa(b); else { c = null; for (var d = this.sj.iterator; d.next();) { for (var e = d.value, f = 0; f < e.length; f++) { var g = e[f].mx(a); null !== g && (null === c && (c = Qa()), c.push(g)) } if (null !== c) break } if (null !== c) { for (d = 0; d < c.length; d++)c[d].Fa(b); Ta(c) } } a === this.diagram.model.modelData && this.updateAllTargetBindings(b) } };
    function Sj(a, b) { var c = b.gi; if (Ka(c)) { var d = a.sj.K(c); if (null === d) d = [], d.push(b), a.sj.add(c, d); else { for (a = 0; a < d.length; a++)if (d[a] === b) return; d.push(b) } } } function Wj(a, b) { var c = b.gi; if (Ka(c)) { var d = a.sj.K(c); if (null !== d) for (var e = 0; e < d.length; e++)if (d[e] === b) { d.splice(e, 1); 0 === d.length && a.sj.remove(c); break } } }
    Ii.prototype.ak = function (a, b, c) {
        var d = new Ub; if (Ka(a)) for (var e = 0; e < a.length; e++)sq(this, a[e], b, d, c); else for (a = a.iterator; a.next();)sq(this, a.value, b, d, c); if (null !== b) {
            c = b.model; a = b.toolManager.findTool("Dragging"); a = null !== a ? a.dragOptions.dragsLink : b.Pk.dragsLink; e = new I; for (var f = new Ub, g = d.iterator; g.next();) {
                var h = g.value; if (h instanceof Q) a || null !== h.fromNode && null !== h.toNode || e.add(h); else if (h instanceof V && null !== h.data && c.jm()) {
                    var k = h; h = g.key; var l = h.rg(); null !== l && (l = d.K(l), null !== l ? (c.Ke(k.data,
                        c.ra(l.data)), k = b.wc(k.data), h = h.Li(), null !== h && null !== k && f.add(h, k)) : c.Ke(k.data, void 0))
                }
            } 0 < e.count && b.wt(e, !1); if (0 < f.count) for (c = f.iterator; c.next();)d.add(c.key, c.value)
        } if (null !== b && null !== this.D && (b = b.model, c = b.afterCopyFunction, null !== c)) { var m = new Ub; d.each(function (a) { null !== a.key.data && m.add(a.key.data, a.value.data) }); c(m, b, this.D.model) } for (b = d.iterator; b.next();)b.value.Fa(); return d
    };
    function sq(a, b, c, d, e) {
        if (null === b || e && !b.canCopy()) return null; if (d.contains(b)) return d.K(b); var f = a.copyPartData(b, c); if (!(f instanceof R)) return null; f.isSelected = !1; f.isHighlighted = !1; d.add(b, f); if (b instanceof V) {
            for (var g = b.linksConnected; g.next();) { var h = g.value; if (h.fromNode === b) { var k = d.K(h); null !== k && (k.fromNode = f) } h.toNode === b && (h = d.K(h), null !== h && (h.toNode = f)) } if (b instanceof xg && f instanceof xg) for (b = b.memberParts; b.next();)g = sq(a, b.value, c, d, e), g instanceof Q || null === g || (g.containingGroup =
                f)
        } else if (b instanceof Q && f instanceof Q) for (g = b.fromNode, null !== g && (g = d.K(g), null !== g && (f.fromNode = g)), g = b.toNode, null !== g && (g = d.K(g), null !== g && (f.toNode = g)), b = b.labelNodes; b.next();)g = sq(a, b.value, c, d, e), null !== g && g instanceof V && (g.labeledLink = f); return f
    }
    Ii.prototype.copyPartData = function (a, b) { var c = null, d = a.data; if (null !== d && null !== b) { var e = b.model; a instanceof Q || (d = e.copyNodeData(d), Ia(d) && (e.lf(d), c = b.xc(d))) } else mh(a), c = a.copy(), null !== c && (e = this.D, null !== b ? b.add(c) : null !== d && null !== e && null !== e.commandHandler && e.commandHandler.copiesClipboardData && (b = e.model, e = null, c instanceof Q || (e = b.copyNodeData(d)), Ia(e) && (c.data = e))); return c };
    na.Object.defineProperties(Ii.prototype, { nodes: { configurable: !0, get: function () { return this.Jo } }, links: { configurable: !0, get: function () { return this.lo } }, parts: { configurable: !0, get: function () { return this.Ga } }, diagram: { configurable: !0, get: function () { return this.D } }, addsToTemporaryLayer: { configurable: !0, get: function () { return this.Jq }, set: function (a) { z(a, "boolean", Ii, "addsToTemporaryLayer"); this.Jq = a } } });
    Ii.prototype.updateAllRelationshipsFromData = Ii.prototype.Dq; Ii.prototype.findLinksByExample = Ii.prototype.Ws; Ii.prototype.findNodesByExample = Ii.prototype.Xs; Ii.prototype.findLinkForData = Ii.prototype.wc; Ii.prototype.findNodeForData = Ii.prototype.Ii; Ii.prototype.findPartForData = Ii.prototype.xc; Ii.prototype.findNodeForKey = Ii.prototype.Kb; Ii.prototype.removeModeledPart = Ii.prototype.wq; Ii.prototype.removeModeledParts = Ii.prototype.vt; Ii.prototype.rebuildParts = Ii.prototype.wd; var mq = !1, lq = !1, nq = !1;
    Ii.className = "PartManager"; function tq(a) { Ii.apply(this, arguments) } ma(tq, Ii); tq.prototype.addAllModeledParts = function () { var a = this.diagram.model; this.addModeledParts(a.nodeDataArray); uq(this, a.linkDataArray) }; tq.prototype.addModeledParts = function (a) { Ii.prototype.addModeledParts.call(this, a, !1); for (a = this.links.iterator; a.next();)Oo(a.value); uk(this.diagram, !1) }; function uq(a, b) { b.forEach(function (b) { vq(a, b) }); uk(a.diagram, !1) }
    function vq(a, b) {
        if (void 0 !== b && null !== b && !a.diagram.undoManager.isUndoingRedoing && !a.Gg.contains(b)) {
            var c = a.getLinkCategoryForData(b), d = a.findLinkTemplateForCategory(c); if (null !== d) {
                mh(d); var e = d.copy(); if (null !== e) {
                    d = a.diagram.skipsModelSourceBindings; a.diagram.skipsModelSourceBindings = !0; e.Bf = c; e.kb = b; c = a.diagram.model; var f = wq(c, b, !0); "" !== f && (e.fromPortId = f); f = xq(c, b, !0); void 0 !== f && (f = a.Kb(f), f instanceof V && (e.fromNode = f)); f = wq(c, b, !1); "" !== f && (e.toPortId = f); f = xq(c, b, !1); void 0 !== f && (f = a.Kb(f),
                        f instanceof V && (e.toNode = f)); c = c.sg(b); Array.isArray(c) && c.forEach(function (b) { b = a.Kb(b); null !== b && (b.labeledLink = e) }); a.Jq && (e.Ug = "Tool"); a.diagram.add(e); e.kb = null; e.data = b; a.diagram.skipsModelSourceBindings = d
                }
            }
        }
    } tq.prototype.removeAllModeledParts = function () { var a = this.diagram.model; yq(this, a.linkDataArray); this.vt(a.nodeDataArray) }; function yq(a, b) { b.forEach(function (b) { a.wq(b) }) } tq.prototype.getLinkCategoryForData = function (a) { return this.diagram.model.iv(a) };
    tq.prototype.setLinkCategoryForData = function (a, b) { return this.diagram.model.yt(a, b) }; tq.prototype.setFromNodeForLink = function (a, b) { var c = this.diagram.model; c.Kx(a.data, c.ra(null !== b ? b.data : null)) }; tq.prototype.setToNodeForLink = function (a, b) { var c = this.diagram.model; c.Ox(a.data, c.ra(null !== b ? b.data : null)) }; tq.prototype.removeDataForLink = function (a) { this.diagram.model.sm(a.data) };
    tq.prototype.findPartForKey = function (a) { var b = Ii.prototype.findPartForKey.call(this, a); return null === b && (a = this.diagram.model.xh(a), null !== a) ? this.Gg.K(a) : b };
    tq.prototype.doModelChanged = function (a) {
        var b = this; Ii.prototype.doModelChanged.call(this, a); if (this.diagram) {
            var c = this.diagram; if (a.model === c.model) {
                var d = a.change; if (c.fa) {
                c.fa = !1; try {
                    var e = a.modelChange; if ("" !== e) if (d === of) {
                        if ("linkFromKey" === e) { var f = this.wc(a.object); if (null !== f) { var g = this.Kb(a.newValue); f.fromNode = g } } else if ("linkToKey" === e) { var h = this.wc(a.object); if (null !== h) { var k = this.Kb(a.newValue); h.toNode = k } } else if ("linkFromPortId" === e) {
                            var l = this.wc(a.object); if (null !== l) {
                                var m = a.newValue;
                                "string" === typeof m && (l.fromPortId = m)
                            }
                        } else if ("linkToPortId" === e) { var n = this.wc(a.object); if (null !== n) { var p = a.newValue; "string" === typeof p && (n.toPortId = p) } } else if ("nodeGroupKey" === e) { var q = this.xc(a.object); if (null !== q) { var r = a.newValue; if (void 0 !== r) { var u = this.Kb(r); u instanceof xg ? q.containingGroup = u : q.containingGroup = null } else q.containingGroup = null } } else if ("linkLabelKeys" === e) {
                            var x = this.wc(a.object); if (null !== x) {
                                var y = a.oldValue, A = a.newValue; Array.isArray(y) && y.forEach(function (a) {
                                    a = b.Kb(a);
                                    null !== a && (a.labeledLink = null)
                                }); Array.isArray(A) && A.forEach(function (a) { a = b.Kb(a); null !== a && (a.labeledLink = x) })
                            }
                        } else if ("linkCategory" === e) { var C = this.wc(a.object), G = a.newValue; null !== C && "string" === typeof G && (C.category = G) } else "linkDataArray" === e && (yq(this, a.oldValue), uq(this, a.newValue)); c.isModified = !0
                    } else if (d === qf) {
                        var H = a.newValue; if ("linkDataArray" === e && "object" === typeof H && null !== H) vq(this, H); else if ("linkLabelKeys" === e && zq(H)) {
                            var O = this.wc(a.object), S = this.Kb(H); null !== O && null !== S && (S.labeledLink =
                                O)
                        } c.isModified = !0
                    } else { if (d === rf) { var T = a.oldValue; if ("linkDataArray" === e && "object" === typeof T && null !== T) this.wq(T); else if ("linkLabelKeys" === e && zq(T)) { var ea = this.Kb(T); null !== ea && (ea.labeledLink = null) } c.isModified = !0 } } else if (d === of) {
                        var Z = a.propertyName, va = a.object; if (va === c.model) {
                            if ("linkFromKeyProperty" === Z || "linkToKeyProperty" === Z || "linkFromPortIdProperty" === Z || "linkToPortIdProperty" === Z || "linkLabelKeysProperty" === Z || "nodeIsGroupProperty" === Z || "nodeGroupKeyProperty" === Z || "linkCategoryProperty" ===
                                Z) c.undoManager.isUndoingRedoing || this.wd()
                        } else this.updateDataBindings(va, Z); c.isModified = !0
                    }
                } finally { c.fa = !0 }
                }
            }
        }
    }; tq.prototype.refreshDataBoundLinks = function () { var a = this, b = this.diagram.model, c = new I, d = b.linkDataArray; d.forEach(function (a) { c.add(a) }); var e = []; this.links.each(function (a) { null === a.data || c.contains(a.data) || e.push(a.data) }); e.forEach(function (a) { Aq(b, a, !1) }); d.forEach(function (c) { null === a.wc(c) && Bq(b, c, !1) }) };
    tq.prototype.updateRelationshipsFromData = function (a) {
        var b = a.data; if (null !== b) {
            var c = a.diagram; if (null !== c) {
                var d = c.model; if (a instanceof Q) {
                    var e = xq(d, b, !0); e = c.Kb(e); a.fromNode = e; e = xq(d, b, !1); e = c.Kb(e); a.toNode = e; b = d.sg(b); if (0 < b.length || 0 < a.labelNodes.count) {
                        if (1 === b.length && 1 === a.labelNodes.count) { e = b[0]; var f = a.labelNodes.first(); if (d.ra(f.data) === e) return } e = (new I).addAll(b); var g = new I; a.labelNodes.each(function (a) { null !== a.data && (a = d.ra(a.data), void 0 !== a && g.add(a)) }); b = g.copy(); b.vq(e); e =
                            e.copy(); e.vq(g); if (0 < b.count || 0 < e.count) b.each(function (b) { b = c.Kb(b); null !== b && b.labeledLink === a && (b.labeledLink = null) }), e.each(function (b) { b = c.Kb(b); null !== b && b.labeledLink !== a && (b.labeledLink = a) })
                    }
                } else !(a instanceof Cf) && (b = d.Oi(b), b = c.findPartForKey(b), null === b || b instanceof xg) && (a.containingGroup = b)
            }
        }
    };
    tq.prototype.resolveReferencesForData = function (a) {
        var b = this.diagram.model, c = b.ra(a); if (void 0 !== c) {
            var d = Cq(b, c), e = this.xc(a); if (null !== d && null !== e) {
                d = d.iterator; for (var f = {}; d.next();) {
                    var g = d.value; b.Ab(g) ? e instanceof xg && b.Oi(g) === c && (g = this.xc(g), null !== g && (g.containingGroup = e)) : (f.link = this.wc(g), null !== f.link && e instanceof V && (xq(b, g, !0) === c && (f.link.fromNode = e), xq(b, g, !1) === c && (f.link.toNode = e), g = b.sg(g), Array.isArray(g) && g.some(function (a) {
                        return function (b) {
                            return b === c ? (e.labeledLink =
                                a.link, !0) : !1
                        }
                    }(f)))); f = { link: f.link }
                } Dq(b, c)
            } a = b.Oi(a); void 0 !== a && (a = this.Kb(a), a instanceof xg && (e.containingGroup = a))
        }
    }; tq.prototype.unresolveReferencesForPart = function (a) { var b = this.diagram.model; if (a instanceof V) { var c = b.ra(a.data); if (void 0 !== c) { for (var d = a.linksConnected; d.next();)Eq(b, c, d.value.data); a.isLinkLabel && (d = a.labeledLink, null !== d && Eq(b, c, d.data)); if (a instanceof xg) for (a = a.memberParts; a.next();)d = a.value.data, b.Ab(d) && Eq(b, c, d) } } };
    tq.prototype.copyPartData = function (a, b) { var c = Ii.prototype.copyPartData.call(this, a, b); if (a instanceof Q) if (a = a.data, null !== a && null !== b) { var d = b.model; a = d.Wp(a); "object" === typeof a && null !== a && (d.Di(a), c = b.wc(a)) } else null !== c && (b = this.diagram, null !== a && null !== b && null !== b.commandHandler && b.commandHandler.copiesClipboardData && (b = b.model.Wp(a), "object" === typeof b && null !== b && (c.data = b))); return c };
    tq.prototype.insertLink = function (a, b, c, d) {
        var e = this.diagram, f = e.model, g = e.toolManager.findTool("Linking"), h = ""; null !== a && (null === b && (b = a), h = b.portId, null === h && (h = "")); b = ""; null !== c && (null === d && (d = c), b = d.portId, null === b && (b = "")); d = g.archetypeLinkData; if (d instanceof Q) { if (mh(d), f = d.copy(), null !== f) return f.fromNode = a, f.fromPortId = h, f.toNode = c, f.toPortId = b, e.add(f), a = g.archetypeLabelNodeData, a instanceof V && (mh(a), a = a.copy(), null !== a && (a.labeledLink = f, e.add(a))), f } else if (null !== d && (d = f.Wp(d), "object" ===
            typeof d && null !== d)) return null !== a && Fq(f, d, f.ra(a.data), !0), Gq(f, d, h, !0), null !== c && Fq(f, d, f.ra(c.data), !1), Gq(f, d, b, !1), f.Di(d), a = g.archetypeLabelNodeData, null === a || a instanceof V || (a = f.copyNodeData(a), "object" === typeof a && null !== a && (f.lf(a), a = f.ra(a), void 0 !== a && f.Lu(d, a))), e.wc(d); return null
    }; tq.prototype.findPartForKey = tq.prototype.findPartForKey; tq.prototype.removeAllModeledParts = tq.prototype.removeAllModeledParts; tq.prototype.addModeledParts = tq.prototype.addModeledParts;
    tq.prototype.addAllModeledParts = tq.prototype.addAllModeledParts; tq.className = "GraphLinksPartManager"; function Hq() { Ii.apply(this, arguments); this.ah = null } ma(Hq, Ii);
    function Iq(a, b, c) {
        if (null !== b && null !== c) {
            var d = a.diagram.toolManager.findTool("Linking"), e = b, f = c; if (a.diagram.isTreePathToChildren) for (b = f.linksConnected; b.next();) { if (b.value.toNode === f) return } else for (e = c, f = b, b = e.linksConnected; b.next();)if (b.value.fromNode === e) return; if (null === d || !Lg(d, e, f, null, !0)) if (d = a.getLinkCategoryForData(c.data), b = a.findLinkTemplateForCategory(d), null !== b && (mh(b), b = b.copy(), null !== b)) {
                var g = a.diagram.skipsModelSourceBindings; a.diagram.skipsModelSourceBindings = !0; b.Bf = d;
                b.kb = c.data; b.fromNode = e; b.toNode = f; a.diagram.add(b); b.kb = null; b.data = c.data; a.diagram.skipsModelSourceBindings = g
            }
        }
    } Hq.prototype.getLinkCategoryForData = function (a) { return this.diagram.model.jv(a) }; Hq.prototype.setLinkCategoryForData = function (a, b) { this.diagram.model.Pv(a, b) };
    Hq.prototype.setFromNodeForLink = function (a, b, c) { var d = this.diagram.model; void 0 === c && (c = null); b = null !== b ? b.data : null; if (this.diagram.isTreePathToChildren) d.Ke(a.data, d.ra(b)); else { var e = this.ah; this.ah = a; null !== c && d.Ke(c.data, void 0); d.Ke(b, d.ra(null !== a.toNode ? a.toNode.data : null)); this.ah = e } };
    Hq.prototype.setToNodeForLink = function (a, b, c) { var d = this.diagram.model; void 0 === c && (c = null); b = null !== b ? b.data : null; if (this.diagram.isTreePathToChildren) { var e = this.ah; this.ah = a; null !== c && d.Ke(c.data, void 0); d.Ke(b, d.ra(null !== a.fromNode ? a.fromNode.data : null)); this.ah = e } else d.Ke(a.data, d.ra(b)) }; Hq.prototype.removeDataForLink = function (a) { this.diagram.model.Ke(a.data, void 0) };
    Hq.prototype.doModelChanged = function (a) {
        Ii.prototype.doModelChanged.call(this, a); if (this.diagram) {
            var b = this.diagram; if (a.model === b.model) {
                var c = a.change; if (b.fa) {
                b.fa = !1; try {
                    var d = a.modelChange; if ("" !== d) {
                        if (c === of) {
                            if ("nodeParentKey" === d) {
                                var e = a.object, f = this.Kb(a.newValue), g = this.Ii(e); if (null !== this.ah) null !== f && (this.ah.data = e, this.ah.category = this.getLinkCategoryForData(e)); else if (null !== g) {
                                    var h = g.Li(); null !== h ? null === f ? b.remove(h) : b.isTreePathToChildren ? h.fromNode = f : h.toNode = f : Iq(this, f,
                                        g)
                                }
                            } else if ("parentLinkCategory" === d) { var k = this.Ii(a.object), l = a.newValue; if (null !== k && "string" === typeof l) { var m = k.Li(); null !== m && (m.category = l) } } b.isModified = !0
                        }
                    } else if (c === of) { var n = a.propertyName, p = a.object; p === b.model ? "nodeParentKeyProperty" === n && (b.undoManager.isUndoingRedoing || this.wd()) : this.updateDataBindings(p, n); b.isModified = !0 }
                } finally { b.fa = !0 }
                }
            }
        }
    };
    Hq.prototype.updateRelationshipsFromData = function (a) { var b = a.data; if (null !== b) { var c = a.diagram; if (null !== c) { var d = c.model; a instanceof V && (b = d.Qi(b), b = c.Kb(b), d = a.rg(), b !== d && (d = a.Li(), null !== b ? null !== d ? c.isTreePathToChildren ? d.fromNode = b : d.toNode = b : Iq(this, b, a) : null !== d && Xj(c, d, !1))) } } }; Hq.prototype.updateDataBindings = function (a, b) { Ii.prototype.updateDataBindings.call(this, a, b); "string" === typeof b && null !== this.xc(a) && (a = this.wc(a), null !== a && a.Fa(b)) };
    Hq.prototype.resolveReferencesForData = function (a) { var b = this.diagram.model, c = b.ra(a); if (void 0 !== c) { var d = Cq(b, c), e = this.xc(a); if (null !== d && null !== e) { for (d = d.iterator; d.next();) { var f = d.value; b.Ab(f) && e instanceof V && b.Qi(f) === c && Iq(this, e, this.Ii(f)) } Dq(b, c) } a = b.Qi(a); void 0 !== a && e instanceof V && (a = this.Kb(a), Iq(this, a, e)) } };
    Hq.prototype.unresolveReferencesForPart = function (a) { var b = this.diagram.model; if (a instanceof V) { var c = b.ra(a.data), d = this.wc(a.data); if (null !== d) { d.isSelected = !1; d.isHighlighted = !1; var e = d.layer; if (null !== e) { var f = e.zc(-1, d, !1); 0 <= f && this.diagram.cb(rf, "parts", e, d, null, f, null); f = d.layerChanged; null !== f && f(d, e, null) } } d = this.diagram.isTreePathToChildren; for (a = a.linksConnected; a.next();)e = a.value, e = (d ? e.toNode : e.fromNode).data, b.Ab(e) && Eq(b, c, e) } };
    Hq.prototype.insertLink = function (a, b, c) { b = this.diagram.model; var d = a, e = c; this.diagram.isTreePathToChildren || (d = c, e = a); return null !== d && null !== e ? (b.Ke(e.data, b.ra(d.data)), e.Li()) : null }; Hq.className = "TreePartManager";
    function X(a) {
    this.Jt = ',\n  "insertedNodeKeys": '; this.lw = ',\n  "modifiedNodeData": '; this.Lt = ',\n  "removedNodeKeys": '; E && 1 < arguments.length && v("Model constructor can only take one optional argument, the Array of node data."); qb(this); this.qn = this.Wa = ""; this.Of = !1; this.l = {}; this.sc = []; this.fb = new Ub; this.ni = "key"; this.Mk = this.sl = null; this.fn = this.gn = !1; this.jn = !0; this.Qm = null; this.Aj = "category"; this.Hf = new Ub; this.ku = new F; this.eh = !1; this.w = null; this.undoManager = new tf; void 0 !== a && (this.nodeDataArray =
        a)
    } X.prototype.cloneProtected = function (a) { a.Wa = this.Wa; a.qn = this.qn; a.Of = this.Of; a.ni = this.ni; a.sl = this.sl; a.Mk = this.Mk; a.gn = this.gn; a.fn = this.fn; a.jn = this.jn; a.Qm = this.Qm; a.Aj = this.Aj }; X.prototype.copy = function () { var a = new this.constructor; this.cloneProtected(a); return a }; t = X.prototype; t.clear = function () { this.sc = []; this.fb.clear(); this.Hf.clear(); this.undoManager.clear() };
    t.toString = function (a) { void 0 === a && (a = 0); if (1 < a) return this.Bq(); var b = ("" !== this.name ? this.name : "") + " Model"; if (0 < a) { b += "\n node data:"; a = this.nodeDataArray; for (var c = a.length, d = 0; d < c; d++) { var e = a[d]; b += " " + this.ra(e) + ":" + Wa(e) } } return b };
    t.xk = function () {
        var a = ""; "" !== this.name && (a += ',\n  "name": ' + this.quote(this.name)); "" !== this.dataFormat && (a += ',\n  "dataFormat": ' + this.quote(this.dataFormat)); this.isReadOnly && (a += ',\n  "isReadOnly": ' + this.isReadOnly); "key" !== this.nodeKeyProperty && "string" === typeof this.nodeKeyProperty && (a += ',\n  "nodeKeyProperty": ' + this.quote(this.nodeKeyProperty)); this.copiesArrays && (a += ',\n  "copiesArrays": true'); this.copiesArrayObjects && (a += ',\n  "copiesArrayObjects": true'); this.copiesKey || (a += ',\n  "copiesKey": false');
        "category" !== this.nodeCategoryProperty && "string" === typeof this.nodeCategoryProperty && (a += ',\n  "nodeCategoryProperty": ' + this.quote(this.nodeCategoryProperty)); return a
    };
    t.uq = function (a) { a.name && (this.name = a.name); a.dataFormat && (this.dataFormat = a.dataFormat); a.isReadOnly && (this.isReadOnly = !0); a.nodeKeyProperty && (this.nodeKeyProperty = a.nodeKeyProperty); a.copiesArrays && (this.copiesArrays = !0); a.copiesArrayObjects && (this.copiesArrayObjects = !0); !1 === a.copiesKey && (this.copiesKey = !1); a.nodeCategoryProperty && (this.nodeCategoryProperty = a.nodeCategoryProperty) }; function Jq(a) { return ',\n  "modelData": ' + Kq(a, a.modelData) }
    function Lq(a, b) { b = b.modelData; Ia(b) && (a.um(b), a.modelData = b) } t.gw = function () { var a = this.modelData, b = !1, c; for (c in a) if (!Mq(c, a[c])) { b = !0; break } a = ""; b && (a = Jq(this)); return a + ',\n  "nodeDataArray": ' + Nq(this, this.nodeDataArray, !0) }; t.Dv = function (a) { Lq(this, a); a = a.nodeDataArray; Ka(a) && (this.um(a), this.nodeDataArray = a) };
    function Oq(a, b, c, d) {
        if (b === c) return !0; if (typeof b !== typeof c || "function" === typeof b || "function" === typeof c) return !1; if (Array.isArray(b) && Array.isArray(c)) { if (d.K(b) === c) return !0; d.add(b, c); if (b.length !== c.length) return !1; for (var e = 0; e < b.length; e++)if (!Oq(a, b[e], c[e], d)) return !1; return !0 } if (Ia(b) && Ia(c)) {
            if (d.K(b) === c) return !0; d.add(b, c); for (var f in b) { var g = b[f]; if (!Mq(f, g)) { var h = c[f]; if (void 0 === h || !Oq(a, g, h, d)) return !1 } } for (e in c) if (f = c[e], !Mq(e, f) && (g = b[e], void 0 === g || !Oq(a, g, f, d))) return !1;
            return !0
        } return !1
    } function Pq(a, b, c) { a[c] !== b[c] && v("Model.computeJsonDifference: Model." + c + ' is not the same in both models: "' + a[c] + '" and "' + b[c] + '"') }
    t.Fq = function (a) {
        Pq(this, a, "nodeKeyProperty"); for (var b = new I, c = new I, d = (new I).addAll(this.fb.iteratorKeys), e = new Ub, f = a.nodeDataArray, g = f.length, h = 0; h < g; h++) { var k = f[h], l = a.ra(k); if (void 0 !== l) { d.remove(l); var m = this.Sb(l); null === m ? (b.add(l), c.add(k)) : Oq(this, m, k, e) || c.add(k) } else this.mt(k), l = this.ra(k), b.add(l), c.add(k) } f = ""; Oq(this, this.modelData, a.modelData, e) || (f += Jq(this)); 0 < b.count && (f += this.Jt + Nq(this, b.Oa(), !0)); 0 < c.count && (f += this.lw + Nq(this, c.Oa(), !0)); 0 < d.count && (f += this.Lt + Nq(this,
            d.Oa(), !0)); return f
    }; t.zy = function (a, b) { w(a, X, X, "computeJsonDifference:newmodel"); void 0 === b && (b = Qq(this, this)); return '{ "class": ' + this.quote(b) + ', "incremental": 1' + this.xk() + this.Fq(a) + "}" };
    t.Et = function (a, b) {
        var c = this, d = !1, e = new I, f = new I, g = new I; a.changes.each(function (a) { a.model === c && ("nodeDataArray" === a.modelChange ? a.change === qf ? e.add(a.newValue) : a.change === rf && g.add(a.oldValue) : c.Ab(a.object) ? f.add(a.object) : c.modelData === a.object && a.change === of && (d = !0)) }); var h = new I; e.each(function (a) { h.add(c.ra(a)); b || f.add(a) }); var k = new I; g.each(function (a) { k.add(c.ra(a)); b && f.add(a) }); a = ""; d && (a += Jq(this)); 0 < h.count && (a += (b ? this.Lt : this.Jt) + Nq(this, h.Oa(), !0)); 0 < f.count && (a += this.lw + Nq(this,
            f.Oa(), !0)); 0 < k.count && (a += (b ? this.Jt : this.Lt) + Nq(this, k.Oa(), !0)); return a
    };
    t.Cv = function (a) {
        Lq(this, a); var b = a.insertedNodeKeys, c = a.modifiedNodeData, d = new Ub; if (Array.isArray(c)) for (var e = 0; e < c.length; e++) { var f = c[e], g = this.ra(f); void 0 !== g && null !== g && d.set(g, f) } if (Array.isArray(b)) for (e = b.length, f = 0; f < e; f++) { g = b[f]; var h = this.Sb(g); null === h && (h = (h = d.get(g)) ? h : this.copyNodeData({}), this.Am(h, g), this.lf(h)) } if (Array.isArray(c)) for (b = c.length, d = 0; d < b; d++)if (e = c[d], f = this.ra(e), f = this.Sb(f), null !== f) for (var k in e) "__gohashid" === k || k === this.nodeKeyProperty || this.hk() && k ===
            this.nodeIsGroupProperty || this.setDataProperty(f, k, e[k]); a = a.removedNodeKeys; if (Array.isArray(a)) for (c = a.length, k = 0; k < c; k++)b = this.Sb(a[k]), null !== b && this.tm(b)
    };
    t.Sx = function (a, b) { w(a, nf, X, "toIncrementalJson:e"); a.change !== pf && v("Model.toIncrementalJson argument is not a Transaction ChangedEvent:" + a.toString()); var c = a.object; if (!(a.isTransactionFinished && c instanceof sf)) return '{ "incremental": 0 }'; void 0 === b && (b = Qq(this, this)); return "2" === b ? '{ "incremental": 2' + this.Et(c, "FinishedUndo" === a.propertyName) + "}" : '{ "class": ' + this.quote(b) + ', "incremental": 1' + this.xk() + this.Et(c, "FinishedUndo" === a.propertyName) + "}" }; t.gA = function (a, b) { return this.Sx(a, b) };
    t.Bq = function (a) { void 0 === a && (a = Qq(this, this)); return '{ "class": ' + this.quote(a) + this.xk() + this.gw() + "}" }; t.toJSON = function (a) { return this.Bq(a) }; t.Zw = function (a) { var b = null; if ("string" === typeof a) try { b = qa.JSON.parse(a) } catch (d) { E && Ga("JSON.parse error: " + d.toString()) } else "object" === typeof a ? b = a : v("Unable to modify a Model from: " + a); var c = b.incremental; "number" !== typeof c && v("Unable to apply non-incremental changes to Model: " + a); 0 !== c && (this.Ca("applyIncrementalJson"), this.Cv(b), this.ab("applyIncrementalJson")) };
    t.sy = function (a) { return this.Zw(a) }; X.constructGraphLinksModel = function () { E && v("Unable to construct a Model. Provided JSON requires GraphLinksModel, which is not loaded."); return new X }; t = X.prototype;
    t.um = function (a) {
        if (Ka(a)) for (var b = a.length, c = 0; c < b; c++) { var d = a[c]; if (Ia(d)) { var e = c; d = this.um(d); Array.isArray(a) ? a[e] = d : v("Cannot replace an object in an HTMLCollection or NodeList at " + e) } } else if (Ia(a)) {
            for (c in a) if (e = a[c], Ia(e) && (e = this.um(e), a[c] = e, "points" === c && Array.isArray(e))) { d = 0 === e.length % 2; for (var f = 0; f < e.length; f++)if ("number" !== typeof e[f]) { d = !1; break } if (d) { d = new F; for (f = 0; f < e.length / 2; f++)d.add(new J(e[2 * f], e[2 * f + 1])); d.freeze(); a[c] = d } } if ("object" === typeof a) {
                c = a; e = a["class"];
                if ("NaN" === e) c = NaN; else if ("Date" === e) c = new Date(a.value); else if ("go.Point" === e) c = new J(Rq(a.x), Rq(a.y)); else if ("go.Size" === e) c = new Zb(Rq(a.width), Rq(a.height)); else if ("go.Rect" === e) c = new L(Rq(a.x), Rq(a.y), Rq(a.width), Rq(a.height)); else if ("go.Margin" === e) c = new Hc(Rq(a.top), Rq(a.right), Rq(a.bottom), Rq(a.left)); else if ("go.Spot" === e) "string" === typeof a["enum"] ? c = je(a["enum"]) : c = new M(Rq(a.x), Rq(a.y), Rq(a.offsetX), Rq(a.offsetY)); else if ("go.Brush" === e) {
                    if (c = new zl, c.type = sb(zl, a.type), "string" ===
                        typeof a.color && (c.color = a.color), a.start instanceof M && (c.start = a.start), a.end instanceof M && (c.end = a.end), "number" === typeof a.startRadius && (c.startRadius = Rq(a.startRadius)), "number" === typeof a.endRadius && (c.endRadius = Rq(a.endRadius)), a = a.colorStops, Ia(a)) for (b in a) c.addColorStop(parseFloat(b), a[b])
                } else "go.Geometry" === e ? (b = null, "string" === typeof a.path ? b = ze(a.path) : b = new me, b.type = sb(me, a.type), "number" === typeof a.startX && (b.startX = Rq(a.startX)), "number" === typeof a.startY && (b.startY = Rq(a.startY)),
                    "number" === typeof a.endX && (b.endX = Rq(a.endX)), "number" === typeof a.endY && (b.endY = Rq(a.endY)), a.spot1 instanceof M && (b.spot1 = a.spot1), a.spot2 instanceof M && (b.spot2 = a.spot2), c = b) : "go.EnumValue" === e && (b = a.classType, 0 === b.indexOf("go.") && (b = b.substr(3)), c = sb(Sq(b), a.name)); a = c
            }
        } return a
    };
    t.quote = function (a) { for (var b = "", c = a.length, d = 0; d < c; d++) { var e = a[d]; if ('"' === e || "\\" === e) b += "\\" + e; else if ("\b" === e) b += "\\b"; else if ("\f" === e) b += "\\f"; else if ("\n" === e) b += "\\n"; else if ("\r" === e) b += "\\r"; else if ("\t" === e) b += "\\t"; else { var f = a.charCodeAt(d); b = 16 > f ? b + ("\\u000" + a.charCodeAt(d).toString(16)) : 32 > f ? b + ("\\u00" + a.charCodeAt(d).toString(16)) : 8232 === f ? b + "\\u2028" : 8233 === f ? b + "\\u2029" : b + e } } return '"' + b + '"' };
    t.Dm = function (a) { return void 0 === a ? "undefined" : null === a ? "null" : !0 === a ? "true" : !1 === a ? "false" : "string" === typeof a ? this.quote(a) : "number" === typeof a ? Infinity === a ? "9e9999" : -Infinity === a ? "-9e9999" : isNaN(a) ? '{"class":"NaN"}' : a.toString() : a instanceof Date ? '{"class":"Date", "value":"' + a.toJSON() + '"}' : a instanceof Number ? this.Dm(a.valueOf()) : Ka(a) ? Nq(this, a) : Ia(a) ? Kq(this, a) : "function" === typeof a ? "null" : a.toString() };
    function Nq(a, b, c) { void 0 === c && (c = !1); var d = b.length; if (0 >= d) return "[]"; var e = new ub; e.add("[ "); c && 1 < d && e.add("\n"); for (var f = 0; f < d; f++) { var g = b[f]; void 0 !== g && (0 < f && (e.add(","), c && e.add("\n")), e.add(a.Dm(g))) } c && 1 < d && e.add("\n"); e.add(" ]"); return e.toString() } function Mq(a, b) { return void 0 === b || "__gohashid" === a || "_" === a[0] || "function" === typeof b ? !0 : !1 } function Tq(a) { return isNaN(a) ? "NaN" : Infinity === a ? "9e9999" : -Infinity === a ? "-9e9999" : a }
    function Kq(a, b) {
        var c = b; if (c instanceof J) b = { "class": "go.Point", x: Tq(c.x), y: Tq(c.y) }; else if (c instanceof Zb) b = { "class": "go.Size", width: Tq(c.width), height: Tq(c.height) }; else if (c instanceof L) b = { "class": "go.Rect", x: Tq(c.x), y: Tq(c.y), width: Tq(c.width), height: Tq(c.height) }; else if (c instanceof Hc) b = { "class": "go.Margin", top: Tq(c.top), right: Tq(c.right), bottom: Tq(c.bottom), left: Tq(c.left) }; else if (c instanceof M) c.Za() ? b = { "class": "go.Spot", x: Tq(c.x), y: Tq(c.y), offsetX: Tq(c.offsetX), offsetY: Tq(c.offsetY) } :
            b = { "class": "go.Spot", "enum": c.toString() }; else if (c instanceof zl) { b = { "class": "go.Brush", type: c.type.name }; if (c.type === Cl) b.color = c.color; else if (c.type === Fl || c.type === Al) b.start = c.start, b.end = c.end, c.type === Al && (0 !== c.startRadius && (b.startRadius = Tq(c.startRadius)), isNaN(c.endRadius) || (b.endRadius = Tq(c.endRadius))); if (null !== c.colorStops) { var d = {}; for (c = c.colorStops.iterator; c.next();)d[c.key] = c.value; b.colorStops = d } } else if (c instanceof me) b = { "class": "go.Geometry", type: c.type.name }, 0 !== c.startX &&
                (b.startX = Tq(c.startX)), 0 !== c.startY && (b.startY = Tq(c.startY)), 0 !== c.endX && (b.endX = Tq(c.endX)), 0 !== c.endY && (b.endY = Tq(c.endY)), c.spot1.A(fd) || (b.spot1 = c.spot1), c.spot2.A(ud) || (b.spot2 = c.spot2), c.type === ne && (b.path = we(c)); else if (c instanceof D) b = { "class": "go.EnumValue", classType: Qq(a, c.classType), name: c.name }; else if (E && null !== Sq(Qq(a, c))) return Ga("ERROR: trying to convert a GraphObject or Diagram or Model or Tool or Layout or UndoManager or other unknown data into JSON text: " + c.toString()), "{}";
        d = "{"; c = !0; for (var e in b) { var f = yn(b, e); if (!Mq(e, f)) if (c ? c = !1 : d += ", ", d += '"' + e + '":', "points" === e && f instanceof F) { var g = "["; for (f = f.iterator; f.next();) { var h = f.value; 1 < g.length && (g += ","); g += a.Dm(h.x); g += ","; g += a.Dm(h.y) } g += "]"; d += g } else d += a.Dm(f) } return d + "}"
    } function Rq(a) { return "number" === typeof a ? a : "NaN" === a ? NaN : "9e9999" === a ? Infinity : "-9e9999" === a ? -Infinity : parseFloat(a) } t.rh = function (a) { z(a, "function", X, "addChangedListener:listener"); this.ku.add(a) };
    t.tk = function (a) { z(a, "function", X, "removeChangedListener:listener"); this.ku.remove(a) }; t.Qs = function (a) { this.skipsUndoManager || this.undoManager.nv(a); for (var b = this.ku, c = b.length, d = 0; d < c; d++)b.O(d)(a) }; t.cb = function (a, b, c, d, e, f, g) { Uq(this, "", a, b, c, d, e, f, g) }; t.g = function (a, b, c, d, e) { Uq(this, "", of, a, this, b, c, d, e) }; t.rt = function (a, b, c, d, e, f) { Uq(this, "", of, b, a, c, d, e, f) };
    function Uq(a, b, c, d, e, f, g, h, k) { void 0 === h && (h = null); void 0 === k && (k = null); var l = new nf; l.model = a; l.change = c; l.modelChange = b; l.propertyName = d; l.object = e; l.oldValue = f; l.oldParam = h; l.newValue = g; l.newParam = k; a.Qs(l) }
    t.Vj = function (a, b) {
        if (null !== a && a.model === this) if (a.change === of) ek(a.object, a.propertyName, a.K(b)); else if (a.change === qf) {
            var c = a.newParam; if ("nodeDataArray" === a.modelChange) { if (a = a.newValue, Ia(a) && "number" === typeof c) { var d = this.ra(a); b ? (this.sc[c] === a && Oa(this.sc, c), void 0 !== d && this.fb.remove(d)) : (this.sc[c] !== a && Na(this.sc, c, a), void 0 !== d && this.fb.add(d, a)) } } else "" === a.modelChange ? ((d = a.object) && !Ka(d) && a.propertyName && (d = yn(a.object, a.propertyName)), Ka(d) && "number" === typeof c && (a = a.newValue, b ?
                Oa(d, c) : Na(d, c, a))) : v("unknown ChangedEvent.Insert modelChange: " + a.toString())
        } else a.change === rf ? (c = a.oldParam, "nodeDataArray" === a.modelChange ? (a = a.oldValue, Ia(a) && "number" === typeof c && (d = this.ra(a), b ? (this.sc[c] !== a && Na(this.sc, c, a), void 0 !== d && this.fb.add(d, a)) : (this.sc[c] === a && Oa(this.sc, c), void 0 !== d && this.fb.remove(d)))) : "" === a.modelChange ? ((d = a.object) && !Ka(d) && a.propertyName && (d = yn(a.object, a.propertyName)), Ka(d) && "number" === typeof c && (a = a.oldValue, b ? Na(d, c, a) : Oa(d, c))) : v("unknown ChangedEvent.Remove modelChange: " +
            a.toString())) : a.change !== pf && v("unknown ChangedEvent: " + a.toString())
    }; t.Ca = function (a) { return this.undoManager.Ca(a) }; t.ab = function (a) { return this.undoManager.ab(a) }; t.xf = function () { return this.undoManager.xf() }; X.prototype.commit = function (a, b) { void 0 === b && (b = ""); var c = this.skipsUndoManager; null === b && (this.skipsUndoManager = !0, b = ""); this.undoManager.Ca(b); var d = !1; try { a(this), d = !0 } finally { d ? this.undoManager.ab(b) : this.undoManager.xf(), this.skipsUndoManager = c } }; t = X.prototype;
    t.Fa = function (a, b) { void 0 === b && (b = ""); Uq(this, "SourceChanged", pf, b, a, null, null) }; function Vq(a, b, c) { "string" !== typeof a && "function" !== typeof a && Ba(a, "string or function", b, c) } t.ra = function (a) { if (null !== a) { var b = this.ni; if ("" !== b && (b = yn(a, b), void 0 !== b)) { if (zq(b)) return b; v("Key value for node data " + a + " is not a number or a string: " + b) } } };
    t.Am = function (a, b) { void 0 !== b && null !== b && zq(b) || Ba(b, "number or string", X, "setKeyForNodeData:key"); if (null !== a) { var c = this.ni; if ("" !== c) if (this.Ab(a)) { var d = yn(a, c); d !== b && null === this.Sb(b) && (ek(a, c, b), void 0 !== d && this.fb.remove(d), this.fb.add(b, a), Uq(this, "nodeKey", of, c, a, d, b), "string" === typeof c && this.Fa(a, c), this.xq(d, b)) } else ek(a, c, b) } }; function zq(a) { return "number" === typeof a || "string" === typeof a } t.Ab = function (a) { var b = this.ra(a); return void 0 === b ? !1 : this.fb.K(b) === a };
    t.Sb = function (a) { null === a && v("Model.findNodeDataForKey:key must not be null"); return void 0 !== a && zq(a) ? this.fb.K(a) : null };
    t.mt = function (a) { if (null !== a) { var b = this.ni; if ("" !== b) { var c = this.ra(a); if (void 0 === c || this.fb.contains(c)) { var d = this.sl; if (null !== d && (c = d(this, a), void 0 !== c && null !== c && !this.fb.contains(c))) { ek(a, b, c); return } if ("string" === typeof c) { for (d = 2; this.fb.contains(c + d);)d++; ek(a, b, c + d) } else if (void 0 === c || "number" === typeof c) { for (c = -this.fb.count - 1; this.fb.contains(c);)c--; ek(a, b, c) } else E && v("Model.getKeyForNodeData returned something other than a string or a number: " + c) } } } };
    t.lf = function (a) { null !== a && (Nb(a), this.Ab(a) || rq(this, a, !0)) }; function rq(a, b, c) { var d = a.ra(b); if (void 0 === d || a.fb.K(d) !== b) a.mt(b), d = a.ra(b), void 0 === d ? v("Model.makeNodeDataKeyUnique failed on " + b + ".  Data not added to Model.") : (a.fb.add(d, b), d = null, c && (d = a.sc.length, Na(a.sc, d, b)), Uq(a, "nodeDataArray", qf, "nodeDataArray", a, null, b, null, d), a.wm(b), a.vm(b)) } t.oy = function (a) { if (Ka(a)) for (var b = a.length, c = 0; c < b; c++)this.lf(a[c]); else for (a = a.iterator; a.next();)this.lf(a.value) };
    t.tm = function (a) { null !== a && qq(this, a, !0) }; function qq(a, b, c) { var d = a.ra(b); void 0 !== d && a.fb.remove(d); d = null; if (c) { a: if (c = a.sc, Array.isArray(c)) d = c.indexOf(b); else { d = c.length; for (var e = 0; e < d; e++)if (c[e] === b) { d = e; break a } d = -1 } if (0 > d) return; Oa(a.sc, d) } Uq(a, "nodeDataArray", rf, "nodeDataArray", a, b, null, d, null); a.Cq(b) } t.Yz = function (a) { if (Ka(a)) for (var b = a.length, c = 0; c < b; c++)this.tm(a[c]); else for (a = a.iterator; a.next();)this.tm(a.value) };
    t.Nz = function (a) { if (Ka(a)) { for (var b = new I(this.fb.iteratorKeys), c = new I, d = a.length, e = 0; e < d; e++) { var f = a[e], g = this.ra(f); if (void 0 !== g) { c.add(g); var h = this.Sb(g); null !== h ? this.Uj(h, f) : (h = {}, this.Am(h, g), this.Uj(h, f), this.lf(h)) } else this.lf(f), c.add(this.ra(f)) } for (a = b.iterator; a.next();)b = a.value, c.contains(b) || (b = this.Sb(b)) && this.tm(b) } }; t.xq = function (a, b) { void 0 !== b && (a = Cq(this, a), a instanceof I && this.Hf.add(b, a)) }; t.cw = function () { }; t.wm = function () { }; t.vm = function () { }; t.Cq = function () { };
    function Eq(a, b, c) { if (void 0 !== b) { var d = a.Hf.K(b); null === d && (d = new I, a.Hf.add(b, d)); d.add(c) } } function Dq(a, b, c) { if (void 0 !== b) { var d = a.Hf.K(b); d instanceof I && (void 0 === c || null === c ? a.Hf.remove(b) : (d.remove(c), 0 === d.count && a.Hf.remove(b))) } } function Cq(a, b) { if (void 0 === b) return null; a = a.Hf.K(b); return a instanceof I ? a : null } t.Ru = function (a) { void 0 === a ? this.Hf.clear() : this.Hf.remove(a) };
    X.prototype.copyNodeData = function (a) { if (null === a) return null; var b = this.Mk; a = null !== b ? b(a, this) : Wq(this, a, !0); Ia(a) && qb(a); return a };
    function Wq(a, b, c) {
        if (a.copiesArrays && Array.isArray(b)) { var d = []; for (c = 0; c < b.length; c++) { var e = Wq(a, b[c], a.copiesArrayObjects); d.push(e) } qb(d); return d } if (c && Ia(b)) {
            c = (c = b.constructor) ? new c : {}; e = a.copiesKey || "string" !== typeof a.nodeKeyProperty ? null : a.nodeKeyProperty; for (d in b) if ("__gohashid" === d) c.__gohashid = void 0; else if (d === e) c[e] = void 0; else {
                var f = yn(b, d); var g = Qq(a, f); "GraphObject" === g || "Diagram" === g || "Layer" === g || "RowColumnDefinition" === g || "AnimationManager" === g || "Tool" === g || "CommandHandler" ===
                    g || "Layout" === g || "InputEvent" === g || "DiagramEvent" === g ? (E && "_" !== d[0] && Ga('Warning: found GraphObject or Diagram reference when copying model data on property "' + d + '" of data object: ' + b.toString() + "  \nModel data should not have any references to a Diagram or any part of a diagram, such as: " + f.toString()), g = !0) : g = f instanceof X || f instanceof tf || f instanceof sf || f instanceof nf ? !0 : !1; g ? ek(c, d, f) : (f = Wq(a, f, !1), ek(c, d, f))
            } qb(c); return c
        } return b instanceof J ? b.copy() : b instanceof Zb ? b.copy() : b instanceof
            L ? b.copy() : b instanceof M ? b.copy() : b instanceof Hc ? b.copy() : b
    }
    X.prototype.setDataProperty = function (a, b, c) {
        E && (z(a, "object", X, "setDataProperty:data"), z(b, "string", X, "setDataProperty:propname"), "" === b && v("Model.setDataProperty: property name must not be an empty string when setting " + a + " to " + c)); if (this.Ab(a)) if (b === this.nodeKeyProperty) this.Am(a, c); else { if (b === this.nodeCategoryProperty) { this.zq(a, c); return } } else !Xq && a instanceof N && (Xq = !0, Ga('Model.setDataProperty is modifying a GraphObject, "' + a.toString() + '"'), Ga("  Is that really your intent?")); var d = yn(a,
            b); d !== c && (ek(a, b, c), this.rt(a, b, d, c))
    }; t = X.prototype; t.set = function (a, b, c) { this.setDataProperty(a, b, c) }; t.Uj = function (a, b) { if (b) { var c = this.Ab(a), d; for (d in b) "__gohashid" === d || c && d === this.nodeKeyProperty || this.setDataProperty(a, d, b[d]) } }; t.ky = function (a, b) { this.ct(a, -1, b) };
    t.ct = function (a, b, c) { E && (La(a, X, "insertArrayItem:arr"), B(b, X, "insertArrayItem:idx"), a === this.sc && v("Model.insertArrayItem or Model.addArrayItem should not be called on the Model.nodeDataArray")); 0 > b && (b = a.length); Na(a, b, c); Uq(this, "", qf, "", a, null, c, null, b) };
    t.Ev = function (a, b) { void 0 === b && (b = -1); E && (La(a, X, "removeArrayItem:arr"), B(b, X, "removeArrayItem:idx")); a === this.sc && v("Model.removeArrayItem should not be called on the Model.nodeDataArray"); -1 === b && (b = a.length - 1); var c = a[b]; Oa(a, b); Uq(this, "", rf, "", a, c, null, b, null) }; t.$s = function (a) { if (null === a) return ""; var b = this.Aj; if ("" === b) return ""; b = yn(a, b); if (void 0 === b) return ""; if ("string" === typeof b) return b; v("getCategoryForNodeData found a non-string category for " + a + ": " + b); return "" };
    t.zq = function (a, b) { z(b, "string", X, "setCategoryForNodeData:cat"); if (null !== a) { var c = this.Aj; if ("" !== c) if (this.Ab(a)) { var d = yn(a, c); void 0 === d && (d = ""); d !== b && (ek(a, c, b), Uq(this, "nodeCategory", of, c, a, d, b)) } else ek(a, c, b) } }; t.jm = function () { return !1 }; t.hk = function () { return !1 }; t.im = function () { return !1 }; t.jt = function () { return !1 }; t.Si = function () { return !1 }; function Mi() { return new X }
    function Qq(a, b) { if ("function" === typeof b) { if (b.className) return b.className; if (b.name) return b.name } else if ("object" === typeof b && null !== b && b.constructor) return Qq(a, b.constructor); return typeof b } function Sq(a) { return Yq[a] ? Yq[a] : null } function yn(a, b) { if (!a || !b) return null; try { if ("function" === typeof b) var c = b(a); else "function" === typeof a.getAttribute ? (c = a.getAttribute(b), null === c && (c = void 0)) : c = a[b] } catch (d) { E && Ga("property get error: " + d.toString()) } return c }
    function ek(a, b, c) { if (a && b) try { "function" === typeof b ? b(a, c) : "function" === typeof a.setAttribute ? a.setAttribute(b, c) : a[b] = c } catch (d) { E && Ga("property set error: " + d.toString()) } }
    na.Object.defineProperties(X.prototype, {
        name: { configurable: !0, get: function () { return this.Wa }, set: function (a) { var b = this.Wa; b !== a && (z(a, "string", X, "name"), this.Wa = a, this.g("name", b, a)) } }, dataFormat: { configurable: !0, get: function () { return this.qn }, set: function (a) { var b = this.qn; b !== a && (z(a, "string", X, "dataFormat"), this.qn = a, this.g("dataFormat", b, a)) } }, isReadOnly: {
            configurable: !0, get: function () { return this.Of }, set: function (a) {
                var b = this.Of; b !== a && (z(a, "boolean",
                    X, "isReadOnly"), this.Of = a, this.g("isReadOnly", b, a))
            }
        }, modelData: { configurable: !0, get: function () { return this.l }, set: function (a) { var b = this.l; b !== a && (z(a, "object", X, "modelData"), this.l = a, this.g("modelData", b, a), this.Fa(a)) } }, undoManager: { configurable: !0, get: function () { return this.w }, set: function (a) { var b = this.w; b !== a && (w(a, tf, X, "undoManager"), null !== b && b.Gx(this), this.w = a, null !== a && a.Xw(this)) } }, skipsUndoManager: {
            configurable: !0, get: function () { return this.eh },
            set: function (a) { z(a, "boolean", X, "skipsUndoManager"); this.eh = a }
        }, nodeKeyProperty: { configurable: !0, get: function () { return this.ni }, set: function (a) { var b = this.ni; b !== a && (Vq(a, X, "nodeKeyProperty"), "" === a && v("Model.nodeKeyProperty may not be the empty string"), 0 < this.fb.count && v("Cannot set Model.nodeKeyProperty when there is existing node data"), this.ni = a, this.g("nodeKeyProperty", b, a)) } }, makeUniqueKeyFunction: {
            configurable: !0, get: function () { return this.sl }, set: function (a) {
                var b =
                    this.sl; b !== a && (null !== a && z(a, "function", X, "makeUniqueKeyFunction"), this.sl = a, this.g("makeUniqueKeyFunction", b, a))
            }
        }, nodeDataArray: {
            configurable: !0, get: function () { return this.sc }, set: function (a) {
                var b = this.sc; if (b !== a) {
                    La(a, X, "nodeDataArray"); this.fb.clear(); this.cw(); for (var c = a.length, d = 0; d < c; d++) { var e = a[d]; if (!Ia(e)) { v("Model.nodeDataArray must only contain Objects, not: " + e); return } Nb(e) } this.sc = a; d = new F; for (e = 0; e < c; e++) {
                        var f = a[e], g = this.ra(f); void 0 === g ? d.add(f) : null !== this.fb.K(g) ?
                            d.add(f) : this.fb.add(g, f)
                    } for (d = d.iterator; d.next();)e = d.value, this.mt(e), f = this.ra(e), void 0 !== f && this.fb.add(f, e); Uq(this, "nodeDataArray", of, "nodeDataArray", this, b, a); for (b = 0; b < c; b++)d = a[b], this.wm(d), this.vm(d); this.Ru(); Array.isArray(a) || (this.isReadOnly = !0)
                }
            }
        }, copyNodeDataFunction: { configurable: !0, get: function () { return this.Mk }, set: function (a) { var b = this.Mk; b !== a && (null !== a && z(a, "function", X, "copyNodeDataFunction"), this.Mk = a, this.g("copyNodeDataFunction", b, a)) } }, copiesArrays: {
            configurable: !0,
            enumerable: !0, get: function () { return this.gn }, set: function (a) { var b = this.gn; b !== a && (null !== a && z(a, "boolean", X, "copiesArrays"), this.gn = a, this.g("copiesArrays", b, a)) }
        }, copiesArrayObjects: { configurable: !0, get: function () { return this.fn }, set: function (a) { var b = this.fn; b !== a && (null !== a && z(a, "boolean", X, "copiesArrayObjects"), this.fn = a, this.g("copiesArrayObjects", b, a)) } }, copiesKey: {
            configurable: !0, get: function () { return this.jn }, set: function (a) {
                var b = this.jn; b !== a && (null !== a && z(a,
                    "boolean", X, "copiesKey"), this.jn = a, this.g("copiesKey", b, a))
            }
        }, afterCopyFunction: { configurable: !0, get: function () { return this.Qm }, set: function (a) { var b = this.Qm; b !== a && (null !== a && z(a, "function", X, "afterCopyFunction"), this.Qm = a, this.g("afterCopyFunction", b, a)) } }, nodeCategoryProperty: { configurable: !0, get: function () { return this.Aj }, set: function (a) { var b = this.Aj; b !== a && (Vq(a, X, "nodeCategoryProperty"), this.Aj = a, this.g("nodeCategoryProperty", b, a)) } }
    });
    na.Object.defineProperties(X, { type: { configurable: !0, get: function () { return "Model" } } }); X.prototype.setCategoryForNodeData = X.prototype.zq; X.prototype.getCategoryForNodeData = X.prototype.$s; X.prototype.removeArrayItem = X.prototype.Ev; X.prototype.insertArrayItem = X.prototype.ct; X.prototype.addArrayItem = X.prototype.ky; X.prototype.assignAllDataProperties = X.prototype.Uj; X.prototype.set = X.prototype.set; X.prototype.clearUnresolvedReferences = X.prototype.Ru; X.prototype.mergeNodeDataArray = X.prototype.Nz;
    X.prototype.removeNodeDataCollection = X.prototype.Yz; X.prototype.removeNodeData = X.prototype.tm; X.prototype.addNodeDataCollection = X.prototype.oy; X.prototype.addNodeData = X.prototype.lf; X.prototype.makeNodeDataKeyUnique = X.prototype.mt; X.prototype.findNodeDataForKey = X.prototype.Sb; X.prototype.containsNodeData = X.prototype.Ab; X.prototype.setKeyForNodeData = X.prototype.Am; X.prototype.getKeyForNodeData = X.prototype.ra; X.prototype.updateTargetBindings = X.prototype.Fa; X.prototype.commit = X.prototype.commit;
    X.prototype.rollbackTransaction = X.prototype.xf; X.prototype.commitTransaction = X.prototype.ab; X.prototype.startTransaction = X.prototype.Ca; X.prototype.raiseDataChanged = X.prototype.rt; X.prototype.raiseChanged = X.prototype.g; X.prototype.raiseChangedEvent = X.prototype.cb; X.prototype.removeChangedListener = X.prototype.tk; X.prototype.addChangedListener = X.prototype.rh; X.prototype.writeJsonValue = X.prototype.Dm; X.prototype.replaceJsonObjects = X.prototype.um; X.prototype.applyIncrementalJSON = X.prototype.sy;
    X.prototype.applyIncrementalJson = X.prototype.Zw; X.prototype.toJSON = X.prototype.toJSON; X.prototype.toJson = X.prototype.Bq; X.prototype.toIncrementalJSON = X.prototype.gA; X.prototype.toIncrementalJson = X.prototype.Sx; X.prototype.computeJsonDifference = X.prototype.zy; X.prototype.clear = X.prototype.clear; var Xq = !1, Yq = {}; X.className = "Model";
    X.fromJSON = X.fromJson = function (a, b) {
    void 0 === b && (b = null); null !== b && w(b, X, X, "fromJson:model"); var c = null; if ("string" === typeof a) try { c = qa.JSON.parse(a) } catch (f) { E && Ga("JSON.parse error: " + f.toString()) } else "object" === typeof a ? c = a : v("Unable to construct a Model from: " + a); if (null === b) {
        a = null; var d = c["class"]; if ("string" === typeof d) try { var e = null; 0 === d.indexOf("go.") ? (d = d.substr(3), e = Sq(d)) : (e = Sq(d), void 0 === e && (e = qa[d])); "function" === typeof e && (a = new e) } catch (f) { } null === a || a instanceof X ? b = a : v("Unable to construct a Model of declared class: " +
            c["class"])
    } null === b && (b = X.constructGraphLinksModel()); b.uq(c); b.Dv(c); return b
    }; X.safePropertyValue = yn; X.safePropertySet = ek; Yq.Brush = zl; Yq.ChangedEvent = nf; Yq.Geometry = me; Yq.GraphObject = N; Yq.Margin = Hc; Yq.Panel = W; Yq.Point = J; Yq.Rect = L; Yq.Size = Zb; Yq.Spot = M; Yq.Transaction = sf; Yq.UndoManager = tf;
    function Ti(a, b, c) { qb(this); this.u = !1; void 0 === a ? a = "" : z(a, "string", Ti, "constructor:targetprop"); void 0 === b ? b = a : z(b, "string", Ti, "constructor:sourceprop"); void 0 === c ? c = null : null !== c && z(c, "function", Ti, "constructor:conv"); this.l = -1; this.Sd = null; this.Sl = a; this.Rl = this.Dp = 0; this.Cs = null; this.$n = !1; this.Il = b; this.en = c; this.wo = Zq; this.Zm = null; this.du = new I }
    Ti.prototype.copy = function () { var a = new Ti; a.Sl = this.Sl; a.Dp = this.Dp; a.Rl = this.Rl; a.Cs = this.Cs; a.$n = this.$n; a.Il = this.Il; a.en = this.en; a.wo = this.wo; a.Zm = this.Zm; return a }; t = Ti.prototype; t.hb = function (a) { a.classType === Ti ? this.mode = a : Fa(this, a) }; t.toString = function () { return "Binding(" + this.targetProperty + ":" + this.sourceProperty + (-1 !== this.aj ? " " + this.aj : "") + " " + this.mode.name + ")" }; t.freeze = function () { this.u = !0; return this }; t.ja = function () { this.u = !1; return this };
    t.yx = function (a) { void 0 === a && (a = null); null !== a && z(a, "function", Ti, "makeTwoWay"); this.mode = qn; this.backConverter = a; return this }; t.rq = function (a) { void 0 === a && (a = ""); E && z(a, "string", Ti, "ofObject:srcname"); this.sourceName = a; this.isToModel = !1; return this }; t.Pz = function () { this.sourceName = null; this.isToModel = !0; return this }; function ml(a, b, c) { a = a.sourceName; return null === a || "" === a ? b : "/" === a ? c.part : "." === a ? c : ".." === a ? c.panel : b.bb(a) }
    t.dw = function (a, b, c) {
        var d = this.Il; if (void 0 === c || "" === d || d === c) {
            c = this.Sl; var e = this.en; if (null === e && "" === c) Ga("Binding error: target property is the empty string: " + this.toString()); else {
            E && "string" === typeof c && ("function" !== typeof a.setAttribute && 0 < c.length && "_" !== c[0] && !Ya(a, c) ? Ga("Binding error: undefined target property: " + c + " on " + a.toString()) : "name" === c && a instanceof N && Ga("Binding error: cannot modify GraphObject.name on " + a.toString())); var f = b; "" !== d && (f = yn(b, d)); if (void 0 !== f) if (null ===
                e) "" !== c && ek(a, c, f); else try { if ("" !== c) { var g = e(f, a); E && void 0 === g && Ga('Binding warning: conversion function returned undefined when setting target property "' + c + '" on ' + a.toString() + ", function is: " + e); ek(a, c, g) } else e(f, a) } catch (h) { E && Ga("Binding error: " + h.toString() + ' setting target property "' + c + '" on ' + a.toString() + " with conversion function: " + e) }
            }
        }
    };
    t.Eq = function (a, b, c, d) {
        if (this.wo === qn) {
            var e = this.Sl; if (void 0 === c || e === c) {
                c = this.Il; var f = this.Zm, g = a; "" !== e && (g = yn(a, e)); if (void 0 !== g && !this.du.contains(a)) try {
                    this.du.add(a); var h = null !== d ? d.diagram : null, k = null !== h ? h.model : null; if (null === f) if ("" !== c) null !== k ? (E && k.nodeKeyProperty === c && k.Ab(b) && Ga("Binding error: cannot have TwoWay Binding on node data key property: " + this.toString()), k.setDataProperty(b, c, g)) : ek(b, c, g); else {
                        if (null !== k && null !== d && 0 <= d.itemIndex && null !== d.panel && Array.isArray(d.panel.itemArray)) {
                            var l =
                                d.itemIndex, m = d.panel.itemArray; k.Ev(m, l); k.ct(m, l, g)
                        }
                    } else try {
                        if ("" !== c) { var n = f(g, b, k); null !== k ? (E && (k.nodeKeyProperty === c && k.Ab(b) && Ga("Binding error: cannot have TwoWay Binding on node data key property: " + this.toString()), void 0 === n && Ga('Binding warning: conversion function returned undefined when setting source property "' + c + '" on ' + b.toString() + ", function is: " + f)), k.setDataProperty(b, c, n)) : ek(b, c, n) } else {
                            var p = f(g, b, k); if (void 0 !== p && null !== k && null !== d && 0 <= d.itemIndex && null !== d.panel && Array.isArray(d.panel.itemArray)) {
                                var q =
                                    d.itemIndex, r = d.panel.itemArray; k.Ev(r, q); k.ct(r, q, p)
                            }
                        }
                    } catch (u) { E && Ga("Binding error: " + u.toString() + ' setting source property "' + c + '" on ' + b.toString() + " with conversion function: " + f) }
                } finally { this.du.remove(a) }
            }
        }
    };
    na.Object.defineProperties(Ti.prototype, {
        aj: { configurable: !0, get: function () { return this.l }, set: function (a) { this.u && ya(this); z(a, "number", Ti, "targetId"); this.l = a } }, targetProperty: { configurable: !0, get: function () { return this.Sl }, set: function (a) { this.u && ya(this); z(a, "string", Ti, "targetProperty"); this.Sl = a } }, sourceName: {
            configurable: !0, get: function () { return this.Cs }, set: function (a) {
            this.u && ya(this); null !== a && z(a, "string", Ti, "sourceName"); this.Cs = a; null !== a && (this.$n =
                !1)
            }
        }, isToModel: { configurable: !0, get: function () { return this.$n }, set: function (a) { this.u && ya(this); z(a, "boolean", Ti, "isToModel"); this.$n = a } }, sourceProperty: { configurable: !0, get: function () { return this.Il }, set: function (a) { this.u && ya(this); z(a, "string", Ti, "sourceProperty"); this.Il = a } }, converter: { configurable: !0, get: function () { return this.en }, set: function (a) { this.u && ya(this); null !== a && z(a, "function", Ti, "converter"); this.en = a } }, backConverter: {
            configurable: !0,
            get: function () { return this.Zm }, set: function (a) { this.u && ya(this); null !== a && z(a, "function", Ti, "backConverter"); this.Zm = a }
        }, mode: { configurable: !0, get: function () { return this.wo }, set: function (a) { this.u && ya(this); tb(a, Ti, Ti, "mode"); this.wo = a } }
    }); Ti.prototype.updateSource = Ti.prototype.Eq; Ti.prototype.updateTarget = Ti.prototype.dw; Ti.prototype.ofModel = Ti.prototype.Pz; Ti.prototype.ofObject = Ti.prototype.rq; Ti.prototype.makeTwoWay = Ti.prototype.yx;
    var Zq = new D(Ti, "OneWay", 1), qn = new D(Ti, "TwoWay", 2); Ti.className = "Binding"; Ti.parseEnum = function (a, b) { z(a, "function", Ti, "parseEnum:ctor"); tb(b, a, Ti, "parseEnum:defval"); return function (c) { c = sb(a, c); return null === c ? b : c } }; Ti.toString = Wa; Ti.OneWay = Zq; Ti.TwoWay = qn;
    function $q(a, b) {
        X.call(this); this.It = ',\n  "insertedLinkKeys": '; this.kw = ',\n  "modifiedLinkData": '; this.Kt = ',\n  "removedLinkKeys": '; E && 2 < arguments.length && v("GraphLinksModel constructor can only take two optional arguments, the Array of node data and the Array of link data."); this.Rc = []; this.Pf = new I; this.rb = new Ub; this.ji = ""; this.dj = this.Lk = this.tl = null; this.We = "from"; this.Xe = "to"; this.xj = this.wj = ""; this.vj = "category"; this.Kd = ""; this.xl = "isGroup"; this.ue = "group"; this.hn = !1; void 0 !== a && (this.nodeDataArray =
            a); void 0 !== b && (this.linkDataArray = b)
    } ma($q, X); $q.constructGraphLinksModel = X.constructGraphLinksModel; $q.prototype.cloneProtected = function (a) { X.prototype.cloneProtected.call(this, a); a.ji = this.ji; a.tl = this.tl; a.Lk = this.Lk; a.We = this.We; a.Xe = this.Xe; a.wj = this.wj; a.xj = this.xj; a.vj = this.vj; a.Kd = this.Kd; a.xl = this.xl; a.ue = this.ue; a.hn = this.hn }; t = $q.prototype; t.clear = function () { X.prototype.clear.call(this); this.Rc = []; this.rb.clear(); this.Pf.clear() };
    t.toString = function (a) { void 0 === a && (a = 0); if (2 <= a) return this.Bq(); var b = ("" !== this.name ? this.name : "") + " GraphLinksModel"; if (0 < a) { b += "\n node data:"; a = this.nodeDataArray; var c = a.length, d; for (d = 0; d < c; d++) { var e = a[d]; b += " " + this.ra(e) + ":" + Wa(e) } b += "\n link data:"; a = this.linkDataArray; c = a.length; for (d = 0; d < c; d++)e = a[d], b += " " + xq(this, e, !0) + "--\x3e" + xq(this, e, !1) } return b };
    t.xk = function () {
        var a = X.prototype.xk.call(this), b = ""; "category" !== this.linkCategoryProperty && "string" === typeof this.linkCategoryProperty && (b += ',\n  "linkCategoryProperty": ' + this.quote(this.linkCategoryProperty)); "" !== this.linkKeyProperty && "string" === typeof this.linkKeyProperty && (b += ',\n  "linkKeyProperty": ' + this.quote(this.linkKeyProperty)); "from" !== this.linkFromKeyProperty && "string" === typeof this.linkFromKeyProperty && (b += ',\n  "linkFromKeyProperty": ' + this.quote(this.linkFromKeyProperty)); "to" !==
            this.linkToKeyProperty && "string" === typeof this.linkToKeyProperty && (b += ',\n  "linkToKeyProperty": ' + this.quote(this.linkToKeyProperty)); "" !== this.linkFromPortIdProperty && "string" === typeof this.linkFromPortIdProperty && (b += ',\n  "linkFromPortIdProperty": ' + this.quote(this.linkFromPortIdProperty)); "" !== this.linkToPortIdProperty && "string" === typeof this.linkToPortIdProperty && (b += ',\n  "linkToPortIdProperty": ' + this.quote(this.linkToPortIdProperty)); "" !== this.linkLabelKeysProperty && "string" === typeof this.linkLabelKeysProperty &&
                (b += ',\n  "linkLabelKeysProperty": ' + this.quote(this.linkLabelKeysProperty)); "isGroup" !== this.nodeIsGroupProperty && "string" === typeof this.nodeIsGroupProperty && (b += ',\n  "nodeIsGroupProperty": ' + this.quote(this.nodeIsGroupProperty)); "group" !== this.nodeGroupKeyProperty && "string" === typeof this.nodeGroupKeyProperty && (b += ',\n  "nodeGroupKeyProperty": ' + this.quote(this.nodeGroupKeyProperty)); return a + b
    };
    t.uq = function (a) {
        X.prototype.uq.call(this, a); a.linkKeyProperty && (this.linkKeyProperty = a.linkKeyProperty); a.linkFromKeyProperty && (this.linkFromKeyProperty = a.linkFromKeyProperty); a.linkToKeyProperty && (this.linkToKeyProperty = a.linkToKeyProperty); a.linkFromPortIdProperty && (this.linkFromPortIdProperty = a.linkFromPortIdProperty); a.linkToPortIdProperty && (this.linkToPortIdProperty = a.linkToPortIdProperty); a.linkCategoryProperty && (this.linkCategoryProperty = a.linkCategoryProperty); a.linkLabelKeysProperty && (this.linkLabelKeysProperty =
            a.linkLabelKeysProperty); a.nodeIsGroupProperty && (this.nodeIsGroupProperty = a.nodeIsGroupProperty); a.nodeGroupKeyProperty && (this.nodeGroupKeyProperty = a.nodeGroupKeyProperty)
    }; t.gw = function () { var a = X.prototype.gw.call(this), b = ',\n  "linkDataArray": ' + Nq(this, this.linkDataArray, !0); return a + b }; t.Dv = function (a) { X.prototype.Dv.call(this, a); a = a.linkDataArray; Array.isArray(a) && (this.um(a), this.linkDataArray = a) };
    t.Fq = function (a) {
        if (!(a instanceof $q)) return v("Model.computeJsonDifference: newmodel must be a GraphLinksModel"), ""; E && "" === this.linkKeyProperty && v("GraphLinksModel.linkKeyProperty must not be an empty string for .computeJsonDifference() to succeed."); var b = X.prototype.Fq.call(this, a); Pq(this, a, "linkKeyProperty"); Pq(this, a, "linkFromKeyProperty"); Pq(this, a, "linkToKeyProperty"); Pq(this, a, "linkLabelKeysProperty"); Pq(this, a, "nodeIsGroupProperty"); Pq(this, a, "nodeGroupKeyProperty"); for (var c = new I, d =
            new I, e = (new I).addAll(this.rb.iteratorKeys), f = new Ub, g = a.linkDataArray, h = g.length, k = 0; k < h; k++) { var l = g[k], m = a.kc(l); if (void 0 !== m) { e.remove(m); var n = this.xh(m); null === n ? (c.add(m), d.add(l)) : Oq(this, n, l, f) || d.add(l) } else this.oq(l), m = this.kc(l), c.add(m), d.add(l) } a = b; 0 < c.count && (a += this.It + Nq(this, c.Oa(), !0)); 0 < d.count && (a += this.kw + Nq(this, d.Oa(), !0)); 0 < e.count && (a += this.Kt + Nq(this, e.Oa(), !0)); return a
    };
    t.Et = function (a, b) {
    E && "" === this.linkKeyProperty && v("GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalJson() to succeed."); var c = X.prototype.Et.call(this, a, b), d = this, e = new I, f = new I, g = new I; a.changes.each(function (a) { a.model === d && ("linkDataArray" === a.modelChange ? a.change === qf ? e.add(a.newValue) : a.change === rf && g.add(a.oldValue) : d.De(a.object) && f.add(a.object)) }); var h = new I; e.each(function (a) { h.add(d.kc(a)); b || f.add(a) }); var k = new I; g.each(function (a) { k.add(d.kc(a)); b && f.add(a) });
        a = c; 0 < h.count && (a += (b ? this.Kt : this.It) + Nq(this, h.Oa(), !0)); 0 < f.count && (a += this.kw + Nq(this, f.Oa(), !0)); 0 < k.count && (a += (b ? this.It : this.Kt) + Nq(this, k.Oa(), !0)); return a
    };
    t.Cv = function (a) { X.prototype.Cv.call(this, a); var b = a.insertedLinkKeys; if (Array.isArray(b)) for (var c = b.length, d = 0; d < c; d++) { var e = b[d], f = this.xh(e); null === f && (f = this.Wp({}), this.At(f, e), this.Di(f)) } b = a.modifiedLinkData; if (Array.isArray(b)) for (c = b.length, d = 0; d < c; d++)if (e = b[d], f = this.kc(e), f = this.xh(f), null !== f) for (var g in e) "__gohashid" !== g && g !== this.linkKeyProperty && this.setDataProperty(f, g, e[g]); a = a.removedLinkKeys; if (Array.isArray(a)) for (g = a.length, b = 0; b < g; b++)c = this.xh(a[b]), null !== c && this.sm(c) };
    t.Vj = function (a, b) {
        if (a.change === qf) {
            var c = a.newParam; if ("linkDataArray" === a.modelChange) { a = a.newValue; if (Ia(a) && "number" === typeof c) { var d = this.kc(a); b ? (this.Pf.remove(a), this.Rc[c] === a && this.Rc.splice(c, 1), void 0 !== d && this.rb.remove(d)) : (this.Pf.add(a), this.Rc[c] !== a && this.Rc.splice(c, 0, a), void 0 !== d && this.rb.add(d, a)) } return } if ("linkLabelKeys" === a.modelChange) {
                d = this.sg(a.object); Array.isArray(d) && "number" === typeof c && (b ? (c = d.indexOf(a.newValue), 0 <= c && d.splice(c, 1)) : 0 > d.indexOf(a.newValue) && d.splice(c,
                    0, a.newValue)); return
            }
        } else if (a.change === rf) {
            c = a.oldParam; if ("linkDataArray" === a.modelChange) { a = a.oldValue; Ia(a) && "number" === typeof c && (d = this.kc(a), b ? (this.Pf.add(a), this.Rc[c] !== a && this.Rc.splice(c, 0, a), void 0 !== d && this.rb.add(d, a)) : (this.Pf.remove(a), this.Rc[c] === a && this.Rc.splice(c, 1), void 0 !== d && this.rb.remove(d))); return } if ("linkLabelKeys" === a.modelChange) {
                d = this.sg(a.object); Array.isArray(d) && "number" === typeof c && (b ? 0 > d.indexOf(a.newValue) && d.splice(c, 0, a.newValue) : (c = d.indexOf(a.newValue),
                    0 <= c && d.splice(c, 1))); return
            }
        } X.prototype.Vj.call(this, a, b)
    }; t.km = function (a) { if (void 0 !== a) { var b = this.dj; if (null !== b) { var c = this.Sb(a); null === c && (c = this.copyNodeData(b), ek(c, this.nodeKeyProperty, a), this.lf(c)) } return a } }; t.kz = function (a) { return xq(this, a, !0) }; t.Kx = function (a, b) { Fq(this, a, b, !0) }; t.pz = function (a) { return xq(this, a, !1) }; t.Ox = function (a, b) { Fq(this, a, b, !1) };
    function xq(a, b, c) { if (null !== b && (a = c ? a.We : a.Xe, "" !== a && (a = yn(b, a), void 0 !== a))) { if (zq(a)) return a; v((c ? "FromKey" : "ToKey") + " value for link data " + b + " is not a number or a string: " + a) } }
    function Fq(a, b, c, d) { null === c && (c = void 0); void 0 === c || zq(c) || Ba(c, "number or string", $q, d ? "setFromKeyForLinkData:key" : "setToKeyForLinkData:key"); if (null !== b) { var e = d ? a.We : a.Xe; if ("" !== e) if (c = a.km(c), a.De(b)) { var f = yn(b, e); f !== c && (Dq(a, f, b), ek(b, e, c), null === a.Sb(c) && Eq(a, c, b), Uq(a, d ? "linkFromKey" : "linkToKey", of, e, b, f, c), "string" === typeof e && a.Fa(b, e)) } else ek(b, e, c) } } t.lz = function (a) { return wq(this, a, !0) }; t.Lx = function (a, b) { Gq(this, a, b, !0) }; t.qz = function (a) { return wq(this, a, !1) };
    t.Px = function (a, b) { Gq(this, a, b, !1) }; function wq(a, b, c) { if (null === b) return ""; a = c ? a.wj : a.xj; if ("" === a) return ""; b = yn(b, a); return void 0 === b ? "" : b } function Gq(a, b, c, d) { z(c, "string", $q, d ? "setFromPortIdForLinkData:portname" : "setToPortIdForLinkData:portname"); if (null !== b) { var e = d ? a.wj : a.xj; if ("" !== e) if (a.De(b)) { var f = yn(b, e); void 0 === f && (f = ""); f !== c && (ek(b, e, c), Uq(a, d ? "linkFromPortId" : "linkToPortId", of, e, b, f, c), "string" === typeof e && a.Fa(b, e)) } else ek(b, e, c) } }
    t.sg = function (a) { if (null === a) return ar; var b = this.Kd; if ("" === b) return ar; a = yn(a, b); return void 0 === a ? ar : a }; t.Ov = function (a, b) { La(b, $q, "setLabelKeysForLinkData:arr"); if (null !== a) { var c = this.Kd; if ("" !== c) if (this.De(a)) { var d = yn(a, c); void 0 === d && (d = ar); if (d !== b) { if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++)Dq(this, d[f], a); ek(a, c, b); e = b.length; for (f = 0; f < e; f++) { var g = b[f]; null === this.Sb(g) && Eq(this, g, a) } Uq(this, "linkLabelKeys", of, c, a, d, b); "string" === typeof c && this.Fa(a, c) } } else ek(a, c, b) } };
    t.Lu = function (a, b) { if (null !== b && void 0 !== b && (zq(b) || Ba(b, "number or string", $q, "addLabelKeyForLinkData:key"), null !== a)) { var c = this.Kd; if ("" !== c) { var d = yn(a, c); if (void 0 === d) c = [], c.push(b), this.Ov(a, c); else if (Array.isArray(d)) { var e = d.indexOf(b); 0 <= e || (e = d.length, d.push(b), this.De(a) && (null === this.Sb(b) && Eq(this, b, a), Uq(this, "linkLabelKeys", qf, c, a, null, b, null, e))) } else v(c + " property is not an Array; cannot addLabelKeyForLinkData: " + a) } } };
    t.Fx = function (a, b) { if (null !== b && void 0 !== b && (zq(b) || Ba(b, "number or string", $q, "removeLabelKeyForLinkData:key"), null !== a)) { var c = this.Kd; if ("" !== c) { var d = yn(a, c); if (Array.isArray(d)) { var e = d.indexOf(b); 0 > e || (d.splice(e, 1), this.De(a) && (Dq(this, b, a), Uq(this, "linkLabelKeys", rf, c, a, b, null, e, null))) } else void 0 !== d && v(c + " property is not an Array; cannot removeLabelKeyforLinkData: " + a) } } };
    t.kc = function (a) { if (null !== a) { var b = this.ji; if ("" !== b && (b = yn(a, b), void 0 !== b)) { if (zq(b)) return b; v("Key value for link data " + a + " is not a number or a string: " + b) } } }; t.At = function (a, b) { void 0 !== b && null !== b && zq(b) || Ba(b, "number or string", $q, "setKeyForLinkData:key"); if (null !== a) { var c = this.ji; if ("" !== c) if (this.De(a)) { var d = yn(a, c); d !== b && null === this.xh(b) && (ek(a, c, b), void 0 !== d && this.rb.remove(d), this.rb.add(b, a), Uq(this, "linkKey", of, c, a, d, b), "string" === typeof c && this.Fa(a, c)) } else ek(a, c, b) } };
    t.xh = function (a) { null === a && v("GraphLinksModel.findLinkDataForKey:key must not be null"); return void 0 !== a && zq(a) ? this.rb.K(a) : null };
    t.oq = function (a) { if (null !== a) { var b = this.ji; if ("" !== b) { var c = this.kc(a); if (void 0 === c || this.rb.contains(c)) { var d = this.tl; if (null !== d && (c = d(this, a), void 0 !== c && null !== c && !this.rb.contains(c))) { ek(a, b, c); return } if ("string" === typeof c) { for (d = 2; this.rb.contains(c + d);)d++; ek(a, b, c + d) } else if (void 0 === c || "number" === typeof c) { for (c = -this.rb.count - 1; this.rb.contains(c);)c--; ek(a, b, c) } else E && v("GraphLinksModel.getKeyForLinkData returned something other than a string or a number: " + c) } } } };
    t.De = function (a) { return null === a ? !1 : this.Pf.contains(a) }; t.Di = function (a) { null !== a && (Nb(a), this.De(a) || Bq(this, a, !0)) }; function Bq(a, b, c) { if ("" !== a.linkKeyProperty) { var d = a.kc(b); if (void 0 !== d && a.rb.K(d) === b) return; a.oq(b); d = a.kc(b); if (void 0 === d) { v("GraphLinksModel.makeLinkDataKeyUnique failed on " + b + ". Data not added to model."); return } a.rb.add(d, b) } a.Pf.add(b); d = null; c && (d = a.Rc.length, a.Rc.splice(d, 0, b)); Uq(a, "linkDataArray", qf, "linkDataArray", a, null, b, null, d); br(a, b) }
    t.ny = function (a) { if (Array.isArray(a)) for (var b = a.length, c = 0; c < b; c++)this.Di(a[c]); else for (a = a.iterator; a.next();)this.Di(a.value) }; t.sm = function (a) { null !== a && Aq(this, a, !0) }; function Aq(a, b, c) { a.Pf.remove(b); var d = a.kc(b); void 0 !== d && a.rb.remove(d); d = null; if (c) { d = a.Rc.indexOf(b); if (0 > d) return; a.Rc.splice(d, 1) } Uq(a, "linkDataArray", rf, "linkDataArray", a, b, null, d, null); c = xq(a, b, !0); Dq(a, c, b); c = xq(a, b, !1); Dq(a, c, b); d = a.sg(b); if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++)c = d[f], Dq(a, c, b) }
    t.Wz = function (a) { if (Array.isArray(a)) for (var b = a.length, c = 0; c < b; c++)this.sm(a[c]); else for (a = a.iterator; a.next();)this.sm(a.value) };
    t.Mz = function (a) { E && "" === this.linkKeyProperty && v("GraphLinksModel.linkKeyProperty must not be an empty string for .mergeLinkDataArray() to succeed."); if (Ka(a)) { for (var b = new I(this.rb.iteratorKeys), c = new I, d = a.length, e = 0; e < d; e++) { var f = a[e], g = this.kc(f); if (void 0 !== g) { c.add(g); var h = this.xh(g); null !== h ? this.Uj(h, f) : (h = {}, this.At(h, g), this.Uj(h, f), this.Di(h)) } else this.Di(f), c.add(this.kc(f)) } for (a = b.iterator; a.next();)b = a.value, c.contains(b) || (b = this.xh(b)) && this.sm(b) } };
    function br(a, b) { var c = xq(a, b, !0); c = a.km(c); null === a.Sb(c) && Eq(a, c, b); c = xq(a, b, !1); c = a.km(c); null === a.Sb(c) && Eq(a, c, b); var d = a.sg(b); if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++)c = d[f], null === a.Sb(c) && Eq(a, c, b) } t.Wp = function (a) { if (null === a) return null; var b = this.Lk; a = null !== b ? b(a, this) : Wq(this, a, !0); Ia(a) && (qb(a), "" !== this.We && ek(a, this.We, void 0), "" !== this.Xe && ek(a, this.Xe, void 0), "" !== this.Kd && ek(a, this.Kd, [])); return a };
    t.ht = function (a) { if (null === a) return !1; var b = this.xl; return "" === b ? !1 : yn(a, b) ? !0 : !1 }; t.Oi = function (a) { if (null !== a) { var b = this.ue; if ("" !== b && (b = yn(a, b), void 0 !== b)) { if (zq(b)) return b; v("GroupKey value for node data " + a + " is not a number or a string: " + b) } } };
    t.zt = function (a, b) { null === b && (b = void 0); void 0 === b || zq(b) || Ba(b, "number or string", $q, "setGroupKeyForNodeData:key"); if (null !== a) { var c = this.ue; if ("" !== c) if (this.Ab(a)) { var d = yn(a, c); d !== b && (Dq(this, d, a), ek(a, c, b), null === this.Sb(b) && Eq(this, b, a), Uq(this, "nodeGroupKey", of, c, a, d, b), "string" === typeof c && this.Fa(a, c)) } else ek(a, c, b) } };
    $q.prototype.copyNodeData = function (a) { if (null === a) return null; a = X.prototype.copyNodeData.call(this, a); this.Zj || "" === this.ue || void 0 === yn(a, this.ue) || ek(a, this.ue, void 0); return a };
    $q.prototype.setDataProperty = function (a, b, c) {
        E && (z(a, "object", $q, "setDataProperty:data"), z(b, "string", $q, "setDataProperty:propname"), "" === b && v("GraphLinksModel.setDataProperty: property name must not be an empty string when setting " + a + " to " + c)); if (this.Ab(a)) if (b === this.nodeKeyProperty) this.Am(a, c); else {
            if (b === this.nodeCategoryProperty) { this.zq(a, c); return } if (b === this.nodeGroupKeyProperty) { this.zt(a, c); return } E && b === this.nodeIsGroupProperty && v("GraphLinksModel.setDataProperty: property name must not be the nodeIsGroupProperty: " +
                b)
        } else if (this.De(a)) { if (b === this.linkFromKeyProperty) { Fq(this, a, c, !0); return } if (b === this.linkToKeyProperty) { Fq(this, a, c, !1); return } if (b === this.linkFromPortIdProperty) { Gq(this, a, c, !0); return } if (b === this.linkToPortIdProperty) { Gq(this, a, c, !1); return } if (b === this.linkKeyProperty) { this.At(a, c); return } if (b === this.linkCategoryProperty) { this.yt(a, c); return } if (b === this.linkLabelKeysProperty) { this.Ov(a, c); return } } var d = yn(a, b); d !== c && (ek(a, b, c), this.rt(a, b, d, c))
    }; t = $q.prototype;
    t.Uj = function (a, b) { if (b) { var c = this.Ab(a), d = this.De(a), e; for (e in b) "__gohashid" === e || c && e === this.nodeKeyProperty || d && e === this.linkKeyProperty || this.setDataProperty(a, e, b[e]) } };
    t.xq = function (a, b) {
        X.prototype.xq.call(this, a, b); for (var c = this.fb.iterator; c.next();)this.Iv(c.value, a, b); for (c = this.Pf.iterator; c.next();) {
            var d = c.value, e = a, f = b; if (xq(this, d, !0) === e) { var g = this.We; ek(d, g, f); Uq(this, "linkFromKey", of, g, d, e, f); "string" === typeof g && this.Fa(d, g) } xq(this, d, !1) === e && (g = this.Xe, ek(d, g, f), Uq(this, "linkToKey", of, g, d, e, f), "string" === typeof g && this.Fa(d, g)); g = this.sg(d); if (Array.isArray(g)) for (var h = g.length, k = this.Kd, l = 0; l < h; l++)g[l] === e && (g[l] = f, Uq(this, "linkLabelKeys", qf,
                k, d, e, f, l, l))
        }
    }; t.Iv = function (a, b, c) { if (this.Oi(a) === b) { var d = this.ue; ek(a, d, c); Uq(this, "nodeGroupKey", of, d, a, b, c); "string" === typeof d && this.Fa(a, d) } }; t.cw = function () { X.prototype.cw.call(this); for (var a = this.linkDataArray, b = a.length, c = 0; c < b; c++)br(this, a[c]) };
    t.wm = function (a) {
        X.prototype.wm.call(this, a); a = this.ra(a); var b = Cq(this, a); if (null !== b) {
            var c = Qa(); for (b = b.iterator; b.next();) {
                var d = b.value; if (this.Ab(d)) { if (this.Oi(d) === a) { var e = this.ue; Uq(this, "nodeGroupKey", of, e, d, a, a); "string" === typeof e && this.Fa(d, e); c.push(d) } } else if (xq(this, d, !0) === a && (e = this.We, Uq(this, "linkFromKey", of, e, d, a, a), "string" === typeof e && this.Fa(d, e), c.push(d)), xq(this, d, !1) === a && (e = this.Xe, Uq(this, "linkToKey", of, e, d, a, a), "string" === typeof e && this.Fa(d, e), c.push(d)), e = this.sg(d),
                    Array.isArray(e)) for (var f = e.length, g = this.Kd, h = 0; h < f; h++)e[h] === a && (Uq(this, "linkLabelKeys", qf, g, d, a, a, h, h), c.push(d))
            } for (b = 0; b < c.length; b++)Dq(this, a, c[b]); Ta(c)
        }
    }; t.vm = function (a) { X.prototype.vm.call(this, a); var b = this.Oi(a); null === this.Sb(b) && Eq(this, b, a) }; t.Cq = function (a) { X.prototype.Cq.call(this, a); var b = this.Oi(a); Dq(this, b, a) };
    t.iv = function (a) { if (null === a) return ""; var b = this.vj; if ("" === b) return ""; b = yn(a, b); if (void 0 === b) return ""; if ("string" === typeof b) return b; v("getCategoryForLinkData found a non-string category for " + a + ": " + b); return "" }; $q.prototype.getLinkCategoryForData = function (a) { return this.iv(a) };
    $q.prototype.yt = function (a, b) { z(b, "string", $q, "setCategoryForLinkData:cat"); if (null !== a) { var c = this.vj; if ("" !== c) if (this.De(a)) { var d = yn(a, c); void 0 === d && (d = ""); d !== b && (ek(a, c, b), Uq(this, "linkCategory", of, c, a, d, b), "string" === typeof c && this.Fa(a, c)) } else ek(a, c, b) } }; $q.prototype.setLinkCategoryForData = function (a, b) { this.yt(a, b) }; $q.prototype.hk = function () { return !0 }; $q.prototype.im = function () { return !0 }; $q.prototype.jt = function () { return !0 }; $q.prototype.Si = function () { return !0 };
    na.Object.defineProperties($q.prototype, {
        archetypeNodeData: { configurable: !0, get: function () { return this.dj }, set: function (a) { var b = this.dj; b !== a && (null !== a && z(a, "object", $q, "archetypeNodeData"), this.dj = a, this.g("archetypeNodeData", b, a)) } }, linkFromKeyProperty: { configurable: !0, get: function () { return this.We }, set: function (a) { var b = this.We; b !== a && (Vq(a, $q, "linkFromKeyProperty"), this.We = a, this.g("linkFromKeyProperty", b, a)) } }, linkToKeyProperty: {
            configurable: !0, get: function () { return this.Xe },
            set: function (a) { var b = this.Xe; b !== a && (Vq(a, $q, "linkToKeyProperty"), this.Xe = a, this.g("linkToKeyProperty", b, a)) }
        }, linkFromPortIdProperty: { configurable: !0, get: function () { return this.wj }, set: function (a) { var b = this.wj; b !== a && (Vq(a, $q, "linkFromPortIdProperty"), !E || a !== this.linkFromKeyProperty && a !== this.linkToKeyProperty || v("linkFromPortIdProperty name must not be the same as the GraphLinksModel.linkFromKeyProperty or linkToKeyProperty: " + a), this.wj = a, this.g("linkFromPortIdProperty", b, a)) } },
        linkToPortIdProperty: { configurable: !0, get: function () { return this.xj }, set: function (a) { var b = this.xj; b !== a && (Vq(a, $q, "linkToPortIdProperty"), !E || a !== this.linkFromKeyProperty && a !== this.linkToKeyProperty || v("linkFromPortIdProperty name must not be the same as the GraphLinksModel.linkFromKeyProperty or linkToKeyProperty: " + a), this.xj = a, this.g("linkToPortIdProperty", b, a)) } }, linkLabelKeysProperty: {
            configurable: !0, get: function () { return this.Kd }, set: function (a) {
                var b = this.Kd; b !==
                    a && (Vq(a, $q, "linkLabelKeysProperty"), this.Kd = a, this.g("linkLabelKeysProperty", b, a))
            }
        }, linkDataArray: {
            configurable: !0, get: function () { return this.Rc }, set: function (a) {
                var b = this.Rc; if (b !== a) {
                    La(a, $q, "linkDataArray"); this.rb.clear(); for (var c = a.length, d = 0; d < c; d++) { var e = a[d]; if (!Ia(e)) { v("GraphLinksModel.linkDataArray must only contain Objects, not: " + e); return } Nb(e) } this.Rc = a; if ("" !== this.linkKeyProperty) {
                        d = new F; for (e = 0; e < c; e++) {
                            var f = a[e], g = this.kc(f); void 0 === g ? d.add(f) : null !== this.rb.K(g) ?
                                d.add(f) : this.rb.add(g, f)
                        } for (d = d.iterator; d.next();)e = d.value, this.oq(e), f = this.kc(e), void 0 !== f && this.rb.add(f, e)
                    } d = new I; for (e = 0; e < c; e++)d.add(a[e]); this.Pf = d; Uq(this, "linkDataArray", of, "linkDataArray", this, b, a); for (b = 0; b < c; b++)br(this, a[b])
                }
            }
        }, linkKeyProperty: {
            configurable: !0, get: function () { return this.ji }, set: function (a) {
                var b = this.ji; if (b !== a) {
                    Vq(a, $q, "linkKeyProperty"); this.ji = a; this.rb.clear(); for (var c = this.linkDataArray.length, d = 0; d < c; d++) {
                        var e = this.linkDataArray[d], f = this.kc(e);
                        void 0 === f && (this.oq(e), f = this.kc(e)); void 0 !== f && this.rb.add(f, e)
                    } this.g("linkKeyProperty", b, a)
                }
            }
        }, makeUniqueLinkKeyFunction: { configurable: !0, get: function () { return this.tl }, set: function (a) { var b = this.tl; b !== a && (null !== a && z(a, "function", $q, "makeUniqueLinkKeyFunction"), this.tl = a, this.g("makeUniqueLinkKeyFunction", b, a)) } }, copyLinkDataFunction: {
            configurable: !0, get: function () { return this.Lk }, set: function (a) {
                var b = this.Lk; b !== a && (null !== a && z(a, "function", $q, "copyLinkDataFunction"),
                    this.Lk = a, this.g("copyLinkDataFunction", b, a))
            }
        }, nodeIsGroupProperty: { configurable: !0, get: function () { return this.xl }, set: function (a) { var b = this.xl; b !== a && (Vq(a, $q, "nodeIsGroupProperty"), this.xl = a, this.g("nodeIsGroupProperty", b, a)) } }, nodeGroupKeyProperty: { configurable: !0, get: function () { return this.ue }, set: function (a) { var b = this.ue; b !== a && (Vq(a, $q, "nodeGroupKeyProperty"), this.ue = a, this.g("nodeGroupKeyProperty", b, a)) } }, Zj: {
            configurable: !0, get: function () { return this.hn },
            set: function (a) { this.hn !== a && (z(a, "boolean", $q, "copiesGroupKeyOfNodeData"), this.hn = a) }
        }, linkCategoryProperty: { configurable: !0, get: function () { return this.vj }, set: function (a) { var b = this.vj; b !== a && (Vq(a, $q, "linkCategoryProperty"), this.vj = a, this.g("linkCategoryProperty", b, a)) } }
    }); na.Object.defineProperties($q, { type: { configurable: !0, get: function () { return "GraphLinksModel" } } }); $q.prototype.setCategoryForLinkData = $q.prototype.yt; $q.prototype.getCategoryForLinkData = $q.prototype.iv;
    $q.prototype.assignAllDataProperties = $q.prototype.Uj; $q.prototype.setGroupKeyForNodeData = $q.prototype.zt; $q.prototype.getGroupKeyForNodeData = $q.prototype.Oi; $q.prototype.isGroupForNodeData = $q.prototype.ht; $q.prototype.copyLinkData = $q.prototype.Wp; $q.prototype.mergeLinkDataArray = $q.prototype.Mz; $q.prototype.removeLinkDataCollection = $q.prototype.Wz; $q.prototype.removeLinkData = $q.prototype.sm; $q.prototype.addLinkDataCollection = $q.prototype.ny; $q.prototype.addLinkData = $q.prototype.Di;
    $q.prototype.containsLinkData = $q.prototype.De; $q.prototype.makeLinkDataKeyUnique = $q.prototype.oq; $q.prototype.findLinkDataForKey = $q.prototype.xh; $q.prototype.setKeyForLinkData = $q.prototype.At; $q.prototype.getKeyForLinkData = $q.prototype.kc; $q.prototype.removeLabelKeyForLinkData = $q.prototype.Fx; $q.prototype.addLabelKeyForLinkData = $q.prototype.Lu; $q.prototype.setLabelKeysForLinkData = $q.prototype.Ov; $q.prototype.getLabelKeysForLinkData = $q.prototype.sg; $q.prototype.setToPortIdForLinkData = $q.prototype.Px;
    $q.prototype.getToPortIdForLinkData = $q.prototype.qz; $q.prototype.setFromPortIdForLinkData = $q.prototype.Lx; $q.prototype.getFromPortIdForLinkData = $q.prototype.lz; $q.prototype.setToKeyForLinkData = $q.prototype.Ox; $q.prototype.getToKeyForLinkData = $q.prototype.pz; $q.prototype.setFromKeyForLinkData = $q.prototype.Kx; $q.prototype.getFromKeyForLinkData = $q.prototype.kz; $q.prototype.clear = $q.prototype.clear; var ar = Object.freeze([]); $q.className = "GraphLinksModel"; Yq.GraphLinksModel = $q;
    X.constructGraphLinksModel = X.constructGraphLinksModel = function () { return new $q }; X.initDiagramModel = Mi = function () { return new $q }; function cr(a) { E && 1 < arguments.length && v("TreeModel constructor can only take one optional argument, the Array of node data."); X.call(this); this.ve = "parent"; this.kn = !1; this.Dj = "parentLinkCategory"; void 0 !== a && (this.nodeDataArray = a) } ma(cr, X); cr.constructGraphLinksModel = X.constructGraphLinksModel;
    cr.prototype.cloneProtected = function (a) { X.prototype.cloneProtected.call(this, a); a.ve = this.ve; a.kn = this.kn; a.Dj = this.Dj }; t = cr.prototype; t.toString = function (a) { void 0 === a && (a = 0); if (2 <= a) return this.Bq(); var b = ("" !== this.name ? this.name : "") + " TreeModel"; if (0 < a) { b += "\n node data:"; a = this.nodeDataArray; for (var c = a.length, d = 0; d < c; d++) { var e = a[d]; b += " " + this.ra(e) + ":" + Wa(e) } } return b };
    t.xk = function () { var a = X.prototype.xk.call(this), b = ""; "parent" !== this.nodeParentKeyProperty && "string" === typeof this.nodeParentKeyProperty && (b += ',\n  "nodeParentKeyProperty": ' + this.quote(this.nodeParentKeyProperty)); return a + b }; t.uq = function (a) { X.prototype.uq.call(this, a); a.nodeParentKeyProperty && (this.nodeParentKeyProperty = a.nodeParentKeyProperty) }; t.Fq = function (a) { Pq(this, a, "nodeParentKeyProperty"); return X.prototype.Fq.call(this, a) }; t.km = function (a) { return a };
    t.Qi = function (a) { if (null !== a) { var b = this.ve; if ("" !== b && (b = yn(a, b), void 0 !== b)) { if (zq(b)) return b; v("ParentKey value for node data " + a + " is not a number or a string: " + b) } } };
    t.Ke = function (a, b) { null === b && (b = void 0); void 0 === b || zq(b) || Ba(b, "number or string", cr, "setParentKeyForNodeData:key"); if (null !== a) { var c = this.ve; if ("" !== c) if (b = this.km(b), this.Ab(a)) { var d = yn(a, c); d !== b && (Dq(this, d, a), ek(a, c, b), null === this.Sb(b) && Eq(this, b, a), Uq(this, "nodeParentKey", of, c, a, d, b), "string" === typeof c && this.Fa(a, c)) } else ek(a, c, b) } };
    t.jv = function (a) { if (null === a) return ""; var b = this.Dj; if ("" === b) return ""; b = yn(a, b); if (void 0 === b) return ""; if ("string" === typeof b) return b; v("getParentLinkCategoryForNodeData found a non-string category for " + a + ": " + b); return "" }; cr.prototype.getLinkCategoryForData = function (a) { return this.jv(a) };
    cr.prototype.Pv = function (a, b) { z(b, "string", cr, "setParentLinkCategoryForNodeData:cat"); if (null !== a) { var c = this.Dj; if ("" !== c) if (this.Ab(a)) { var d = yn(a, c); void 0 === d && (d = ""); d !== b && (ek(a, c, b), Uq(this, "parentLinkCategory", of, c, a, d, b), "string" === typeof c && this.Fa(a, c)) } else ek(a, c, b) } }; cr.prototype.setLinkCategoryForData = function (a, b) { this.Pv(a, b) };
    cr.prototype.copyNodeData = function (a) { if (null === a) return null; a = X.prototype.copyNodeData.call(this, a); this.$j || "" === this.ve || void 0 === yn(a, this.ve) || ek(a, this.ve, void 0); return a };
    cr.prototype.setDataProperty = function (a, b, c) { E && (z(a, "object", cr, "setDataProperty:data"), z(b, "string", cr, "setDataProperty:propname"), "" === b && v("TreeModel.setDataProperty: property name must not be an empty string when setting " + a + " to " + c)); if (this.Ab(a)) if (b === this.nodeKeyProperty) this.Am(a, c); else { if (b === this.nodeCategoryProperty) { this.zq(a, c); return } if (b === this.nodeParentKeyProperty) { this.Ke(a, c); return } } var d = yn(a, b); d !== c && (ek(a, b, c), this.rt(a, b, d, c)) }; t = cr.prototype;
    t.xq = function (a, b) { X.prototype.xq.call(this, a, b); for (var c = this.fb.iterator; c.next();)this.Iv(c.value, a, b) }; t.Iv = function (a, b, c) { if (this.Qi(a) === b) { var d = this.ve; ek(a, d, c); Uq(this, "nodeParentKey", of, d, a, b, c); "string" === typeof d && this.Fa(a, d) } };
    t.wm = function (a) { X.prototype.wm.call(this, a); a = this.ra(a); var b = Cq(this, a); if (null !== b) { var c = Qa(); for (b = b.iterator; b.next();) { var d = b.value; if (this.Ab(d) && this.Qi(d) === a) { var e = this.ve; Uq(this, "nodeParentKey", of, e, d, a, a); "string" === typeof e && this.Fa(d, e); c.push(d) } } for (b = 0; b < c.length; b++)Dq(this, a, c[b]); Ta(c) } }; t.vm = function (a) { X.prototype.vm.call(this, a); var b = this.Qi(a); b = this.km(b); null === this.Sb(b) && Eq(this, b, a) }; t.Cq = function (a) { X.prototype.Cq.call(this, a); var b = this.Qi(a); Dq(this, b, a) };
    t.jm = function () { return !0 }; t.jt = function () { return !0 };
    na.Object.defineProperties(cr.prototype, {
        nodeParentKeyProperty: { configurable: !0, get: function () { return this.ve }, set: function (a) { var b = this.ve; b !== a && (Vq(a, cr, "nodeParentKeyProperty"), this.ve = a, this.g("nodeParentKeyProperty", b, a)) } }, $j: { configurable: !0, get: function () { return this.kn }, set: function (a) { this.kn !== a && (z(a, "boolean", cr, "copiesParentKeyOfNodeData"), this.kn = a) } }, parentLinkCategoryProperty: {
            configurable: !0, get: function () { return this.Dj }, set: function (a) {
                var b =
                    this.Dj; b !== a && (Vq(a, cr, "parentLinkCategoryProperty"), this.Dj = a, this.g("parentLinkCategoryProperty", b, a))
            }
        }, linkCategoryProperty: { configurable: !0, get: function () { return this.parentLinkCategoryProperty }, set: function (a) { this.parentLinkCategoryProperty = a } }
    }); na.Object.defineProperties(cr, { type: { configurable: !0, get: function () { return "TreeModel" } } }); cr.prototype.setParentLinkCategoryForNodeData = cr.prototype.Pv; cr.prototype.getParentLinkCategoryForNodeData = cr.prototype.jv;
    cr.prototype.setParentKeyForNodeData = cr.prototype.Ke; cr.prototype.getParentKeyForNodeData = cr.prototype.Qi; cr.className = "TreeModel"; Yq.TreeModel = cr; function dr() { 0 < arguments.length && Da(dr); Ni.call(this); this.Bw = this.Dn = this.Zb = 0; this.rr = 360; this.Aw = er; this.jj = 0; this.mw = new J; this.cr = this.Td = 0; this.Ms = new fr; this.Rt = this.Cj = 0; this.ay = 600; this.Yo = NaN; this.Wm = 1; this.Ap = 0; this.Ol = 360; this.Db = er; this.M = hr; this.Tc = ir; this.Pc = aq; this.bf = 6; this.Io = jr } ma(dr, Ni);
    dr.prototype.cloneProtected = function (a) { Ni.prototype.cloneProtected.call(this, a); a.Yo = this.Yo; a.Wm = this.Wm; a.Ap = this.Ap; a.Ol = this.Ol; a.Db = this.Db; a.M = this.M; a.Tc = this.Tc; a.Pc = this.Pc; a.bf = this.bf; a.Io = this.Io };
    dr.prototype.hb = function (a) { if (a.classType === dr) if (a === kr || a === lr || a === mr || a === nr || a === ir) this.sorting = a; else if (a === or || a === pr || a === hr || a === qr) this.direction = a; else if (a === rr || a === sr || a === er || a === tr) this.arrangement = a; else { if (a === ur || a === jr) this.nodeDiameterFormula = a } else Ni.prototype.hb.call(this, a) }; dr.prototype.createNetwork = function () { return new vr(this) };
    dr.prototype.doLayout = function (a) {
    E && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"); null === this.network && (this.network = this.makeNetwork(a)); this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin); a = this.network.vertexes; if (1 >= a.count) 1 === a.count && (a = a.first(), a.centerX = 0, a.centerY = 0); else {
        var b = new F; b.addAll(a.iterator); a = new F; var c = new F; var d = this.sort(b); var e, f, g = this.cr; var h = this.arrangement; var k = this.nodeDiameterFormula;
        var l = this.radius; if (!isFinite(l) || 0 >= l) l = NaN; var m = this.aspectRatio; if (!isFinite(m) || 0 >= m) m = 1; var n = this.startAngle; isFinite(n) || (n = 0); var p = this.sweepAngle; if (!isFinite(p) || 360 < p || 1 > p) p = 360; b = this.spacing; isFinite(b) || (b = NaN); h === tr && k === ur ? h = er : h === tr && k !== ur && (h = this.arrangement); if ((this.direction === or || this.direction === pr) && this.sorting !== ir) {
            for (k = 0; !(k >= d.length); k += 2) { a.add(d.O(k)); if (k + 1 >= d.length) break; c.add(d.O(k + 1)) } this.direction === or ? (this.arrangement === tr && a.reverse(), d = new F, d.addAll(a),
                d.addAll(c)) : (this.arrangement === tr && c.reverse(), d = new F, d.addAll(c), d.addAll(a))
        } k = d.length; for (var q = f = e = 0; q < d.length; q++) { var r = n + p * f * (this.direction === hr ? 1 : -1) / k, u = d.O(q).diameter; isNaN(u) && (u = wr(d.O(q), r)); 360 > p && (0 === q || q === d.length - 1) && (u /= 2); e += u; f++ } if (isNaN(l) || h === tr) {
        isNaN(b) && (b = 6); if (h !== er && h !== tr) {
            f = -Infinity; for (g = 0; g < k; g++)q = d.O(g), e = d.O(g === k - 1 ? 0 : g + 1), isNaN(q.diameter) && wr(q, 0), isNaN(e.diameter) && wr(e, 0), f = Math.max(f, (q.diameter + e.diameter) / 2); g = f + b; h === rr ? l = (f + b) / (2 * Math.PI / k) :
                l = xr(this, g * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180)
        } else l = xr(this, e + (360 <= p ? k : k - 1) * (h !== tr ? b : 1.6 * b), m, n * Math.PI / 180, p * Math.PI / 180); f = l * m
        } else if (f = l * m, q = yr(this, l, f, n * Math.PI / 180, p * Math.PI / 180), isNaN(b)) { if (h === er || h === tr) b = (q - e) / (360 <= p ? k : k - 1) } else if (h === er || h === tr) q = (q - e) / (360 <= p ? k : k - 1), q < b ? (l = xr(this, e + b * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180), f = l * m) : b = q; else {
            g = -Infinity; for (e = 0; e < k; e++)r = d.O(e), u = d.O(e === k - 1 ? 0 : e + 1), isNaN(r.diameter) && wr(r, 0), isNaN(u.diameter) && wr(u, 0), g = Math.max(g,
                (r.diameter + u.diameter) / 2); g += b; e = xr(this, g * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180); e > l ? (l = e, f = l * m) : g = q / (360 <= p ? k : k - 1)
        } this.Aw = h; this.Zb = l; this.Dn = m; this.Bw = n; this.rr = p; this.jj = b; this.Td = f; this.cr = g; b = d; d = this.Aw; h = this.Zb; l = this.Bw; m = this.rr; n = this.jj; p = this.Td; k = this.cr; if (this.direction !== or && this.direction !== pr || d !== tr) if (this.direction === or || this.direction === pr) {
            g = 0; switch (d) {
                case sr: g = 180 * zr(this, h, p, l, k) / Math.PI; break; case er: k = b = 0; g = a.first(); null !== g && (b = wr(g, Math.PI / 2)); g = c.first();
                    null !== g && (k = wr(g, Math.PI / 2)); g = 180 * zr(this, h, p, l, n + (b + k) / 2) / Math.PI; break; case rr: g = m / b.length
            }if (this.direction === or) { switch (d) { case sr: Ar(this, a, l, qr); break; case er: Br(this, a, l, qr); break; case rr: Cr(this, a, m / 2, l, qr) }switch (d) { case sr: Ar(this, c, l + g, hr); break; case er: Br(this, c, l + g, hr); break; case rr: Cr(this, c, m / 2, l + g, hr) } } else {
                switch (d) { case sr: Ar(this, c, l, qr); break; case er: Br(this, c, l, qr); break; case rr: Cr(this, c, m / 2, l, qr) }switch (d) {
                    case sr: Ar(this, a, l + g, hr); break; case er: Br(this, a, l + g, hr); break; case rr: Cr(this,
                        a, m / 2, l + g, hr)
                }
            }
        } else switch (d) { case sr: Ar(this, b, l, this.direction); break; case er: Br(this, b, l, this.direction); break; case rr: Cr(this, b, m, l, this.direction); break; case tr: Dr(this, b, m, l, this.direction) } else Dr(this, b, m, l - m / 2, hr)
    } this.updateParts(); this.network = null; this.isValidLayout = !0
    };
    function Cr(a, b, c, d, e) { var f = a.rr, g = a.Zb; a = a.Td; d = d * Math.PI / 180; c = c * Math.PI / 180; for (var h = b.length, k = 0; k < h; k++) { var l = d + (e === hr ? k * c / (360 <= f ? h : h - 1) : -(k * c) / h), m = b.O(k), n = g * Math.tan(l) / a; n = Math.sqrt((g * g + a * a * n * n) / (1 + n * n)); m.centerX = n * Math.cos(l); m.centerY = n * Math.sin(l); m.actualAngle = 180 * l / Math.PI } }
    function Br(a, b, c, d) { var e = a.Zb, f = a.Td, g = a.jj; c = c * Math.PI / 180; for (var h = b.length, k = 0; k < h; k++) { var l = b.O(k), m = b.O(k === h - 1 ? 0 : k + 1), n = f * Math.sin(c); l.centerX = e * Math.cos(c); l.centerY = n; l.actualAngle = 180 * c / Math.PI; isNaN(l.diameter) && wr(l, 0); isNaN(m.diameter) && wr(m, 0); l = zr(a, e, f, d === hr ? c : -c, (l.diameter + m.diameter) / 2 + g); c += d === hr ? l : -l } }
    function Ar(a, b, c, d) { var e = a.Zb, f = a.Td, g = a.cr; c = c * Math.PI / 180; for (var h = b.length, k = 0; k < h; k++) { var l = b.O(k); l.centerX = e * Math.cos(c); l.centerY = f * Math.sin(c); l.actualAngle = 180 * c / Math.PI; l = zr(a, e, f, d === hr ? c : -c, g); c += d === hr ? l : -l } } function Dr(a, b, c, d, e) { var f = a.rr; a.Cj = 0; a.Ms = new fr; if (360 > c) { for (f = d + (e === hr ? f : -f); 0 > f;)f += 360; f %= 360; 180 < f && (f -= 360); f *= Math.PI / 180; a.Rt = f; Er(a, b, c, d, e) } else Fr(a, b, c, d, e); a.Ms.commit(b) }
    function Fr(a, b, c, d, e) {
        var f = a.Zb, g = a.jj, h = a.Dn, k = f * Math.cos(d * Math.PI / 180), l = a.Td * Math.sin(d * Math.PI / 180), m = b.Oa(); if (3 === m.length) m[0].centerX = f, m[0].centerY = 0, m[1].centerX = m[0].centerX - m[0].width / 2 - m[1].width / 2 - g, m[1].y = m[0].y, m[2].centerX = (m[0].centerX + m[1].centerX) / 2, m[2].y = m[0].y - m[2].height - g; else if (4 === m.length) m[0].centerX = f, m[0].centerY = 0, m[2].centerX = -m[0].centerX, m[2].centerY = m[0].centerY, m[1].centerX = 0, m[1].y = Math.min(m[0].y, m[2].y) - m[1].height - g, m[3].centerX = 0, m[3].y = Math.max(m[0].y +
            m[0].height + g, m[2].y + m[2].height + g); else {
                f = J.alloc(); for (var n = 0; n < m.length; n++) { m[n].centerX = k; m[n].centerY = l; if (n >= m.length - 1) break; Gr(a, k, l, m, n, e, f) || Hr(a, k, l, m, n, e, f); k = f.x; l = f.y } J.free(f); a.Cj++; if (!(23 < a.Cj)) {
                    k = m[0].centerX; l = m[0].centerY; f = m[m.length - 1].centerX; n = m[m.length - 1].centerY; var p = Math.abs(k - f) - ((m[0].width + m[m.length - 1].width) / 2 + g), q = Math.abs(l - n) - ((m[0].height + m[m.length - 1].height) / 2 + g); g = 0; 1 > Math.abs(q) ? Math.abs(k - f) < (m[0].width + m[m.length - 1].width) / 2 && (g = 0) : g = 0 < q ? q : 1 > Math.abs(p) ?
                        0 : p; k = Math.abs(f) > Math.abs(n) ? 0 < f !== l > n : 0 < n !== k < f; if (k = e === hr ? k : !k) g = -Math.abs(g), g = Math.min(g, -m[m.length - 1].width), g = Math.min(g, -m[m.length - 1].height); a.Ms.compare(g, m); 1 < Math.abs(g) && (a.Zb = 8 > a.Cj ? a.Zb - g / (2 * Math.PI) : 5 > m.length && 10 < g ? a.Zb / 2 : a.Zb - (0 < g ? 1.7 : -2.3), a.Td = a.Zb * h, Fr(a, b, c, d, e))
                }
        }
    }
    function Er(a, b, c, d, e) {
        for (var f = a.Zb, g = a.Td, h = a.Dn, k = f * Math.cos(d * Math.PI / 180), l = g * Math.sin(d * Math.PI / 180), m = J.alloc(), n = b.Oa(), p = 0; p < n.length; p++) { n[p].centerX = k; n[p].centerY = l; if (p >= n.length - 1) break; Gr(a, k, l, n, p, e, m) || Hr(a, k, l, n, p, e, m); k = m.x; l = m.y } J.free(m); a.Cj++; if (!(23 < a.Cj)) {
            k = Math.atan2(l, k); k = e === hr ? a.Rt - k : k - a.Rt; k = Math.abs(k) < Math.abs(k - 2 * Math.PI) ? k : k - 2 * Math.PI; f = k * (f + g) / 2; g = a.Ms; if (Math.abs(f) < Math.abs(g.em)) for (g.em = f, g.yk = [], g.Em = [], k = 0; k < n.length; k++)g.yk[k] = n[k].bounds.x, g.Em[k] = n[k].bounds.y;
            1 < Math.abs(f) && (a.Zb = 8 > a.Cj ? a.Zb - f / (2 * Math.PI) : a.Zb - (0 < f ? 1.7 : -2.3), a.Td = a.Zb * h, Er(a, b, c, d, e))
        }
    } function Gr(a, b, c, d, e, f, g) { var h = a.Zb, k = a.Td, l = 0; a = (d[e].width + d[e + 1].width) / 2 + a.jj; var m = !1; if (0 <= c !== (f === hr)) { if (f = b + a, f > h) { f = b - a; if (f < -h) return g.x = f, g.y = l, !1; m = !0 } } else if (f = b - a, f < -h) { f = b + a; if (f > h) return g.x = f, g.y = l, !1; m = !0 } l = Math.sqrt(1 - Math.min(1, f * f / (h * h))) * k; 0 > c !== m && (l = -l); if (Math.abs(c - l) > (d[e].height + d[e + 1].height) / 2) return g.x = f, g.y = l, !1; g.x = f; g.y = l; return !0 }
    function Hr(a, b, c, d, e, f, g) { var h = a.Zb, k = a.Td, l = 0; a = (d[e].height + d[e + 1].height) / 2 + a.jj; d = !1; if (0 <= b !== (f === hr)) { if (f = c - a, f < -k) { f = c + a; if (f > k) { g.x = l; g.y = f; return } d = !0 } } else if (f = c + a, f > k) { f = c - a; if (f < -k) { g.x = l; g.y = f; return } d = !0 } l = Math.sqrt(1 - Math.min(1, f * f / (k * k))) * h; 0 > b !== d && (l = -l); g.x = l; g.y = f } dr.prototype.commitLayout = function () { this.commitNodes(); this.isRouting && this.commitLinks() };
    dr.prototype.commitNodes = function () { var a = null !== this.group && null !== this.group.placeholder && this.group.isSubGraphExpanded, b = a ? this.group.location.copy() : null, c = this.actualCenter; a ? c = new J(0, 0) : (c.x = this.arrangementOrigin.x + this.Zb, c.y = this.arrangementOrigin.y + this.Td); for (var d = this.network.vertexes.iterator; d.next();) { var e = d.value; e.x += c.x; e.y += c.y; e.commit() } a && (this.group.bc(), a = this.group.position.copy(), c = this.group.location.copy(), b = b.Zd(c.Zd(a)), this.group.move(b), this.mw = b.Zd(a)) };
    dr.prototype.commitLinks = function () { for (var a = this.network.edges.iterator; a.next();)a.value.commit() }; function yr(a, b, c, d, e) { var f = a.ay; if (.001 > Math.abs(a.Dn - 1)) return void 0 !== d && void 0 !== e ? e * b : 2 * Math.PI * b; a = b > c ? Math.sqrt(b * b - c * c) / b : Math.sqrt(c * c - b * b) / c; var g = 0; var h = void 0 !== d && void 0 !== e ? e / (f + 1) : Math.PI / (2 * (f + 1)); for (var k = 0, l = 0; l <= f; l++) { void 0 !== d && void 0 !== e ? k = d + l * e / f : k = l * Math.PI / (2 * f); var m = Math.sin(k); g += Math.sqrt(1 - a * a * m * m) * h } return void 0 !== d && void 0 !== e ? (b > c ? b : c) * g : 4 * (b > c ? b : c) * g }
    function xr(a, b, c, d, e) { return b / (void 0 !== d && void 0 !== e ? yr(a, 1, c, d, e) : yr(a, 1, c)) } function zr(a, b, c, d, e) { if (.001 > Math.abs(a.Dn - 1)) return e / b; var f = b > c ? Math.sqrt(b * b - c * c) / b : Math.sqrt(c * c - b * b) / c, g = 0; a = 2 * Math.PI / (700 * a.network.vertexes.count); b > c && (d += Math.PI / 2); for (var h = 0; ; h++) { var k = Math.sin(d + h * a); g += (b > c ? b : c) * Math.sqrt(1 - f * f * k * k) * a; if (g >= e) return h * a } }
    dr.prototype.sort = function (a) {
        switch (this.sorting) {
            case mr: break; case nr: a.reverse(); break; case kr: a.sort(this.comparer); break; case lr: a.sort(this.comparer); a.reverse(); break; case ir: for (var b = [], c = 0; c < a.length; c++)b.push(0); c = new F; for (var d = 0; d < a.length; d++) {
                var e = -1, f = -1; if (0 === d) for (var g = 0; g < a.length; g++) { var h = a.O(g).edgesCount; h > e && (e = h, f = g) } else for (g = 0; g < a.length; g++)h = b[g], h > e && (e = h, f = g); c.add(a.O(f)); b[f] = -1; f = a.O(f); for (g = f.sourceEdges; g.next();)e = a.indexOf(g.value.fromVertex), 0 > e || 0 <=
                    b[e] && b[e]++; for (f = f.destinationEdges; f.next();)e = a.indexOf(f.value.toVertex), 0 > e || 0 <= b[e] && b[e]++
            } a = []; for (b = 0; b < c.length; b++) { e = c.O(b); a[b] = []; for (f = e.destinationEdges; f.next();)d = c.indexOf(f.value.toVertex), d !== b && 0 > a[b].indexOf(d) && a[b].push(d); for (e = e.sourceEdges; e.next();)d = c.indexOf(e.value.fromVertex), d !== b && 0 > a[b].indexOf(d) && a[b].push(d) } f = []; for (b = 0; b < a.length; b++)f[b] = 0; b = []; g = []; h = []; e = []; d = new F; for (var k = 0, l = 0; l < a.length; l++) {
                var m = a[l].length; if (1 === m) e.push(l); else if (0 === m) d.add(c.O(l));
                else {
                    if (0 === k) b.push(l); else {
                        for (var n = m = Infinity, p = -1, q = [], r = 0; r < b.length; r++)0 > a[b[r]].indexOf(b[r === b.length - 1 ? 0 : r + 1]) && q.push(r === b.length - 1 ? 0 : r + 1); if (0 === q.length) for (r = 0; r < b.length; r++)q.push(r); for (r = 0; r < q.length; r++) {
                            for (var u = q[r], x = a[l], y = 0, A = 0; A < g.length; A++) {
                                var C = f[g[A]], G = f[h[A]]; if (C < G) { var H = C; C = G } else H = G; if (H < u && u <= C) for (G = 0; G < x.length; G++) { var O = x[G]; 0 > b.indexOf(O) || H < f[O] && f[O] < C || H === f[O] || C === f[O] || y++ } else for (G = 0; G < x.length; G++)O = x[G], 0 > b.indexOf(O) || H < f[O] && f[O] < C && H !== f[O] &&
                                    C !== f[O] && y++
                            } x = y; for (A = y = 0; A < a[l].length; A++)H = b.indexOf(a[l][A]), 0 <= H && (H = Math.abs(u - (H >= u ? H + 1 : H)), y += H < b.length + 1 - H ? H : b.length + 1 - H); for (A = 0; A < g.length; A++)H = f[g[A]], C = f[h[A]], H >= u && H++ , C >= u && C++ , H > C && (G = C, C = H, H = G), C - H < (b.length + 2) / 2 === (H < u && u <= C) && y++; if (x < m || x === m && y < n) m = x, n = y, p = u
                        } b.splice(p, 0, l); for (m = 0; m < b.length; m++)f[b[m]] = m; for (m = 0; m < a[l].length; m++)n = a[l][m], 0 <= b.indexOf(n) && (g.push(l), h.push(n))
                    } k++
                }
            } for (g = b.length; ;) {
                f = !0; for (h = 0; h < e.length; h++)if (k = e[h], l = a[k][0], m = b.indexOf(l), 0 <= m) {
                    for (p =
                        n = 0; p < a[l].length; p++)q = b.indexOf(a[l][p]), 0 > q || q === m || (r = q > m ? q - m : m - q, n += q < m !== r > g - r ? 1 : -1); b.splice(0 > n ? m : m + 1, 0, k); e.splice(h, 1); h--
                } else f = !1; if (f) break; else b.push(e[0]), e.splice(0, 1)
            } for (a = 0; a < b.length; a++)d.add(c.O(b[a])); return d; default: v("Invalid sorting type.")
        }return a
    };
    na.Object.defineProperties(dr.prototype, {
        radius: { configurable: !0, get: function () { return this.Yo }, set: function (a) { this.Yo !== a && (z(a, "number", dr, "radius"), 0 < a || isNaN(a)) && (this.Yo = a, this.C()) } }, aspectRatio: { configurable: !0, get: function () { return this.Wm }, set: function (a) { this.Wm !== a && (z(a, "number", dr, "aspectRatio"), 0 < a && (this.Wm = a, this.C())) } }, startAngle: {
            configurable: !0, get: function () { return this.Ap }, set: function (a) {
            this.Ap !== a && (z(a, "number", dr, "startAngle"),
                this.Ap = a, this.C())
            }
        }, sweepAngle: { configurable: !0, get: function () { return this.Ol }, set: function (a) { this.Ol !== a && (z(a, "number", dr, "sweepAngle"), 0 < a && 360 >= a ? this.Ol = a : this.Ol = 360, this.C()) } }, arrangement: { configurable: !0, get: function () { return this.Db }, set: function (a) { this.Db !== a && (tb(a, dr, dr, "arrangement"), a === tr || a === er || a === sr || a === rr) && (this.Db = a, this.C()) } }, direction: {
            configurable: !0, get: function () { return this.M }, set: function (a) {
            this.M !== a && (tb(a, dr, dr, "direction"),
                a === hr || a === qr || a === or || a === pr) && (this.M = a, this.C())
            }
        }, sorting: { configurable: !0, get: function () { return this.Tc }, set: function (a) { this.Tc !== a && (tb(a, dr, dr, "sorting"), a === mr || a === nr || a === kr || lr || a === ir) && (this.Tc = a, this.C()) } }, comparer: { configurable: !0, get: function () { return this.Pc }, set: function (a) { this.Pc !== a && (z(a, "function", dr, "comparer"), this.Pc = a, this.C()) } }, spacing: {
            configurable: !0, get: function () { return this.bf }, set: function (a) {
            this.bf !== a && (z(a, "number",
                dr, "spacing"), this.bf = a, this.C())
            }
        }, nodeDiameterFormula: { configurable: !0, get: function () { return this.Io }, set: function (a) { this.Io !== a && (tb(a, dr, dr, "nodeDiameterFormula"), a === jr || a === ur) && (this.Io = a, this.C()) } }, actualXRadius: { configurable: !0, get: function () { return this.Zb } }, actualYRadius: { configurable: !0, get: function () { return this.Td } }, actualSpacing: { configurable: !0, get: function () { return this.jj } }, actualCenter: { configurable: !0, get: function () { return this.mw } }
    });
    var er = new D(dr, "ConstantSpacing", 0), sr = new D(dr, "ConstantDistance", 1), rr = new D(dr, "ConstantAngle", 2), tr = new D(dr, "Packed", 3), hr = new D(dr, "Clockwise", 4), qr = new D(dr, "Counterclockwise", 5), or = new D(dr, "BidirectionalLeft", 6), pr = new D(dr, "BidirectionalRight", 7), mr = new D(dr, "Forwards", 8), nr = new D(dr, "Reverse", 9), kr = new D(dr, "Ascending", 10), lr = new D(dr, "Descending", 11), ir = new D(dr, "Optimized", 12), jr = new D(dr, "Pythagorean", 13), ur = new D(dr, "Circular", 14); dr.className = "CircularLayout"; dr.ConstantSpacing = er;
    dr.ConstantDistance = sr; dr.ConstantAngle = rr; dr.Packed = tr; dr.Clockwise = hr; dr.Counterclockwise = qr; dr.BidirectionalLeft = or; dr.BidirectionalRight = pr; dr.Forwards = mr; dr.Reverse = nr; dr.Ascending = kr; dr.Descending = lr; dr.Optimized = ir; dr.Pythagorean = jr; dr.Circular = ur; function fr() { this.em = -Infinity; this.Em = this.yk = null }
    fr.prototype.compare = function (a, b) { if (0 < a && 0 > this.em || Math.abs(a) < Math.abs(this.em) && !(0 > a && 0 < this.em)) for (this.em = a, this.yk = [], this.Em = [], a = 0; a < b.length; a++)this.yk[a] = b[a].bounds.x, this.Em[a] = b[a].bounds.y }; fr.prototype.commit = function (a) { if (null !== this.yk && null !== this.Em) for (var b = 0; b < this.yk.length; b++) { var c = a.O(b); c.x = this.yk[b]; c.y = this.Em[b] } }; fr.className = "VertexArrangement"; function vr(a) { Sp.call(this, a) } ma(vr, Sp); vr.prototype.createVertex = function () { return new Ir(this) };
    vr.prototype.createEdge = function () { return new Jr(this) }; vr.className = "CircularNetwork"; function Ir(a) { Vp.call(this, a); this.L = this.ij = NaN } ma(Ir, Vp);
    function wr(a, b) { var c = a.network; if (null === c) return NaN; c = c.layout; if (null === c) return NaN; if (c.arrangement === tr) if (c.nodeDiameterFormula === ur) a.ij = Math.max(a.width, a.height); else { c = Math.abs(Math.sin(b)); b = Math.abs(Math.cos(b)); if (0 === c) return a.width; if (0 === b) return a.height; a.ij = Math.min(a.height / c, a.width / b) } else a.ij = c.nodeDiameterFormula === ur ? Math.max(a.width, a.height) : Math.sqrt(a.width * a.width + a.height * a.height); return a.ij }
    na.Object.defineProperties(Ir.prototype, { diameter: { configurable: !0, get: function () { return this.ij }, set: function (a) { this.ij !== a && (z(a, "number", Ir, "diameter"), this.ij = a) } }, actualAngle: { configurable: !0, get: function () { return this.L }, set: function (a) { this.L !== a && (z(a, "number", Ir, "actualAngle"), this.L = a) } } }); Ir.className = "CircularVertex"; function Jr(a) { Wp.call(this, a) } ma(Jr, Wp); Jr.className = "CircularEdge";
    function Kr() { 0 < arguments.length && Da(Kr); Ni.call(this); this.ph = null; this.eo = 0; this.yd = (new Zb(100, 100)).freeze(); this.Vm = !1; this.af = !0; this.Zc = !1; this.ul = 100; this.Gn = 1; this.Mf = 1E3; this.zo = 10; this.Zo = Math; this.Tk = .05; this.Sk = 50; this.Qk = 150; this.Rk = 0; this.tn = 10; this.sn = 5 } ma(Kr, Ni);
    Kr.prototype.cloneProtected = function (a) { Ni.prototype.cloneProtected.call(this, a); a.yd.assign(this.yd); a.Vm = this.Vm; a.af = this.af; a.Zc = this.Zc; a.ul = this.ul; a.Gn = this.Gn; a.Mf = this.Mf; a.zo = this.zo; a.Zo = this.Zo; a.Tk = this.Tk; a.Sk = this.Sk; a.Qk = this.Qk; a.Rk = this.Rk; a.tn = this.tn; a.sn = this.sn }; Kr.prototype.createNetwork = function () { return new Lr(this) };
    Kr.prototype.doLayout = function (a) {
    E && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"); null === this.network && (this.network = this.makeNetwork(a)); a = this.maxIterations; if (0 < this.network.vertexes.count) {
        this.network.Xp(); for (var b = this.network.vertexes.iterator; b.next();) { var c = b.value; c.charge = this.electricalCharge(c); c.mass = this.gravitationalMass(c) } for (b = this.network.edges.iterator; b.next();)c = b.value, c.stiffness = this.springStiffness(c),
            c.length = this.springLength(c); this.Nu(); this.eo = 0; if (this.needsClusterLayout()) {
                b = this.network; for (c = b.Rx().iterator; c.next();) { this.network = c.value; for (var d = this.network.vertexes.iterator; d.next();) { var e = d.value; e.vd = e.vertexes.count; e.Bh = 1; e.Yj = null; e.Je = null } Mr(this, 0, a) } this.network = b; c.reset(); E && w(b, Lr, Kr, "arrangeConnectedGraphs:singletons"); d = this.arrangementSpacing; for (var f = c.count, g = !0, h = e = 0, k = Qa(), l = 0; l < f + b.vertexes.count + 2; l++)k[l] = null; f = 0; c.reset(); for (var m = L.alloc(); c.next();)if (l =
                    c.value, this.computeBounds(l, m), g) g = !1, e = m.x + m.width / 2, h = m.y + m.height / 2, k[0] = new J(m.x + m.width + d.width, m.y), k[1] = new J(m.x, m.y + m.height + d.height), f = 2; else { var n = Nr(k, f, e, h, m.width, m.height, d), p = k[n], q = new J(p.x + m.width + d.width, p.y), r = new J(p.x, p.y + m.height + d.height); n + 1 < f && k.splice(n + 1, 0, null); k[n] = q; k[n + 1] = r; f++; n = p.x - m.x; p = p.y - m.y; for (l = l.vertexes.iterator; l.next();)q = l.value, q.centerX += n, q.centerY += p } L.free(m); for (l = b.vertexes.iterator; l.next();)g = l.value, q = g.bounds, 2 > f ? (e = q.x + q.width / 2, h = q.y +
                        q.height / 2, k[0] = new J(q.x + q.width + d.width, q.y), k[1] = new J(q.x, q.y + q.height + d.height), f = 2) : (m = Nr(k, f, e, h, q.width, q.height, d), p = k[m], n = new J(p.x + q.width + d.width, p.y), q = new J(p.x, p.y + q.height + d.height), m + 1 < f && k.splice(m + 1, 0, null), k[m] = n, k[m + 1] = q, f++ , g.centerX = p.x + g.width / 2, g.centerY = p.y + g.height / 2); Ta(k); for (c.reset(); c.next();) { d = c.value; for (e = d.vertexes.iterator; e.next();)b.th(e.value); for (d = d.edges.iterator; d.next();)b.Sj(d.value) }
            } Or(this, a); this.updateParts()
    } this.ul = a; this.network = null; this.isValidLayout =
        !0
    }; Kr.prototype.needsClusterLayout = function () { if (3 > this.network.vertexes.count) return !1; for (var a = 0, b = 0, c = this.network.vertexes.first().bounds, d = this.network.vertexes.iterator; d.next();) { if (d.value.bounds.Kc(c) && (a++ , 2 < a)) return !0; if (10 < b) break; b++ } return !1 }; Kr.prototype.computeBounds = function (a, b) { var c = !0; for (a = a.vertexes.iterator; a.next();) { var d = a.value; c ? (c = !1, b.set(d.bounds)) : b.Lc(d.bounds) } return b };
    function Pr(a, b, c) { E && (B(b, Kr, "computeClusterLayoutIterations:level"), B(c, Kr, "computeClusterLayoutIterations:maxiter")); return Math.max(Math.min(a.network.vertexes.count, c * (b + 1) / 11), 10) }
    function Mr(a, b, c) { E && (B(b, Kr, "layoutClusters:level"), B(c, Kr, "layoutClusters:maxiter")); if (Qr(a, b)) { var d = a.Mf; a.Mf *= 1 + 1 / (b + 1); var e = Rr(a, b), f = Math.max(0, Pr(a, b, c)); a.maxIterations += f; Mr(a, b + 1, c); Or(a, f); Sr(a, e, b); c = e.vertexes.Oa(); c.sort(function (a, b) { return null === a || null === b || a === b ? 0 : b.vd - a.vd }); for (e = 0; e < c.length; e++)Tr(a, c[e], b); a.Mf = d } }
    function Qr(a, b) { E && B(b, Kr, "hasClusters:level"); if (10 < b || 3 > a.network.vertexes.count) return !1; a.ph = a.network.vertexes.Oa(); a = a.ph; a.sort(function (a, b) { return null === a || null === b || a === b ? 0 : b.vd - a.vd }); for (b = a.length - 1; 0 <= b && 1 >= a[b].vd;)b--; return 1 < a.length - b }
    function Rr(a, b) {
        E && B(b, Kr, "pushSubNetwork:level"); for (var c = a.network, d = new Lr(a), e = 0; e < a.ph.length; e++) { var f = a.ph[e]; if (1 < f.vd) { d.th(f); var g = new Ur; g.Gt = f.vd; g.Ht = f.width; g.Ft = f.height; g.hw = f.focus.x; g.iw = f.focus.y; null === f.Je && (f.Je = new F); f.Je.add(g); f.Lv = f.Je.count - 1 } else break } for (f = c.edges.iterator; f.next();) {
            var h = f.value; e = h.fromVertex; g = h.toVertex; e.network === d && g.network === d ? d.Sj(h) : e.network === d ? (h = e.Yj, null === h && (h = new F, e.Yj = h), h.add(g), e.vd-- , e.Bh += g.Bh) : g.network === d && (h = g.Yj, null ===
                h && (h = new F, g.Yj = h), h.add(e), g.vd-- , g.Bh += e.Bh)
        } for (e = d.edges.iterator; e.next();)f = e.value, f.length *= Math.max(1, K.sqrt((f.fromVertex.Bh + f.toVertex.Bh) / (4 * b + 1))); for (b = d.vertexes.iterator; b.next();) {
            e = b.value; var k = e.Yj; if (null !== k && 0 < k.count && (g = e.Je.O(e.Je.count - 1).Gt - e.vd, !(0 >= g))) {
                for (var l = h = 0, m = k.count - g; m < k.count; m++) { var n = k.O(m), p = null; for (f = n.edges.iterator; f.next();) { var q = f.value; if (q.sx(n) === e) { p = q; break } } null !== p && (l += p.length, h += n.width * n.height) } f = e.centerX; k = e.centerY; m = e.width; n =
                    e.height; p = e.focus; q = m * n; 1 > q && (q = 1); h = K.sqrt((h + q + l * l * 4 / (g * g)) / q); g = (h - 1) * m / 2; h = (h - 1) * n / 2; e.bounds = new L(f - p.x - g, k - p.y - h, m + 2 * g, n + 2 * h); e.focus = new J(p.x + g, p.y + h)
            }
        } a.network = d; return c
    }
    function Sr(a, b, c) { E && (w(b, Lr, Kr, "popNetwork:oldnet"), B(c, Kr, "popNetwork:level")); for (c = a.network.vertexes.iterator; c.next();) { var d = c.value; d.network = b; if (null !== d.Je) { var e = d.Je.O(d.Lv); d.vd = e.Gt; var f = e.hw, g = e.iw; d.bounds = new L(d.centerX - f, d.centerY - g, e.Ht, e.Ft); d.focus = new J(f, g); d.Lv-- } } for (c = a.network.edges.iterator; c.next();)c.value.network = b; a.network = b }
    function Tr(a, b, c) {
        E && (w(b, Vr, Kr, "surroundNode:oldnet"), B(c, Kr, "surroundNode:level")); var d = b.Yj; if (null !== d && 0 !== d.count) {
            c = b.centerX; var e = b.centerY, f = b.width, g = b.height; null !== b.Je && 0 < b.Je.count && (g = b.Je.O(0), f = g.Ht, g = g.Ft); f = K.sqrt(f * f + g * g) / 2; for (var h = !1, k = g = 0, l = 0, m = b.vertexes.iterator; m.next();) { var n = m.value; 1 >= n.vd ? k++ : (h = !0, l++ , g += Math.atan2(b.centerY - n.centerY, b.centerX - n.centerX)) } if (0 !== k) for (0 < l && (g /= l), l = b = 0, b = h ? 2 * Math.PI / (k + 1) : 2 * Math.PI / k, 0 === k % 2 && (l = b / 2), 1 < d.count && d.sort(function (a,
                b) { return null === a || null === b || a === b ? 0 : b.width * b.height - a.width * a.height }), h = 0 === k % 2 ? 0 : 1, d = d.iterator; d.next();)if (k = d.value, !(1 < k.vd || a.isFixed(k))) { m = null; for (n = k.edges.iterator; n.next();) { m = n.value; break } n = k.width; var p = k.height; n = K.sqrt(n * n + p * p) / 2; m = f + m.length + n; n = g + (b * (h / 2 >> 1) + l) * (0 === h % 2 ? 1 : -1); k.centerX = c + m * Math.cos(n); k.centerY = e + m * Math.sin(n); h++ }
        }
    }
    function Nr(a, b, c, d, e, f, g) { var h = 9E19, k = -1, l = 0; a: for (; l < b; l++) { var m = a[l], n = m.x - c, p = m.y - d; n = n * n + p * p; if (n < h) { for (p = l - 1; 0 <= p; p--)if (a[p].y > m.y && a[p].x - m.x < e + g.width) continue a; for (p = l + 1; p < b; p++)if (a[p].x > m.x && a[p].y - m.y < f + g.height) continue a; k = l; h = n } } return k } Kr.prototype.Nu = function () { if (this.comments) for (var a = this.network.vertexes.iterator; a.next();)this.addComments(a.value) };
    Kr.prototype.addComments = function (a) { var b = a.node; if (null !== b) for (b = b.ev(); b.next();) { var c = b.value; if ("Comment" === c.category && c.isVisible()) { var d = this.network.Mi(c); null === d && (d = this.network.Vl(c)); d.charge = this.defaultCommentElectricalCharge; c = null; for (var e = d.destinationEdges; e.next();) { var f = e.value; if (f.toVertex === a) { c = f; break } } if (null === c) for (e = d.sourceEdges; e.next();)if (f = e.value, f.fromVertex === a) { c = f; break } null === c && (c = this.network.jk(a, d, null)); c.length = this.defaultCommentSpringLength } } };
    function Wr(a, b) { E && (w(a, Vr, Kr, "getNodeDistance:vertexA"), w(b, Vr, Kr, "getNodeDistance:vertexB")); var c = a.bounds, d = c.x; a = c.y; var e = c.width; c = c.height; var f = b.bounds, g = f.x; b = f.y; var h = f.width; f = f.height; return d + e < g ? a > b + f ? (c = d + e - g, a = a - b - f, K.sqrt(c * c + a * a)) : a + c < b ? (d = d + e - g, a = a + c - b, K.sqrt(d * d + a * a)) : g - (d + e) : d > g + h ? a > b + f ? (c = d - g - h, a = a - b - f, K.sqrt(c * c + a * a)) : a + c < b ? (d = d - g - h, a = a + c - b, K.sqrt(d * d + a * a)) : d - (g + h) : a > b + f ? a - (b + f) : a + c < b ? b - (a + c) : .1 }
    function Or(a, b) { E && B(b, Kr, "performIterations:num"); a.ph = null; for (b = a.eo + b; a.eo < b && (a.eo++ , Xr(a));); a.ph = null }
    function Xr(a) {
    null === a.ph && (a.ph = a.network.vertexes.Oa()); var b = a.ph; if (0 >= b.length) return !1; var c = b[0]; c.forceX = 0; c.forceY = 0; for (var d = c.centerX, e = d, f = c = c.centerY, g = 1; g < b.length; g++) { var h = b[g]; h.forceX = 0; h.forceY = 0; var k = h.centerX; h = h.centerY; d = Math.min(d, k); e = Math.max(e, k); c = Math.min(c, h); f = Math.max(f, h) } (e = e - d > f - c) ? b.sort(function (a, b) { return null === a || null === b || a === b ? 0 : a.centerX - b.centerX }) : b.sort(function (a, b) { return null === a || null === b || a === b ? 0 : a.centerY - b.centerY }); c = a.Mf; var l = d = h = 0; for (f =
        0; f < b.length; f++) {
            g = b[f]; d = g.bounds; h = g.focus; k = d.x + h.x; var m = d.y + h.y; d = g.charge * a.electricalFieldX(k, m); l = g.charge * a.electricalFieldY(k, m); d += g.mass * a.gravitationalFieldX(k, m); l += g.mass * a.gravitationalFieldY(k, m); g.forceX += d; g.forceY += l; for (var n = f + 1; n < b.length; n++) {
                var p = b[n]; if (p !== g) {
                    d = p.bounds; h = p.focus; l = d.x + h.x; var q = d.y + h.y; if (k - l > c || l - k > c) { if (e) break } else if (m - q > c || q - m > c) { if (!e) break } else {
                        var r = Wr(g, p); 1 > r ? (d = a.randomNumberGenerator, null === d && (a.randomNumberGenerator = d = new Yr), r = d.random(),
                            h = d.random(), k > l ? (d = Math.abs(p.bounds.right - g.bounds.x), d = (1 + d) * r) : k < l ? (d = Math.abs(p.bounds.x - g.bounds.right), d = -(1 + d) * r) : (d = Math.max(p.width, g.width), d = (1 + d) * r - d / 2), m > q ? (l = Math.abs(p.bounds.bottom - g.bounds.y), l = (1 + l) * h) : k < l ? (l = Math.abs(p.bounds.y - g.bounds.bottom), l = -(1 + l) * h) : (l = Math.max(p.height, g.height), l = (1 + l) * h - l / 2)) : (h = -(g.charge * p.charge) / (r * r), d = (l - k) / r * h, l = (q - m) / r * h); g.forceX += d; g.forceY += l; p.forceX -= d; p.forceY -= l
                    }
                }
            }
    } for (e = a.network.edges.iterator; e.next();)h = e.value, c = h.fromVertex, f = h.toVertex,
        g = c.bounds, k = c.focus, d = g.x + k.x, g = g.y + k.y, m = f.bounds, n = f.focus, k = m.x + n.x, m = m.y + n.y, n = Wr(c, f), 1 > n ? (n = a.randomNumberGenerator, null === n && (a.randomNumberGenerator = n = new Yr), h = n.random(), n = n.random(), d = (d > k ? 1 : -1) * (1 + (f.width > c.width ? f.width : c.width)) * h, l = (g > m ? 1 : -1) * (1 + (f.height > c.height ? f.height : c.height)) * n) : (h = h.stiffness * (n - h.length), d = (k - d) / n * h, l = (m - g) / n * h), c.forceX += d, c.forceY += l, f.forceX -= d, f.forceY -= l; d = 0; e = a.moveLimit; for (c = 0; c < b.length; c++)f = b[c], a.isFixed(f) ? a.moveFixedVertex(f) : (g = f.forceX, k =
            f.forceY, g < -e ? g = -e : g > e && (g = e), k < -e ? k = -e : k > e && (k = e), f.centerX += g, f.centerY += k, d = Math.max(d, g * g + k * k)); return d > a.epsilonDistance * a.epsilonDistance
    } Kr.prototype.moveFixedVertex = function () { }; Kr.prototype.commitLayout = function () { this.Qv(); this.commitNodes(); this.isRouting && this.commitLinks() }; Kr.prototype.Qv = function () { if (this.setsPortSpots) for (var a = this.network.edges.iterator; a.next();) { var b = a.value.link; null !== b && (b.fromSpot = Qd, b.toSpot = Qd) } };
    Kr.prototype.commitNodes = function () { var a = 0, b = 0; if (this.arrangesToOrigin) { var c = L.alloc(); this.computeBounds(this.network, c); b = this.arrangementOrigin; a = b.x - c.x; b = b.y - c.y; L.free(c) } c = L.alloc(); for (var d = this.network.vertexes.iterator; d.next();) { var e = d.value; if (0 !== a || 0 !== b) c.assign(e.bounds), c.x += a, c.y += b, e.bounds = c; e.commit() } L.free(c) }; Kr.prototype.commitLinks = function () { for (var a = this.network.edges.iterator; a.next();)a.value.commit() };
    Kr.prototype.springStiffness = function (a) { a = a.stiffness; return isNaN(a) ? this.Tk : a }; Kr.prototype.springLength = function (a) { a = a.length; return isNaN(a) ? this.Sk : a }; Kr.prototype.electricalCharge = function (a) { a = a.charge; return isNaN(a) ? this.Qk : a }; Kr.prototype.electricalFieldX = function () { return 0 }; Kr.prototype.electricalFieldY = function () { return 0 }; Kr.prototype.gravitationalMass = function (a) { a = a.mass; return isNaN(a) ? this.Rk : a }; Kr.prototype.gravitationalFieldX = function () { return 0 };
    Kr.prototype.gravitationalFieldY = function () { return 0 }; Kr.prototype.isFixed = function (a) { return a.isFixed };
    na.Object.defineProperties(Kr.prototype, {
        currentIteration: { configurable: !0, get: function () { return this.eo } }, arrangementSpacing: { configurable: !0, get: function () { return this.yd }, set: function (a) { w(a, Zb, Kr, "arrangementSpacing"); this.yd.A(a) || (this.yd.assign(a), this.C()) } }, arrangesToOrigin: { configurable: !0, get: function () { return this.Vm }, set: function (a) { this.Vm !== a && (z(a, "boolean", Kr, "arrangesToOrigin"), this.Vm = a, this.C()) } }, setsPortSpots: {
            configurable: !0,
            get: function () { return this.af }, set: function (a) { this.af !== a && (z(a, "boolean", Kr, "setsPortSpots"), this.af = a, this.C()) }
        }, comments: { configurable: !0, get: function () { return this.Zc }, set: function (a) { this.Zc !== a && (z(a, "boolean", Kr, "comments"), this.Zc = a, this.C()) } }, maxIterations: { configurable: !0, get: function () { return this.ul }, set: function (a) { this.ul !== a && (z(a, "number", Kr, "maxIterations"), 0 <= a && (this.ul = a, this.C())) } }, epsilonDistance: {
            configurable: !0, get: function () { return this.Gn },
            set: function (a) { this.Gn !== a && (z(a, "number", Kr, "epsilonDistance"), 0 < a && (this.Gn = a, this.C())) }
        }, infinityDistance: { configurable: !0, get: function () { return this.Mf }, set: function (a) { this.Mf !== a && (z(a, "number", Kr, "infinityDistance"), 1 < a && (this.Mf = a, this.C())) } }, moveLimit: { configurable: !0, get: function () { return this.zo }, set: function (a) { this.zo !== a && (z(a, "number", Kr, "moveLimit"), 1 < a && (this.zo = a, this.C())) } }, randomNumberGenerator: {
            configurable: !0, get: function () { return this.Zo },
            set: function (a) { this.Zo !== a && (null !== a && "function" !== typeof a.random && v('ForceDirectedLayout.randomNumberGenerator must have a "random()" function on it: ' + a), this.Zo = a) }
        }, defaultSpringStiffness: { configurable: !0, get: function () { return this.Tk }, set: function (a) { this.Tk !== a && (z(a, "number", Kr, "defaultSpringStiffness"), this.Tk = a, this.C()) } }, defaultSpringLength: {
            configurable: !0, get: function () { return this.Sk }, set: function (a) {
            this.Sk !== a && (z(a, "number", Kr, "defaultSpringLength"),
                this.Sk = a, this.C())
            }
        }, defaultElectricalCharge: { configurable: !0, get: function () { return this.Qk }, set: function (a) { this.Qk !== a && (z(a, "number", Kr, "defaultElectricalCharge"), this.Qk = a, this.C()) } }, defaultGravitationalMass: { configurable: !0, get: function () { return this.Rk }, set: function (a) { this.Rk !== a && (z(a, "number", Kr, "defaultGravitationalMass"), this.Rk = a, this.C()) } }, defaultCommentSpringLength: {
            configurable: !0, get: function () { return this.tn }, set: function (a) {
            this.tn !==
                a && (z(a, "number", Kr, "defaultCommentSpringLength"), this.tn = a, this.C())
            }
        }, defaultCommentElectricalCharge: { configurable: !0, get: function () { return this.sn }, set: function (a) { this.sn !== a && (z(a, "number", Kr, "defaultCommentElectricalCharge"), this.sn = a, this.C()) } }
    }); Kr.className = "ForceDirectedLayout"; function Ur() { this.iw = this.hw = this.Ft = this.Ht = this.Gt = 0 } Ur.className = "ForceDirectedSubnet"; function Lr(a) { Sp.call(this, a) } ma(Lr, Sp); Lr.prototype.createVertex = function () { return new Vr(this) };
    Lr.prototype.createEdge = function () { return new Zr(this) }; Lr.className = "ForceDirectedNetwork"; function Vr(a) { Vp.call(this, a); this.Na = !1; this.Wb = this.L = NaN; this.Bh = this.vd = this.Ma = this.ca = 0; this.Je = this.Yj = null; this.Lv = 0 } ma(Vr, Vp);
    na.Object.defineProperties(Vr.prototype, {
        isFixed: { configurable: !0, get: function () { return this.Na }, set: function (a) { this.Na !== a && (z(a, "boolean", Vr, "isFixed"), this.Na = a) } }, charge: { configurable: !0, get: function () { return this.L }, set: function (a) { this.L !== a && (z(a, "number", Vr, "charge"), this.L = a) } }, mass: { configurable: !0, get: function () { return this.Wb }, set: function (a) { this.Wb !== a && (z(a, "number", Vr, "mass"), this.Wb = a) } }, forceX: {
            configurable: !0, get: function () { return this.ca },
            set: function (a) { this.ca !== a && (z(a, "number", Vr, "forceX"), this.ca = a) }
        }, forceY: { configurable: !0, get: function () { return this.Ma }, set: function (a) { this.Ma !== a && (z(a, "number", Vr, "forceY"), this.Ma = a) } }
    }); Vr.className = "ForceDirectedVertex"; function Zr(a) { Wp.call(this, a); this.l = this.w = NaN } ma(Zr, Wp);
    na.Object.defineProperties(Zr.prototype, { stiffness: { configurable: !0, get: function () { return this.w }, set: function (a) { this.w !== a && (z(a, "number", Zr, "stiffness"), this.w = a) } }, length: { configurable: !0, get: function () { return this.l }, set: function (a) { this.l !== a && (z(a, "number", Zr, "length"), this.l = a) } } }); Zr.className = "ForceDirectedEdge";
    function Yr() { var a = 0; void 0 === a && (a = 42); this.seed = a; this.Tx = 48271; this.Vx = 2147483647; this.Q = 44488.07041494893; this.Xx = 3399; this.Ux = 1 / 2147483647; this.random() } Yr.prototype.random = function () { var a = this.seed % this.Q * this.Tx - this.seed / this.Q * this.Xx; 0 < a ? this.seed = a : this.seed = a + this.Vx; return this.seed * this.Ux }; Yr.className = "RandomNumberGenerator";
    function $r() { 0 < arguments.length && Da($r); Ni.call(this); this.Yb = this.me = 25; this.M = 0; this.Ok = as; this.pl = bs; this.fl = cs; this.tj = 4; this.Ak = ds; this.bg = 7; this.af = !0; this.ko = 4; this.Ia = this.Vr = this.Ba = -1; this.qd = this.uo = 0; this.La = this.nd = this.od = this.Jd = this.hc = null; this.Eo = 0; this.Do = this.yj = null; this.Nd = 0; this.Fo = null; this.ow = new J; this.se = []; this.se.length = 100 } ma($r, Ni);
    $r.prototype.cloneProtected = function (a) { Ni.prototype.cloneProtected.call(this, a); a.me = this.me; a.Yb = this.Yb; a.M = this.M; a.Ok = this.Ok; a.pl = this.pl; a.fl = this.fl; a.tj = this.tj; a.Ak = this.Ak; a.bg = this.bg; a.af = this.af; a.ko = this.ko };
    $r.prototype.hb = function (a) { a.classType === $r ? 0 === a.name.indexOf("Aggressive") ? this.aggressiveOption = a : 0 === a.name.indexOf("Cycle") ? this.cycleRemoveOption = a : 0 === a.name.indexOf("Init") ? this.initializeOption = a : 0 === a.name.indexOf("Layer") ? this.layeringOption = a : v("Unknown enum value: " + a) : Ni.prototype.hb.call(this, a) }; $r.prototype.createNetwork = function () { return new es(this) };
    $r.prototype.doLayout = function (a) {
    E && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"); null === this.network && (this.network = this.makeNetwork(a)); this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin); this.Vr = -1; this.qd = this.uo = 0; this.Fo = this.Do = this.yj = null; for (a = 0; a < this.se.length; a++)this.se[a] = null; if (0 < this.network.vertexes.count) {
        this.network.Xp(); this.cycleRemoveOption !== fs && this.removeCycles(); for (a = this.network.vertexes.iterator; a.next();)a.value.layer =
            -1; this.Ba = -1; this.assignLayers(); for (a.reset(); a.next();)this.Ba = Math.max(this.Ba, a.value.layer); this.cycleRemoveOption === fs && this.removeCycles(); a = this.network; for (var b = [], c = a.edges.iterator; c.next();) { var d = c.value; d.valid = !1; b.push(d) } for (c = 0; c < b.length; c++) {
                d = b[c]; var e = d.fromVertex, f = d.toVertex; if (!d.valid && (null !== e.node && null !== f.node || e.layer !== f.layer)) {
                    var g = 0, h = 0, k = 0, l = 0; if (null !== d.link) {
                        h = d.link; if (null === h) continue; var m = e.node; g = f.node; if (null === m || null === g) continue; var n = h.fromNode;
                        k = h.toNode; var p = h.fromPort; h = h.toPort; if (d.rev) { l = n; var q = p; n = k; p = h; k = l; h = q } var r = e.focus; l = f.focus; var u = d.rev ? f.bounds : e.bounds; q = J.alloc(); m !== n ? u.o() && n.isVisible() ? n.actualBounds.o() ? (n.rf(p, qd, q), q.x += n.actualBounds.x - u.x, q.y += n.actualBounds.y - u.y) : (n.rf(p, qd, q), q.o() || q.assign(r)) : q.assign(r) : u.o() ? (n.rf(p, qd, q), q.o() || q.assign(r)) : q.assign(r); n = d.rev ? e.bounds : f.bounds; m = J.alloc(); g !== k ? n.o() && k.isVisible() ? k.actualBounds.o() ? (k.rf(h, qd, m), m.x += k.actualBounds.x - n.x, m.y += k.actualBounds.y - n.y) :
                            (k.rf(h, qd, m), m.o() || m.assign(l)) : m.assign(l) : n.o() ? (k.rf(h, qd, m), m.o() || m.assign(l)) : m.assign(l); 90 === this.M || 270 === this.M ? (g = Math.round((q.x - r.x) / this.Yb), k = q.x, h = Math.round((m.x - l.x) / this.Yb), l = m.x) : (g = Math.round((q.y - r.y) / this.Yb), k = q.y, h = Math.round((m.y - l.y) / this.Yb), l = m.y); J.free(q); J.free(m); d.portFromColOffset = g; d.portFromPos = k; d.portToColOffset = h; d.portToPos = l
                    } else d.portFromColOffset = 0, d.portFromPos = 0, d.portToColOffset = 0, d.portToPos = 0; q = e.layer; m = f.layer; n = 0; u = d.link; if (null !== u) {
                        var x =
                            u.fromPort, y = u.toPort; if (null !== x && null !== y) {
                                var A = u.fromNode; p = u.toNode; if (null !== A && null !== p) {
                                    var C = gs(this, !0), G = gs(this, !1), H = this.setsPortSpots ? C : u.computeSpot(!0, x); r = this.setsPortSpots ? G : u.computeSpot(!1, y); var O = u.isOrthogonal; H.tf() && H.sf(G) && r.tf() && r.sf(C) ? n = 0 : (C = u.getLinkPoint(A, x, H, !0, O, p, y, J.alloc()), G = u.getLinkDirection(A, x, C, H, !0, O, p, y), J.free(C), H.kq() || G !== hs(this, d, !0) ? this.setsPortSpots && null !== A && 1 === A.ports.count && d.rev && (n += 1) : n += 1, H = u.getLinkPoint(p, y, r, !1, O, A, x, J.alloc()),
                                        u = u.getLinkDirection(p, y, H, r, !1, O, A, x), J.free(H), r.kq() || u !== hs(this, d, !1) ? this.setsPortSpots && null !== p && 1 === p.ports.count && d.rev && (n += 2) : n += 2)
                                }
                            }
                    } p = n; n = 1 === p || 3 === p ? !0 : !1; if (p = 2 === p || 3 === p ? !0 : !1) r = a.createVertex(), r.node = null, r.Tj = 1, r.layer = q, r.near = e, a.th(r), e = a.jk(e, r, d.link), e.valid = !1, e.rev = d.rev, e.portFromColOffset = g, e.portToColOffset = 0, e.portFromPos = k, e.portToPos = 0, e = r; u = 1; n && u--; if (q - m > u && 0 < q) {
                    d.valid = !1; r = a.createVertex(); r.node = null; r.Tj = 2; r.layer = q - 1; a.th(r); e = a.jk(e, r, d.link); e.valid = !0;
                        e.rev = d.rev; e.portFromColOffset = p ? 0 : g; e.portToColOffset = 0; e.portFromPos = p ? 0 : k; e.portToPos = 0; e = r; for (q--; q - m > u && 0 < q;)r = a.createVertex(), r.node = null, r.Tj = 3, r.layer = q - 1, a.th(r), e = a.jk(e, r, d.link), e.valid = !0, e.rev = d.rev, e.portFromColOffset = 0, e.portToColOffset = 0, e.portFromPos = 0, e.portToPos = 0, e = r, q--; e = a.jk(r, f, d.link); e.valid = !n; n && (r.near = f); e.rev = d.rev; e.portFromColOffset = 0; e.portToColOffset = h; e.portFromPos = 0; e.portToPos = l
                    } else d.valid = !0
                }
            } a = this.hc = []; for (b = 0; b <= this.Ba; b++)a[b] = 0; for (b = this.network.vertexes.iterator; b.next();)b.value.index =
                -1; this.initializeIndices(); this.Vr = -1; for (c = this.qd = this.uo = 0; c <= this.Ba; c++)a[c] > a[this.qd] && (this.Vr = a[c] - 1, this.qd = c), a[c] < a[this.uo] && (this.uo = c); this.Fo = []; for (c = 0; c < a.length; c++)this.Fo[c] = []; for (b.reset(); b.next();)a = b.value, this.Fo[a.layer][a.index] = a; this.Ia = -1; for (a = 0; a <= this.Ba; a++) { b = is(this, a); c = 0; d = this.hc[a]; for (f = 0; f < d; f++)e = b[f], c += this.nodeMinColumnSpace(e, !0), e.column = c, c += 1, c += this.nodeMinColumnSpace(e, !1); this.Ia = Math.max(this.Ia, c - 1); js(this, a, b) } this.reduceCrossings(); this.straightenAndPack();
        this.updateParts()
    } this.network = null; this.isValidLayout = !0
    }; $r.prototype.linkMinLength = function () { return 1 }; function ks(a) { var b = a.fromVertex.node; a = a.toVertex.node; return null === b && null === a ? 8 : null === b || null === a ? 4 : 1 } $r.prototype.nodeMinLayerSpace = function (a, b) { return null === a.node ? 0 : 90 === this.M || 270 === this.M ? b ? a.focus.y + 10 : a.bounds.height - a.focus.y + 10 : b ? a.focus.x + 10 : a.bounds.width - a.focus.x + 10 };
    $r.prototype.nodeMinColumnSpace = function (a, b) { if (null === a.node) return 0; var c = b ? a.xv : a.wv; if (null !== c) return c; c = this.M; return 90 === c || 270 === c ? b ? a.xv = a.focus.x / this.Yb + 1 | 0 : a.wv = (a.bounds.width - a.focus.x) / this.Yb + 1 | 0 : b ? a.xv = a.focus.y / this.Yb + 1 | 0 : a.wv = (a.bounds.height - a.focus.y) / this.Yb + 1 | 0 }; function ls(a) { null === a.yj && (a.yj = []); for (var b = 0, c = a.network.vertexes.iterator; c.next();) { var d = c.value; a.yj[b] = d.layer; b++; a.yj[b] = d.column; b++; a.yj[b] = d.index; b++ } return a.yj }
    function ms(a, b) { var c = 0; for (a = a.network.vertexes.iterator; a.next();) { var d = a.value; d.layer = b[c]; c++; d.column = b[c]; c++; d.index = b[c]; c++ } }
    function ns(a, b, c) {
        E && (B(b, $r, "crossingMatrix:unfixedLayer"), B(c, $r, "crossingMatrix:direction")); var d = is(a, b), e = a.hc[b]; if (null === a.Do || a.Do.length < e * e) a.Do = []; for (var f = a.Do, g = 0; g < e; g++) {
            var h = 0, k = d[g], l = k.near; if (null !== l && l.layer === k.layer) if (k = l.index, k > g) for (var m = g + 1; m < k; m++) { var n = d[m]; n.near === l && n.Tj === l.Tj || h++ } else for (m = g - 1; m > k; m--)n = d[m], n.near === l && n.Tj === l.Tj || h++; var p; if (0 <= c) for (k = d[g].sourceEdgesArrayAccess, l = 0; l < k.length; l++) {
                var q = k[l]; if (q.valid && q.fromVertex.layer !== b) for (n =
                    q.fromVertex.index, m = q.portToPos, q = q.portFromPos, p = l + 1; p < k.length; p++) { var r = k[p]; if (r.valid && r.fromVertex.layer !== b) { var u = r.fromVertex.index; var x = r.portToPos; r = r.portFromPos; m < x && (n > u || n === u && q > r) && h++; x < m && (u > n || u === n && r > q) && h++ } }
            } if (0 >= c) for (k = d[g].destinationEdgesArrayAccess, l = 0; l < k.length; l++)if (q = k[l], q.valid && q.toVertex.layer !== b) for (n = q.toVertex.index, m = q.portToPos, q = q.portFromPos, p = l + 1; p < k.length; p++)r = k[p], r.valid && r.toVertex.layer !== b && (u = r.toVertex.index, x = r.portToPos, r = r.portFromPos,
                q < r && (n > u || n === u && m > x) && h++ , r < q && (u > n || u === n && x > m) && h++); f[g * e + g] = h; for (k = g + 1; k < e; k++) {
                    var y = 0, A = 0; if (0 <= c) { h = d[g].sourceEdgesArrayAccess; var C = d[k].sourceEdgesArrayAccess; for (l = 0; l < h.length; l++)if (q = h[l], q.valid && q.fromVertex.layer !== b) for (n = q.fromVertex.index, q = q.portFromPos, p = 0; p < C.length; p++)r = C[p], r.valid && r.fromVertex.layer !== b && (u = r.fromVertex.index, r = r.portFromPos, (n < u || n === u && q < r) && A++ , (u < n || u === n && r < q) && y++) } if (0 >= c) for (h = d[g].destinationEdgesArrayAccess, C = d[k].destinationEdgesArrayAccess,
                        l = 0; l < h.length; l++)if (q = h[l], q.valid && q.toVertex.layer !== b) for (n = q.toVertex.index, m = q.portToPos, p = 0; p < C.length; p++)r = C[p], r.valid && r.toVertex.layer !== b && (u = r.toVertex.index, x = r.portToPos, (n < u || n === u && m < x) && A++ , (u < n || u === n && x < m) && y++); f[g * e + k] = y; f[k * e + g] = A
                }
        } js(a, b, d); return f
    } $r.prototype.countCrossings = function () { for (var a = 0, b = 0; b <= this.Ba; b++)for (var c = ns(this, b, 1), d = this.hc[b], e = 0; e < d; e++)for (var f = e; f < d; f++)a += c[e * d + f]; return a };
    function os(a) { for (var b = 0, c = 0; c <= a.Ba; c++) { for (var d = a, e = c, f = is(d, e), g = d.hc[e], h = 0, k = 0; k < g; k++) { var l = f[k].destinationEdgesArrayAccess; if (null !== l) for (var m = 0; m < l.length; m++) { var n = l[m]; if (n.valid && n.toVertex.layer !== e) { var p = n.fromVertex.column + n.portFromColOffset; var q = n.toVertex.column + n.portToColOffset; h += (Math.abs(p - q) + 1) * ks(n) } } } js(d, e, f); b += h } return b }
    $r.prototype.normalize = function () { var a = Infinity; this.Ia = -1; for (var b = this.network.vertexes.iterator; b.next();) { var c = b.value; a = Math.min(a, c.column - this.nodeMinColumnSpace(c, !0)); this.Ia = Math.max(this.Ia, c.column + this.nodeMinColumnSpace(c, !1)) } for (b.reset(); b.next();)b.value.column -= a; this.Ia -= a };
    function ps(a, b, c) {
        E && (B(b, $r, "barycenters:unfixedLayer"), B(c, $r, "barycenters:direction")); for (var d = is(a, b), e = a.hc[b], f = [], g = 0; g < e; g++) {
            var h = d[g], k = null; 0 >= c && (k = h.sourceEdgesArrayAccess); var l = null; 0 <= c && (l = h.destinationEdgesArrayAccess); var m = 0, n = 0, p = h.near; null !== p && p.layer === h.layer && (m += p.column - 1, n++); if (null !== k) for (p = 0; p < k.length; p++) { h = k[p]; var q = h.fromVertex; h.valid && !h.rev && q.layer !== b && (m += q.column, n++) } if (null !== l) for (k = 0; k < l.length; k++)h = l[k], p = h.toVertex, h.valid && !h.rev && p.layer !==
                b && (m += p.column, n++); f[g] = 0 === n ? -1 : m / n
        } js(a, b, d); return f
    }
    function qs(a, b, c) {
        E && (B(b, $r, "medians:unfixedLayer"), B(c, $r, "medians:direction")); for (var d = is(a, b), e = a.hc[b], f = [], g = 0; g < e; g++) {
            var h = d[g], k = null; 0 >= c && (k = h.sourceEdgesArrayAccess); var l = null; 0 <= c && (l = h.destinationEdgesArrayAccess); var m = 0, n = [], p = h.near; null !== p && p.layer === h.layer && (n[m] = p.column - 1, m++); h = void 0; if (null !== k) for (p = 0; p < k.length; p++) { h = k[p]; var q = h.fromVertex; h.valid && !h.rev && q.layer !== b && (n[m] = q.column + h.portFromColOffset, m++) } if (null !== l) for (k = 0; k < l.length; k++)h = l[k], p = h.toVertex,
                h.valid && !h.rev && p.layer !== b && (n[m] = p.column + h.portToColOffset, m++); 0 === m ? f[g] = -1 : (n.sort(function (a, b) { return a - b }), l = m >> 1, f[g] = 0 !== (m & 1) ? n[l] : n[l - 1] + n[l] >> 1)
        } js(a, b, d); return f
    }
    function rs(a, b, c, d, e, f) { if (b.component === d) { b.component = c; if (e) for (var g = b.destinationEdges; g.next();) { var h = g.value; var k = h.toVertex; var l = b.layer - k.layer; h = a.linkMinLength(h); l === h && rs(a, k, c, d, e, f) } if (f) for (g = b.sourceEdges; g.next();)h = g.value, k = h.fromVertex, l = k.layer - b.layer, h = a.linkMinLength(h), l === h && rs(a, k, c, d, e, f) } }
    function ss(a, b, c, d, e, f) { if (b.component === d) { b.component = c; if (e) for (var g = b.destinationEdges; g.next();)ss(a, g.value.toVertex, c, d, e, f); if (f) for (b = b.sourceEdges; b.next();)ss(a, b.value.fromVertex, c, d, e, f) } }
    $r.prototype.removeCycles = function () {
        for (var a = this.network.edges.iterator; a.next();)a.value.rev = !1; switch (this.Ok) {
            default: case ts: a = this.network; var b = 0, c = a.vertexes.count - 1, d = []; d.length = c + 1; for (var e = a.vertexes.iterator; e.next();)e.value.valid = !0; for (; null !== us(a);) {
                for (e = vs(a); null !== e;)d[c] = e, c-- , e.valid = !1, e = vs(a); for (e = ws(a); null !== e;)d[b] = e, b++ , e.valid = !1, e = ws(a); e = null; for (var f = 0, g = this.network.vertexes.iterator; g.next();) {
                    var h = g.value; if (h.valid) {
                        for (var k = 0, l = h.destinationEdges; l.next();)l.value.toVertex.valid &&
                            k++; l = 0; for (var m = h.sourceEdges; m.next();)m.value.fromVertex.valid && l++; if (null === e || f < k - l) e = h, f = k - l
                    }
                } null !== e && (d[b] = e, b++ , e.valid = !1)
            } for (b = 0; b < a.vertexes.count; b++)d[b].index = b; for (d = a.edges.iterator; d.next();)b = d.value, b.fromVertex.index > b.toVertex.index && (a.xm(b), b.rev = !0); break; case as: for (d = this.network.vertexes.iterator; d.next();)a = d.value, a.am = -1, a.finish = -1; for (a = this.network.edges.iterator; a.next();)a.value.forest = !1; this.Eo = 0; for (d.reset(); d.next();)b = d.value, 0 === b.sourceEdges.count &&
                xs(this, b); for (d.reset(); d.next();)b = d.value, -1 === b.am && xs(this, b); for (a.reset(); a.next();)d = a.value, d.forest || (b = d.fromVertex, c = b.finish, e = d.toVertex, f = e.finish, e.am < b.am && c < f && (this.network.xm(d), d.rev = !0)); break; case fs: a = this.network; b = a.vertexes.iterator; for (d = Infinity; b.next();)d = Math.min(d, b.value.layer); if (Infinity > d) {
                    if (0 > d) for (b.reset(); b.next();)b.value.layer -= d; d = []; for (b.reset(); b.next();)c = b.value, e = d[c.layer], void 0 === e ? d[c.layer] = [c] : e.push(c); for (c = b = 0; c < d.length; c++)if (e = d[c], !e ||
                        0 === e.length) b++; else if (0 < c) for (f = 0; f < e.length; f++)e[f].layer -= b; for (d = a.edges.iterator; d.next();)b = d.value, b.fromVertex.layer < b.toVertex.layer && (a.xm(b), b.rev = !0)
                }
        }
    }; function us(a) { for (a = a.vertexes.iterator; a.next();) { var b = a.value; if (b.valid) return b } return null } function vs(a) { for (a = a.vertexes.iterator; a.next();) { var b = a.value; if (b.valid) { for (var c = !0, d = b.destinationEdges; d.next();)if (d.value.toVertex.valid) { c = !1; break } if (c) return b } } return null }
    function ws(a) { for (a = a.vertexes.iterator; a.next();) { var b = a.value; if (b.valid) { for (var c = !0, d = b.sourceEdges; d.next();)if (d.value.fromVertex.valid) { c = !1; break } if (c) return b } } return null } function xs(a, b) { b.am = a.Eo; a.Eo++; for (var c = b.destinationEdges; c.next();) { var d = c.value, e = d.toVertex; -1 === e.am && (d.forest = !0, xs(a, e)) } b.finish = a.Eo; a.Eo++ }
    $r.prototype.assignLayers = function () {
        switch (this.pl) {
            case ys: zs(this); break; case As: for (var a, b = this.network.vertexes.iterator; b.next();)a = Bs(this, b.value), this.Ba = Math.max(a, this.Ba); for (b.reset(); b.next();)a = b.value, a.layer = this.Ba - a.layer; break; default: case bs: zs(this); for (b = this.network.vertexes.iterator; b.next();)b.value.valid = !1; for (b.reset(); b.next();)a = b.value, 0 === a.sourceEdges.count && Cs(this, a); a = Infinity; for (b.reset(); b.next();)a = Math.min(a, b.value.layer); this.Ba = -1; for (b.reset(); b.next();) {
                var c =
                    b.value; c.layer -= a; this.Ba = Math.max(this.Ba, c.layer)
            }
        }
    }; function zs(a) { for (var b = a.network.vertexes.iterator; b.next();) { var c = Ds(a, b.value); a.Ba = Math.max(c, a.Ba) } } function Ds(a, b) { var c = 0; if (-1 === b.layer) { for (var d = b.destinationEdges; d.next();) { var e = d.value, f = e.toVertex; e = a.linkMinLength(e); c = Math.max(c, Ds(a, f) + e) } b.layer = c } else c = b.layer; return c }
    function Bs(a, b) { var c = 0; if (-1 === b.layer) { for (var d = b.sourceEdges; d.next();) { var e = d.value, f = e.fromVertex; e = a.linkMinLength(e); c = Math.max(c, Bs(a, f) + e) } b.layer = c } else c = b.layer; return c }
    function Cs(a, b) {
        if (!b.valid) {
        b.valid = !0; for (var c = b.destinationEdges; c.next();)Cs(a, c.value.toVertex); for (c = a.network.vertexes.iterator; c.next();)c.value.component = -1; for (var d = b.sourceEdgesArrayAccess, e = d.length, f = 0; f < e; f++) { var g = d[f], h = g.fromVertex, k = g.toVertex; g = a.linkMinLength(g); h.layer - k.layer > g && rs(a, h, 0, -1, !0, !1) } for (rs(a, b, 1, -1, !0, !0); 0 !== b.component;) {
            f = 0; d = Infinity; h = 0; k = null; for (g = a.network.vertexes.iterator; g.next();) {
                var l = g.value; if (1 === l.component) {
                    var m = 0, n = !1, p = l.sourceEdgesArrayAccess;
                    e = p.length; for (var q = 0; q < e; q++) { var r = p[q], u = r.fromVertex; m += 1; 1 !== u.component && (f += 1, u = u.layer - l.layer, r = a.linkMinLength(r), d = Math.min(d, u - r)) } p = l.destinationEdgesArrayAccess; e = p.length; for (q = 0; q < e; q++)r = p[q].toVertex, --m, 1 !== r.component ? --f : n = !0; (null === k || m < h) && !n && (k = l, h = m)
                }
            } if (0 < f) { for (c.reset(); c.next();)e = c.value, 1 === e.component && (e.layer += d); b.component = 0 } else k.component = 0
        } for (c = a.network.vertexes.iterator; c.next();)c.value.component = -1; for (rs(a, b, 1, -1, !0, !1); 0 !== b.component;) {
            d = 0; e = Infinity;
            f = 0; h = null; for (k = a.network.vertexes.iterator; k.next();)if (g = k.value, 1 === g.component) { l = 0; m = !1; p = g.sourceEdgesArrayAccess; n = p.length; for (q = 0; q < n; q++)r = p[q].fromVertex, l += 1, 1 !== r.component ? d += 1 : m = !0; p = g.destinationEdgesArrayAccess; n = p.length; for (q = 0; q < n; q++)r = p[q], u = r.toVertex, --l, 1 !== u.component && (--d, u = g.layer - u.layer, r = a.linkMinLength(r), e = Math.min(e, u - r)); (null === h || l > f) && !m && (h = g, f = l) } if (0 > d) { for (c.reset(); c.next();)d = c.value, 1 === d.component && (d.layer -= e); b.component = 0 } else h.component = 0
        }
        }
    }
    function hs(a, b, c) { return 90 === a.M ? c && !b.rev || !c && b.rev ? 270 : 90 : 180 === a.M ? c && !b.rev || !c && b.rev ? 0 : 180 : 270 === a.M ? c && !b.rev || !c && b.rev ? 90 : 270 : c && !b.rev || !c && b.rev ? 180 : 0 }
    $r.prototype.initializeIndices = function () { switch (this.fl) { default: case Es: for (var a = this.network.vertexes.iterator; a.next();) { var b = a.value, c = b.layer; b.index = this.hc[c]; this.hc[c]++ } break; case cs: a = this.network.vertexes.iterator; for (b = this.Ba; 0 <= b; b--)for (a.reset(); a.next();)c = a.value, c.layer === b && -1 === c.index && Fs(this, c); break; case Gs: for (a = this.network.vertexes.iterator, b = 0; b <= this.Ba; b++)for (a.reset(); a.next();)c = a.value, c.layer === b && -1 === c.index && Hs(this, c) } };
    function Fs(a, b) { var c = b.layer; b.index = a.hc[c]; a.hc[c]++; b = b.destinationEdgesArrayAccess; for (c = !0; c;) { c = !1; for (var d = 0; d < b.length - 1; d++) { var e = b[d], f = b[d + 1]; e.portFromColOffset > f.portFromColOffset && (c = !0, b[d] = f, b[d + 1] = e) } } for (c = 0; c < b.length; c++)d = b[c], d.valid && (d = d.toVertex, -1 === d.index && Fs(a, d)) }
    function Hs(a, b) { var c = b.layer; b.index = a.hc[c]; a.hc[c]++; b = b.sourceEdgesArrayAccess; for (var d = !0; d;)for (d = !1, c = 0; c < b.length - 1; c++) { var e = b[c], f = b[c + 1]; e.portToColOffset > f.portToColOffset && (d = !0, b[c] = f, b[c + 1] = e) } for (c = 0; c < b.length; c++)d = b[c], d.valid && (d = d.fromVertex, -1 === d.index && Hs(a, d)) }
    $r.prototype.reduceCrossings = function () {
        var a = this.countCrossings(), b = ls(this), c, d; for (c = 0; c < this.tj; c++) { for (d = 0; d <= this.Ba; d++)Is(this, d, 1), Js(this, d, 1); var e = this.countCrossings(); e < a && (a = e, b = ls(this)); for (d = this.Ba; 0 <= d; d--)Is(this, d, -1), Js(this, d, -1); e = this.countCrossings(); e < a && (a = e, b = ls(this)) } ms(this, b); for (c = 0; c < this.tj; c++) {
            for (d = 0; d <= this.Ba; d++)Is(this, d, 0), Js(this, d, 0); e = this.countCrossings(); e < a && (a = e, b = ls(this)); for (d = this.Ba; 0 <= d; d--)Is(this, d, 0), Js(this, d, 0); e = this.countCrossings();
            e < a && (a = e, b = ls(this))
        } ms(this, b); var f, g, h; switch (this.Ak) {
            case Ks: break; case Ls: for (h = a + 1; (d = this.countCrossings()) < h;)for (h = d, c = this.Ba; 0 <= c; c--)for (g = 0; g <= c; g++) {
                for (f = !0; f;)for (f = !1, d = c; d >= g; d--)f = Js(this, d, -1) || f; e = this.countCrossings(); e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = c; d >= g; d--)f = Js(this, d, 1) || f; e = this.countCrossings(); e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = g; d <= c; d++)f = Js(this, d, 1) || f; e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = g; d <= c; d++)f =
                    Js(this, d, -1) || f; e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = c; d >= g; d--)f = Js(this, d, 0) || f; e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = g; d <= c; d++)f = Js(this, d, 0) || f; e >= a ? ms(this, b) : (a = e, b = ls(this))
            } break; default: case ds: for (c = this.Ba, g = 0, h = a + 1; (d = this.countCrossings()) < h;) {
                h = d; for (f = !0; f;)for (f = !1, d = c; d >= g; d--)f = Js(this, d, -1) || f; e = this.countCrossings(); e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = c; d >= g; d--)f = Js(this, d, 1) || f; e = this.countCrossings(); e >= a ? ms(this, b) :
                    (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = g; d <= c; d++)f = Js(this, d, 1) || f; e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = g; d <= c; d++)f = Js(this, d, -1) || f; e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = c; d >= g; d--)f = Js(this, d, 0) || f; e >= a ? ms(this, b) : (a = e, b = ls(this)); for (f = !0; f;)for (f = !1, d = g; d <= c; d++)f = Js(this, d, 0) || f; e >= a ? ms(this, b) : (a = e, b = ls(this))
            }
        }ms(this, b)
    };
    function Is(a, b, c) {
        E && (B(b, $r, "medianBarycenterCrossingReduction:unfixedLayer"), B(c, $r, "medianBarycenterCrossingReduction:direction")); var d = is(a, b), e = a.hc[b], f = qs(a, b, c), g = ps(a, b, c); for (c = 0; c < e; c++)-1 === g[c] && (g[c] = d[c].column), -1 === f[c] && (f[c] = d[c].column); for (var h = !0, k; h;)for (h = !1, c = 0; c < e - 1; c++)if (f[c + 1] < f[c] || f[c + 1] === f[c] && g[c + 1] < g[c]) h = !0, k = f[c], f[c] = f[c + 1], f[c + 1] = k, k = g[c], g[c] = g[c + 1], g[c + 1] = k, k = d[c], d[c] = d[c + 1], d[c + 1] = k; for (c = f = 0; c < e; c++)k = d[c], k.index = c, f += a.nodeMinColumnSpace(k, !0), k.column =
            f, f += 1, f += a.nodeMinColumnSpace(k, !1); js(a, b, d)
    }
    function Js(a, b, c) {
        var d = is(a, b), e = a.hc[b]; c = ns(a, b, c); var f; var g = []; for (f = 0; f < e; f++)g[f] = -1; var h = []; for (f = 0; f < e; f++)h[f] = -1; for (var k = !1, l = !0; l;)for (l = !1, f = 0; f < e - 1; f++) {
            var m = c[d[f].index * e + d[f + 1].index], n = c[d[f + 1].index * e + d[f].index], p = 0, q = 0, r = d[f].column, u = d[f + 1].column, x = a.nodeMinColumnSpace(d[f], !0), y = a.nodeMinColumnSpace(d[f], !1), A = a.nodeMinColumnSpace(d[f + 1], !0), C = a.nodeMinColumnSpace(d[f + 1], !1); x = r - x + A; y = u - y + C; var G = d[f].sourceEdges.iterator; for (G.reset(); G.next();)if (A = G.value, C = A.fromVertex,
                A.valid && C.layer === b) { for (A = 0; d[A] !== C;)A++; A < f && (p += 2 * (f - A), q += 2 * (f + 1 - A)); A === f + 1 && (p += 1); A > f + 1 && (p += 4 * (A - f), q += 4 * (A - (f + 1))) } G = d[f].destinationEdges.iterator; for (G.reset(); G.next();)if (A = G.value, C = A.toVertex, A.valid && C.layer === b) { for (A = 0; d[A] !== C;)A++; A === f + 1 && (q += 1) } G = d[f + 1].sourceEdges.iterator; for (G.reset(); G.next();)if (A = G.value, C = A.fromVertex, A.valid && C.layer === b) { for (A = 0; d[A] !== C;)A++; A < f && (p += 2 * (f + 1 - A), q += 2 * (f - A)); A === f && (q += 1); A > f + 1 && (p += 4 * (A - (f + 1)), q += 4 * (A - f)) } G = d[f + 1].destinationEdges.iterator;
            for (G.reset(); G.next();)if (A = G.value, C = A.toVertex, A.valid && C.layer === b) { for (A = 0; d[A] !== C;)A++; A === f && (p += 1) } A = C = 0; G = g[d[f].index]; var H = h[d[f].index], O = g[d[f + 1].index], S = h[d[f + 1].index]; -1 !== G && (C += Math.abs(G - r), A += Math.abs(G - y)); -1 !== H && (C += Math.abs(H - r), A += Math.abs(H - y)); -1 !== O && (C += Math.abs(O - u), A += Math.abs(O - x)); -1 !== S && (C += Math.abs(S - u), A += Math.abs(S - x)); if (q < p - .5 || q === p && n < m - .5 || q === p && n === m && A < C - .5) l = k = !0, d[f].column = y, d[f + 1].column = x, m = d[f], d[f] = d[f + 1], d[f + 1] = m
        } for (f = 0; f < e; f++)d[f].index =
            f; js(a, b, d); return k
    }
    $r.prototype.straightenAndPack = function () {
        var a = 0 !== (this.bg & 1); var b = 7 === this.bg; 1E3 < this.network.edges.count && !b && (a = !1); if (a) { var c = []; for (b = 0; b <= this.Ba; b++)c[b] = 0; for (var d, e = this.network.vertexes.iterator; e.next();) { var f = e.value; b = f.layer; d = f.column; f = this.nodeMinColumnSpace(f, !1); c[b] = Math.max(c[b], d + f) } for (e.reset(); e.next();)f = e.value, b = f.layer, d = f.column, f.column = (8 * (this.Ia - c[b]) >> 1) + 8 * d; this.Ia *= 8 } if (0 !== (this.bg & 2)) for (c = !0; c;) {
            c = !1; for (b = this.qd + 1; b <= this.Ba; b++)c = Ms(this, b, 1) || c; for (b =
                this.qd - 1; 0 <= b; b--)c = Ms(this, b, -1) || c; c = Ms(this, this.qd, 0) || c
        } if (0 !== (this.bg & 4)) { for (b = this.qd + 1; b <= this.Ba; b++)Ns(this, b, 1); for (b = this.qd - 1; 0 <= b; b--)Ns(this, b, -1); Ns(this, this.qd, 0) } a && (Os(this, -1), Os(this, 1)); if (0 !== (this.bg & 2)) for (c = !0; c;) { c = !1; c = Ms(this, this.qd, 0) || c; for (b = this.qd + 1; b <= this.Ba; b++)c = Ms(this, b, 0) || c; for (b = this.qd - 1; 0 <= b; b--)c = Ms(this, b, 0) || c }
    };
    function Ms(a, b, c) { E && (B(b, $r, "bendStraighten:unfixedLayer"), B(c, $r, "bendStraighten:direction")); for (var d = !1; Ps(a, b, c);)d = !0; return d }
    function Ps(a, b, c) {
        E && (B(b, $r, "shiftbendStraighten:unfixedLayer"), B(c, $r, "shiftbendStraighten:direction")); var d, e = is(a, b), f = a.hc[b], g = ps(a, b, -1); if (0 < c) for (d = 0; d < f; d++)g[d] = -1; var h = ps(a, b, 1); if (0 > c) for (d = 0; d < f; d++)h[d] = -1; for (var k = !1, l = !0; l;)for (l = !1, d = 0; d < f; d++) {
            var m = e[d].column, n = a.nodeMinColumnSpace(e[d], !0), p = a.nodeMinColumnSpace(e[d], !1), q = 0; 0 > d - 1 || m - e[d - 1].column - 1 > n + a.nodeMinColumnSpace(e[d - 1], !1) ? q = m - 1 : q = m; n = d + 1 >= f || e[d + 1].column - m - 1 > p + a.nodeMinColumnSpace(e[d + 1], !0) ? m + 1 : m; var r = p = 0, u =
                0; if (0 >= c) for (var x = e[d].sourceEdges.iterator; x.next();) { var y = x.value; var A = y.fromVertex; if (y.valid && A.layer !== b) { var C = ks(y); var G = y.portFromColOffset; y = y.portToColOffset; A = A.column; p += (Math.abs(m + y - (A + G)) + 1) * C; r += (Math.abs(q + y - (A + G)) + 1) * C; u += (Math.abs(n + y - (A + G)) + 1) * C } } if (0 <= c) for (x = e[d].destinationEdges.iterator; x.next();)y = x.value, A = y.toVertex, y.valid && A.layer !== b && (C = ks(y), G = y.portFromColOffset, y = y.portToColOffset, A = A.column, p += (Math.abs(m + G - (A + y)) + 1) * C, r += (Math.abs(q + G - (A + y)) + 1) * C, u += (Math.abs(n +
                    G - (A + y)) + 1) * C); y = G = C = 0; x = g[e[d].index]; A = h[e[d].index]; -1 !== x && (C += Math.abs(x - m), G += Math.abs(x - q), y += Math.abs(x - n)); -1 !== A && (C += Math.abs(A - m), G += Math.abs(A - q), y += Math.abs(A - n)); if (r < p || r === p && G < C) l = k = !0, e[d].column = q; else if (u < p || u === p && y < C) l = k = !0, e[d].column = n
        } js(a, b, e); a.normalize(); return k
    }
    function Ns(a, b, c) {
        E && (B(b, $r, "medianStraighten:unfixedLayer"), B(c, $r, "medianStraighten:direction")); var d = is(a, b), e = a.hc[b], f = qs(a, b, c), g = []; for (c = 0; c < e; c++)g[c] = f[c]; for (f = !0; f;)for (f = !1, c = 0; c < e; c++) {
            var h = d[c].column, k = a.nodeMinColumnSpace(d[c], !0), l = a.nodeMinColumnSpace(d[c], !1), m = 0; if (-1 === g[c]) if (0 === c && c === e - 1) m = h; else if (0 === c) { var n = d[c + 1].column; n - h === l + a.nodeMinColumnSpace(d[c + 1], !0) ? m = h - 1 : m = h } else c === e - 1 ? (n = d[c - 1].column, m = h - n === k + a.nodeMinColumnSpace(d[c - 1], !1) ? h + 1 : h) : (n = d[c - 1].column,
                k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, m = (k + l) / 2 | 0); else 0 === c && c === e - 1 ? m = g[c] : 0 === c ? (n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, m = Math.min(g[c], l)) : c === e - 1 ? (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, m = Math.max(g[c], k)) : (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, k < g[c] && g[c] < l ? m = g[c] : k >= g[c] ? m = k : l <= g[c] && (m = l)); m !== h && (f = !0, d[c].column = m)
        } js(a, b,
            d); a.normalize()
    } function Qs(a, b) { E && (B(b, $r, "packAux:column"), B(1, $r, "packAux:direction")); for (var c = !0, d = a.network.vertexes.iterator; d.next();) { var e = d.value, f = a.nodeMinColumnSpace(e, !0), g = a.nodeMinColumnSpace(e, !1); if (e.column - f <= b && e.column + g >= b) { c = !1; break } } a = !1; if (c) for (d.reset(); d.next();)c = d.value, c.column > b && (--c.column, a = !0); return a }
    function Rs(a, b) { E && (B(b, $r, "tightPackAux:column"), B(1, $r, "tightPackAux:direction")); var c = b + 1; var d, e = [], f = []; for (d = 0; d <= a.Ba; d++)e[d] = !1, f[d] = !1; for (var g = a.network.vertexes.iterator; g.next();) { d = g.value; var h = d.column - a.nodeMinColumnSpace(d, !0), k = d.column + a.nodeMinColumnSpace(d, !1); h <= b && k >= b && (e[d.layer] = !0); h <= c && k >= c && (f[d.layer] = !0) } h = !0; c = !1; for (d = 0; d <= a.Ba; d++)h = h && !(e[d] && f[d]); if (h) for (g.reset(); g.next();)a = g.value, a.column > b && (--a.column, c = !0); return c }
    function Os(a, b) { E && B(b, $r, "componentPack:direction"); for (var c = 0; c <= a.Ia; c++)for (; Qs(a, c);); a.normalize(); for (c = 0; c < a.Ia; c++)for (; Rs(a, c);); a.normalize(); var d; if (0 < b) for (c = 0; c <= a.Ia; c++) { var e = ls(a); var f = os(a); for (d = f + 1; f < d;) { d = f; Ss(a, c, 1); var g = os(a); g > f ? ms(a, e) : g < f && (f = g, e = ls(a)) } } if (0 > b) for (c = a.Ia; 0 <= c; c--)for (e = ls(a), f = os(a), d = f + 1; f < d;)d = f, Ss(a, c, -1), g = os(a), g > f ? ms(a, e) : g < f && (f = g, e = ls(a)); a.normalize() }
    function Ss(a, b, c) {
    a.Nd = 0; for (var d = a.network.vertexes.iterator; d.next();)d.value.component = -1; if (0 < c) for (d.reset(); d.next();) { var e = d.value; e.column - a.nodeMinColumnSpace(e, !0) <= b && (e.component = a.Nd) } if (0 > c) for (d.reset(); d.next();)e = d.value, e.column + a.nodeMinColumnSpace(e, !1) >= b && (e.component = a.Nd); a.Nd++; for (d.reset(); d.next();)b = d.value, -1 === b.component && (ss(a, b, a.Nd, -1, !0, !0), a.Nd++); var f; b = []; for (f = 0; f < a.Nd * a.Nd; f++)b[f] = !1; e = []; for (f = 0; f < (a.Ba + 1) * (a.Ia + 1); f++)e[f] = -1; for (d.reset(); d.next();) {
        f =
        d.value; for (var g = f.layer, h = Math.max(0, f.column - a.nodeMinColumnSpace(f, !0)), k = Math.min(a.Ia, f.column + a.nodeMinColumnSpace(f, !1)); h <= k; h++)e[g * (a.Ia + 1) + h] = f.component
    } for (f = 0; f <= a.Ba; f++) { if (0 < c) for (g = 0; g < a.Ia; g++)-1 !== e[f * (a.Ia + 1) + g] && -1 !== e[f * (a.Ia + 1) + g + 1] && e[f * (a.Ia + 1) + g] !== e[f * (a.Ia + 1) + g + 1] && (b[e[f * (a.Ia + 1) + g] * a.Nd + e[f * (a.Ia + 1) + g + 1]] = !0); if (0 > c) for (g = a.Ia; 0 < g; g--)-1 !== e[f * (a.Ia + 1) + g] && -1 !== e[f * (a.Ia + 1) + g - 1] && e[f * (a.Ia + 1) + g] !== e[f * (a.Ia + 1) + g - 1] && (b[e[f * (a.Ia + 1) + g] * a.Nd + e[f * (a.Ia + 1) + g - 1]] = !0) } e =
        []; for (f = 0; f < a.Nd; f++)e[f] = !0; g = []; for (g.push(0); 0 !== g.length;)if (k = g[g.length - 1], g.pop(), e[k]) for (e[k] = !1, f = 0; f < a.Nd; f++)b[k * a.Nd + f] && g.splice(0, 0, f); if (0 < c) for (d.reset(); d.next();)a = d.value, e[a.component] && --a.column; if (0 > c) for (d.reset(); d.next();)c = d.value, e[c.component] && (c.column += 1)
    }
    $r.prototype.commitLayout = function () { if (this.setsPortSpots) for (var a = gs(this, !0), b = gs(this, !1), c = this.network.edges.iterator; c.next();) { var d = c.value.link; null !== d && (d.fromSpot = a, d.toSpot = b) } this.commitNodes(); this.Su(); this.isRouting && this.commitLinks() }; function gs(a, b) { return 270 === a.M ? b ? Vd : de : 90 === a.M ? b ? de : Vd : 180 === a.M ? b ? Wd : Xd : b ? Xd : Wd }
    $r.prototype.commitNodes = function () {
    this.Jd = []; this.od = []; this.nd = []; this.La = []; for (var a = 0; a <= this.Ba; a++)this.Jd[a] = 0, this.od[a] = 0, this.nd[a] = 0, this.La[a] = 0; for (a = this.network.vertexes.iterator; a.next();) { var b = a.value, c = b.layer; this.Jd[c] = Math.max(this.Jd[c], this.nodeMinLayerSpace(b, !0)); this.od[c] = Math.max(this.od[c], this.nodeMinLayerSpace(b, !1)) } b = 0; c = this.me; for (var d = 0; d <= this.Ba; d++) {
        var e = c; 0 >= this.Jd[d] + this.od[d] && (e = 0); 0 < d && (b += e / 2); 90 === this.M || 0 === this.M ? (b += this.od[d], this.nd[d] = b,
            b += this.Jd[d]) : (b += this.Jd[d], this.nd[d] = b, b += this.od[d]); d < this.Ba && (b += e / 2); this.La[d] = b
    } c = b; b = this.arrangementOrigin; for (d = 0; d <= this.Ba; d++)270 === this.M ? this.nd[d] = b.y + this.nd[d] : 90 === this.M ? (this.nd[d] = b.y + c - this.nd[d], this.La[d] = c - this.La[d]) : 180 === this.M ? this.nd[d] = b.x + this.nd[d] : (this.nd[d] = b.x + c - this.nd[d], this.La[d] = c - this.La[d]); a.reset(); for (c = d = Infinity; a.next();) {
        e = a.value; var f = e.layer, g = e.column | 0; if (270 === this.M || 90 === this.M) { var h = b.x + this.Yb * g; f = this.nd[f] } else h = this.nd[f], f = b.y +
            this.Yb * g; e.centerX = h; e.centerY = f; d = Math.min(e.x, d); c = Math.min(e.y, c)
    } d = b.x - d; b = b.y - c; this.ow = new J(d, b); for (a.reset(); a.next();)c = a.value, c.x += d, c.y += b, c.commit()
    };
    $r.prototype.Su = function () {
        for (var a = 0, b = this.me, c = 0; c <= this.Ba; c++)a += this.Jd[c], a += this.od[c]; a += this.Ba * b; b = []; c = this.Yb * this.Ia; for (var d = this.maxLayer; 0 <= d; d--)270 === this.M ? 0 === d ? b.push(new L(0, 0, c, Math.abs(this.La[0]))) : b.push(new L(0, this.La[d - 1], c, Math.abs(this.La[d - 1] - this.La[d]))) : 90 === this.M ? 0 === d ? b.push(new L(0, this.La[0], c, Math.abs(this.La[0] - a))) : b.push(new L(0, this.La[d], c, Math.abs(this.La[d - 1] - this.La[d]))) : 180 === this.M ? 0 === d ? b.push(new L(0, 0, Math.abs(this.La[0]), c)) : b.push(new L(this.La[d -
            1], 0, Math.abs(this.La[d - 1] - this.La[d]), c)) : 0 === d ? b.push(new L(this.La[0], 0, Math.abs(this.La[0] - a), c)) : b.push(new L(this.La[d], 0, Math.abs(this.La[d - 1] - this.La[d]), c)); this.commitLayers(b, this.ow)
    }; $r.prototype.commitLayers = function () { };
    $r.prototype.commitLinks = function () {
        for (var a = this.network.edges.iterator, b; a.next();)b = a.value.link, null !== b && (b.Dh(), b.Xj(), b.nf()); for (a.reset(); a.next();)b = a.value.link, null !== b && b.bj(); for (a.reset(); a.next();) {
            var c = a.value; b = c.link; if (null !== b) {
                b.Dh(); var d = b, e = d.fromNode, f = d.toNode, g = d.fromPort, h = d.toPort; if (null !== e) { var k = e.findVisibleNode(); null !== k && k !== e && (e = k, g = k.port) } if (null !== f) { var l = f.findVisibleNode(); null !== l && l !== f && (f = l, h = l.port) } var m = b.computeSpot(!0, g), n = b.computeSpot(!1,
                    h), p = c.fromVertex, q = c.toVertex; if (c.valid) {
                        if (b.curve === fh && 4 === b.pointsCount) if (p.column === q.column) { var r = b.getLinkPoint(e, g, m, !0, !1, f, h), u = b.getLinkPoint(f, h, n, !1, !1, e, g); r.o() || r.set(e.actualBounds.center); u.o() || u.set(f.actualBounds.center); b.Xj(); b.mf(r.x, r.y); b.mf((2 * r.x + u.x) / 3, (2 * r.y + u.y) / 3); b.mf((r.x + 2 * u.x) / 3, (r.y + 2 * u.y) / 3); b.mf(u.x, u.y) } else {
                            var x = !1, y = !1; null !== g && m === ed && (x = !0); null !== h && n === ed && (y = !0); if (x || y) {
                                var A = b.i(0).x, C = b.i(0).y, G = b.i(3).x, H = b.i(3).y; if (x) {
                                    if (90 === this.M || 270 ===
                                        this.M) { var O = A; var S = (C + H) / 2 } else O = (A + G) / 2, S = C; b.N(1, O, S); var T = b.getLinkPoint(e, g, m, !0, !1, f, h); T.o() || T.set(e.actualBounds.center); b.N(0, T.x, T.y)
                                } if (y) { if (90 === this.M || 270 === this.M) { var ea = G; var Z = (C + H) / 2 } else ea = (A + G) / 2, Z = H; b.N(2, ea, Z); var va = b.getLinkPoint(f, h, n, !1, !1, e, g); va.o() || va.set(f.actualBounds.center); b.N(3, va.x, va.y) }
                            }
                        } b.nf()
                    } else if (p.layer === q.layer) b.nf(); else {
                        var za = !1, U = !1, aa = b.firstPickIndex + 1; if (b.isOrthogonal) { U = !0; var Ja = b.pointsCount; 4 < Ja && b.points.removeRange(2, Ja - 3) } else if (b.curve ===
                            fh) za = !0, Ja = b.pointsCount, 4 < Ja && b.points.removeRange(2, Ja - 3), 4 === Ja && (aa = 2); else { Ja = b.pointsCount; var Eb = m === ed, Xa = n === ed; 2 < Ja && Eb && Xa ? b.points.removeRange(1, Ja - 2) : 3 < Ja && Eb && !Xa ? b.points.removeRange(1, Ja - 3) : 3 < Ja && !Eb && Xa ? b.points.removeRange(2, Ja - 2) : 4 < Ja && !Eb && !Xa && b.points.removeRange(2, Ja - 3) } var Sa; if (c.rev) {
                                for (var Ua; null !== q && p !== q;) {
                                    var hb = Sa = null; for (var kc = q.sourceEdges.iterator; kc.next();) { var rb = kc.value; if (rb.link === c.link && (Sa = rb.fromVertex, hb = rb.toVertex, null === Sa.node)) break } if (Sa !==
                                        p) {
                                            var mb = b.i(aa - 1).x; var cb = b.i(aa - 1).y; var ta = Sa.centerX; var sa = Sa.centerY; if (U) if (180 === this.M || 0 === this.M) if (aa === b.firstPickIndex + 1) b.m(aa++, mb, cb), b.m(aa++, mb, sa); else { if ((null !== hb ? hb.centerY : cb) !== sa) { var wb = this.La[Sa.layer - 1]; b.m(aa++, wb, cb); b.m(aa++, wb, sa) } } else aa === b.firstPickIndex + 1 ? (b.m(aa++, mb, cb), b.m(aa++, ta, cb)) : (null !== hb ? hb.centerX : mb) !== ta && (wb = this.La[Sa.layer - 1], b.m(aa++, mb, wb), b.m(aa++, ta, wb)); else if (aa === b.firstPickIndex + 1) {
                                                var yb = Math.max(10, this.Jd[q.layer]); var db = Math.max(10,
                                                    this.od[q.layer]); if (za) 180 === this.M ? ta <= q.bounds.x ? (Ua = q.bounds.x, b.m(aa++, Ua - yb, sa), b.m(aa++, Ua, sa), b.m(aa++, Ua + db, sa)) : (b.m(aa++, ta - yb, sa), b.m(aa++, ta, sa), b.m(aa++, ta + db, sa)) : 90 === this.M ? sa >= q.bounds.bottom ? (Ua = q.bounds.y + q.bounds.height, b.m(aa++, ta, Ua + db), b.m(aa++, ta, Ua), b.m(aa++, ta, Ua - yb)) : (b.m(aa++, ta, sa + db), b.m(aa++, ta, sa), b.m(aa++, ta, sa - yb)) : 270 === this.M ? sa <= q.bounds.y ? (Ua = q.bounds.y, b.m(aa++, ta, Ua - yb), b.m(aa++, ta, Ua), b.m(aa++, ta, Ua + db)) : (b.m(aa++, ta, sa - yb), b.m(aa++, ta, sa), b.m(aa++, ta, sa +
                                                        db)) : 0 === this.M && (ta >= q.bounds.right ? (Ua = q.bounds.x + q.bounds.width, b.m(aa++, Ua + db, sa), b.m(aa++, Ua, sa), b.m(aa++, Ua - yb, sa)) : (b.m(aa++, ta + db, sa), b.m(aa++, ta, sa), b.m(aa++, ta - yb, sa))); else { b.m(aa++, mb, cb); var qe = 0; if (180 === this.M || 0 === this.M) { if (180 === this.M ? ta >= q.bounds.right : ta <= q.bounds.x) qe = (0 === this.M ? -yb : db) / 2; b.m(aa++, mb + qe, sa) } else { if (270 === this.M ? sa >= q.bounds.bottom : sa <= q.bounds.y) qe = (90 === this.M ? -yb : db) / 2; b.m(aa++, ta, cb + qe) } b.m(aa++, ta, sa) }
                                            } else yb = Math.max(10, this.Jd[Sa.layer]), db = Math.max(10,
                                                this.od[Sa.layer]), 180 === this.M ? (za && b.m(aa++, ta - yb, sa), b.m(aa++, ta, sa), za && b.m(aa++, ta + db, sa)) : 90 === this.M ? (za && b.m(aa++, ta, sa + db), b.m(aa++, ta, sa), za && b.m(aa++, ta, sa - yb)) : 270 === this.M ? (za && b.m(aa++, ta, sa - yb), b.m(aa++, ta, sa), za && b.m(aa++, ta, sa + db)) : (za && b.m(aa++, ta + db, sa), b.m(aa++, ta, sa), za && b.m(aa++, ta - yb, sa))
                                    } q = Sa
                                } if (null === h || m !== ed || U) if (mb = b.i(aa - 1).x, cb = b.i(aa - 1).y, ta = b.i(aa).x, sa = b.i(aa).y, U) {
                                    var Yd = this.od[p.layer]; if (180 === this.M || 0 === this.M) {
                                        var Lb = cb; Lb >= p.bounds.y && Lb <= p.bounds.bottom &&
                                            (180 === this.M ? ta >= p.bounds.x : ta <= p.bounds.right) && (Ua = p.centerX + (180 === this.M ? -Yd : Yd), Lb < p.bounds.y + p.bounds.height / 2 ? Lb = p.bounds.y - this.Yb / 2 : Lb = p.bounds.bottom + this.Yb / 2, b.m(aa++, Ua, cb), b.m(aa++, Ua, Lb)); b.m(aa++, ta, Lb)
                                    } else Lb = mb, Lb >= p.bounds.x && Lb <= p.bounds.right && (270 === this.M ? sa >= p.bounds.y : sa <= p.bounds.bottom) && (Ua = p.centerY + (270 === this.M ? -Yd : Yd), Lb < p.bounds.x + p.bounds.width / 2 ? Lb = p.bounds.x - this.Yb / 2 : Lb = p.bounds.right + this.Yb / 2, b.m(aa++, mb, Ua), b.m(aa++, Lb, Ua)), b.m(aa++, Lb, sa); b.m(aa++, ta, sa)
                                } else if (za) yb =
                                    Math.max(10, this.Jd[p.layer]), db = Math.max(10, this.od[p.layer]), 180 === this.M && ta >= p.bounds.x ? (Ua = p.bounds.x + p.bounds.width, b.N(aa - 2, Ua, cb), b.N(aa - 1, Ua + db, cb)) : 90 === this.M && sa <= p.bounds.bottom ? (Ua = p.bounds.y, b.N(aa - 2, mb, Ua), b.N(aa - 1, mb, Ua - yb)) : 270 === this.M && sa >= p.bounds.y ? (Ua = p.bounds.y + p.bounds.height, b.N(aa - 2, mb, Ua), b.N(aa - 1, mb, Ua + db)) : 0 === this.M && ta <= p.bounds.right && (Ua = p.bounds.x, b.N(aa - 2, Ua, cb), b.N(aa - 1, Ua - yb, cb)); else {
                                        yb = Math.max(10, this.Jd[p.layer]); db = Math.max(10, this.od[p.layer]); var Pf = 0;
                                    if (180 === this.M || 0 === this.M) { if (180 === this.M ? ta <= p.bounds.x : ta >= p.bounds.right) Pf = (0 === this.M ? db : -yb) / 2; b.m(aa++, ta + Pf, cb) } else { if (270 === this.M ? sa <= p.bounds.y : sa >= p.bounds.bottom) Pf = (90 === this.M ? db : -yb) / 2; b.m(aa++, mb, sa + Pf) } b.m(aa++, ta, sa)
                                }
                            } else {
                                for (; null !== p && p !== q;) {
                                    hb = Sa = null; for (var Wb = p.destinationEdges.iterator; Wb.next();) { var De = Wb.value; if (De.link === c.link && (Sa = De.toVertex, hb = De.fromVertex, null !== hb.node && (hb = null), null === Sa.node)) break } Sa !== q && (mb = b.i(aa - 1).x, cb = b.i(aa - 1).y, ta = Sa.centerX,
                                        sa = Sa.centerY, U ? 180 === this.M || 0 === this.M ? (null !== hb ? hb.centerY : cb) !== sa && (wb = this.La[Sa.layer], aa === b.firstPickIndex + 1 && (wb = 0 === this.M ? Math.max(wb, mb) : Math.min(wb, mb)), b.m(aa++, wb, cb), b.m(aa++, wb, sa)) : (null !== hb ? hb.centerX : mb) !== ta && (wb = this.La[Sa.layer], aa === b.firstPickIndex + 1 && (wb = 90 === this.M ? Math.max(wb, cb) : Math.min(wb, cb)), b.m(aa++, mb, wb), b.m(aa++, ta, wb)) : (yb = Math.max(10, this.Jd[Sa.layer]), db = Math.max(10, this.od[Sa.layer]), 180 === this.M ? (b.m(aa++, ta + db, sa), za && b.m(aa++, ta, sa), b.m(aa++, ta - yb, sa)) :
                                            90 === this.M ? (b.m(aa++, ta, sa - yb), za && b.m(aa++, ta, sa), b.m(aa++, ta, sa + db)) : 270 === this.M ? (b.m(aa++, ta, sa + db), za && b.m(aa++, ta, sa), b.m(aa++, ta, sa - yb)) : (b.m(aa++, ta - yb, sa), za && b.m(aa++, ta, sa), b.m(aa++, ta + db, sa)))); p = Sa
                                } U && (mb = b.i(aa - 1).x, cb = b.i(aa - 1).y, ta = b.i(aa).x, sa = b.i(aa).y, 180 === this.M || 0 === this.M ? cb !== sa && (wb = 0 === this.M ? Math.min(Math.max((ta + mb) / 2, this.La[q.layer]), ta) : Math.max(Math.min((ta + mb) / 2, this.La[q.layer]), ta), b.m(aa++, wb, cb), b.m(aa++, wb, sa)) : mb !== ta && (wb = 90 === this.M ? Math.min(Math.max((sa +
                                    cb) / 2, this.La[q.layer]), sa) : Math.max(Math.min((sa + cb) / 2, this.La[q.layer]), sa), b.m(aa++, mb, wb), b.m(aa++, ta, wb)))
                        } if (null !== d && za) {
                            if (null !== g) { if (m === ed) { var id = b.i(0), lc = b.i(2); id.A(lc) || b.N(1, (id.x + lc.x) / 2, (id.y + lc.y) / 2) } var Zd = b.getLinkPoint(e, g, ed, !0, !1, f, h); Zd.o() || Zd.set(e.actualBounds.center); b.N(0, Zd.x, Zd.y) } if (null !== h) {
                                if (n === ed) { var Wc = b.i(b.pointsCount - 1), Ze = b.i(b.pointsCount - 3); Wc.A(Ze) || b.N(b.pointsCount - 2, (Wc.x + Ze.x) / 2, (Wc.y + Ze.y) / 2) } var $e = b.getLinkPoint(f, h, ed, !1, !1, e, g); $e.o() || $e.set(f.actualBounds.center);
                                b.N(b.pointsCount - 1, $e.x, $e.y)
                            }
                        } b.nf(); c.commit()
                    }
            }
        } for (var Qf = new F, wf = this.network.edges.iterator; wf.next();) { var Rf = wf.value.link; null !== Rf && Rf.isOrthogonal && !Qf.contains(Rf) && Qf.add(Rf) } if (0 < Qf.count) if (90 === this.M || 270 === this.M) {
            for (var mc = 0, ob = [], nb, Nc, Sf = Qf.iterator; Sf.next();) {
                var zc = Sf.value; if (null !== zc && zc.isOrthogonal) for (var $d = 2; $d < zc.pointsCount - 3; $d++)if (nb = zc.i($d), Nc = zc.i($d + 1), this.B(nb.y, Nc.y) && !this.B(nb.x, Nc.x)) {
                    var Ic = new Ts; Ic.layer = Math.floor(nb.y / 2); var ae = zc.i(0), nc = zc.i(zc.pointsCount -
                        1); Ic.first = ae.x * ae.x + ae.y; Ic.Ub = nc.x * nc.x + nc.y; Ic.Vc = Math.min(nb.x, Nc.x); Ic.uc = Math.max(nb.x, Nc.x); Ic.index = $d; Ic.link = zc; if ($d + 2 < zc.pointsCount) { var Zh = zc.i($d - 1), $h = zc.i($d + 2), af = 0; Zh.y < nb.y ? af = $h.y < nb.y ? 3 : nb.x < Nc.x ? 2 : 1 : Zh.y > nb.y && (af = $h.y > nb.y ? 0 : Nc.x < nb.x ? 2 : 1); Ic.l = af } ob.push(Ic)
                }
            } if (1 < ob.length) {
                ob.sort(this.Jx); for (var Fb = 0; Fb < ob.length;) {
                    for (var Tf = ob[Fb].layer, bf = Fb + 1; bf < ob.length && ob[bf].layer === Tf;)bf++; if (1 < bf - Fb) for (var oc = Fb; oc < bf;) {
                        for (var cf = ob[oc].uc, $c = Fb + 1; $c < bf && ob[$c].Vc < cf;)cf =
                            Math.max(cf, ob[$c].uc), $c++; var vb = $c - oc; if (1 < vb) {
                                this.Zi(ob, this.xt, oc, oc + vb); for (var df = 1, Ib = ob[oc].Ub, Jc = oc; Jc < $c; Jc++) { var zb = ob[Jc]; zb.Ub !== Ib && (df++ , Ib = zb.Ub) } this.Zi(ob, this.Ix, oc, oc + vb); var jd = 1; Ib = ob[oc].first; for (var kd = oc; kd < $c; kd++) { var Jd = ob[kd]; Jd.first !== Ib && (jd++ , Ib = Jd.first) } var Vg = !0, Uf = jd; df < jd ? (Vg = !1, Uf = df, Ib = ob[oc].Ub, this.Zi(ob, this.xt, oc, oc + vb)) : Ib = ob[oc].first; for (var Vf = 0, xf = oc; xf < $c; xf++) {
                                    var xd = ob[xf]; (Vg ? xd.first : xd.Ub) !== Ib && (Vf++ , Ib = Vg ? xd.first : xd.Ub); var Kd = xd.link;
                                    nb = Kd.i(xd.index); Nc = Kd.i(xd.index + 1); var ad = this.linkSpacing * (Vf - (Uf - 1) / 2); if (!Kd.isAvoiding || Us(nb.x, nb.y + ad, Nc.x, Nc.y + ad)) mc++ , Kd.Dh(), Kd.N(xd.index, nb.x, nb.y + ad), Kd.N(xd.index + 1, Nc.x, Nc.y + ad), Kd.nf()
                                }
                            } oc = $c
                    } Fb = bf
                }
            }
        } else {
            for (var yd = 0, Ab = [], pb, bd, ld = Qf.iterator; ld.next();) {
                var zd = ld.value; if (null !== zd && zd.isOrthogonal) for (var Oc = 2; Oc < zd.pointsCount - 3; Oc++)if (pb = zd.i(Oc), bd = zd.i(Oc + 1), this.B(pb.x, bd.x) && !this.B(pb.y, bd.y)) {
                    var Pa = new Ts; Pa.layer = Math.floor(pb.x / 2); var md = zd.i(0), pc = zd.i(zd.pointsCount -
                        1); Pa.first = md.x + md.y * md.y; Pa.Ub = pc.x + pc.y * pc.y; Pa.Vc = Math.min(pb.y, bd.y); Pa.uc = Math.max(pb.y, bd.y); Pa.index = Oc; Pa.link = zd; if (Oc + 2 < zd.pointsCount) { var re = zd.i(Oc - 1), ef = zd.i(Oc + 2), se = 0; re.x < pb.x ? se = ef.x < pb.x ? 3 : pb.y < bd.y ? 2 : 1 : re.x > pb.x && (se = ef.x > pb.x ? 0 : bd.y < pb.y ? 2 : 1); Pa.l = se } Ab.push(Pa)
                }
            } if (1 < Ab.length) {
                Ab.sort(this.Jx); for (var Pc = 0; Pc < Ab.length;) {
                    for (var Ee = Ab[Pc].layer, nd = Pc + 1; nd < Ab.length && Ab[nd].layer === Ee;)nd++; if (1 < nd - Pc) for (var Mb = Pc; Mb < nd;) {
                        for (var be = Ab[Mb].uc, bc = Pc + 1; bc < nd && Ab[bc].Vc < be;)be =
                            Math.max(be, Ab[bc].uc), bc++; var Fe = bc - Mb; if (1 < Fe) {
                                this.Zi(Ab, this.xt, Mb, Mb + Fe); for (var Ld = 1, te = Ab[Mb].Ub, Wg = Mb; Wg < bc; Wg++) { var od = Ab[Wg]; od.Ub !== te && (Ld++ , te = od.Ub) } this.Zi(Ab, this.Ix, Mb, Mb + Fe); var ff = 1; te = Ab[Mb].first; for (var Wf = Mb; Wf < bc; Wf++) { var Xf = Ab[Wf]; Xf.first !== te && (ff++ , te = Xf.first) } var gf = !0, Xg = ff; Ld < ff ? (gf = !1, Xg = Ld, te = Ab[Mb].Ub, this.Zi(Ab, this.xt, Mb, Mb + Fe)) : te = Ab[Mb].first; for (var rg = 0, $i = Mb; $i < bc; $i++) {
                                    var hf = Ab[$i]; (gf ? hf.first : hf.Ub) !== te && (rg++ , te = gf ? hf.first : hf.Ub); var Ge = hf.link;
                                    pb = Ge.i(hf.index); bd = Ge.i(hf.index + 1); var sg = this.linkSpacing * (rg - (Xg - 1) / 2); if (!Ge.isAvoiding || Us(pb.x + sg, pb.y, bd.x + sg, bd.y)) yd++ , Ge.Dh(), Ge.N(hf.index, pb.x + sg, pb.y), Ge.N(hf.index + 1, bd.x + sg, bd.y), Ge.nf()
                                }
                            } Mb = bc
                    } Pc = nd
                }
            }
        }
    }; t = $r.prototype; t.Jx = function (a, b) { return a instanceof Ts && b instanceof Ts && a !== b ? a.layer < b.layer ? -1 : a.layer > b.layer ? 1 : a.Vc < b.Vc ? -1 : a.Vc > b.Vc ? 1 : a.uc < b.uc ? -1 : a.uc > b.uc ? 1 : 0 : 0 };
    t.Ix = function (a, b) { return a instanceof Ts && b instanceof Ts && a !== b ? a.first < b.first ? -1 : a.first > b.first || a.l < b.l ? 1 : a.l > b.l || a.Vc < b.Vc ? -1 : a.Vc > b.Vc ? 1 : a.uc < b.uc ? -1 : a.uc > b.uc ? 1 : 0 : 0 }; t.xt = function (a, b) { return a instanceof Ts && b instanceof Ts && a !== b ? a.Ub < b.Ub ? -1 : a.Ub > b.Ub || a.l < b.l ? 1 : a.l > b.l || a.Vc < b.Vc ? -1 : a.Vc > b.Vc ? 1 : a.uc < b.uc ? -1 : a.uc > b.uc ? 1 : 0 : 0 }; t.B = function (a, b) { E && (B(a, $r, "isApprox:a"), B(b, $r, "isApprox:b")); a -= b; return -1 < a && 1 > a };
    t.Zi = function (a, b, c, d) { var e = a.length, f = d - c; if (!(1 >= f)) if ((0 > c || c >= e - 1) && v("not in range 0 <= from < length: " + c), 2 === f) d = a[c], e = a[c + 1], 0 < b(d, e) && (a[c] = e, a[c + 1] = d); else if (0 === c) if (d >= e) a.sort(b); else for (c = a.slice(0, d),